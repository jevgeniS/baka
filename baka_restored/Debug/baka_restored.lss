
baka_restored.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004d34  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00404d34  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000a48  2000043c  00405170  0001043c  2**2
                  ALLOC
  3 .stack        00003004  20000e84  00405bb8  0001043c  2**0
                  ALLOC
  4 .ARM.attributes 0000002f  00000000  00000000  0001043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000033  00000000  00000000  0001046b  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001074d  00000000  00000000  0001049e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000313e  00000000  00000000  00020beb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00008c6c  00000000  00000000  00023d29  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000ba0  00000000  00000000  0002c995  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000de0  00000000  00000000  0002d535  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001c29e  00000000  00000000  0002e315  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed25  00000000  00000000  0004a5b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004f33e  00000000  00000000  000592d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001954  00000000  00000000  000a8618  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20003e88 	.word	0x20003e88
  400004:	00402151 	.word	0x00402151
  400008:	0040214d 	.word	0x0040214d
  40000c:	0040214d 	.word	0x0040214d
  400010:	0040214d 	.word	0x0040214d
  400014:	0040214d 	.word	0x0040214d
  400018:	0040214d 	.word	0x0040214d
	...
  40002c:	0040214d 	.word	0x0040214d
  400030:	0040214d 	.word	0x0040214d
  400034:	00000000 	.word	0x00000000
  400038:	0040214d 	.word	0x0040214d
  40003c:	00404231 	.word	0x00404231
  400040:	0040214d 	.word	0x0040214d
  400044:	0040214d 	.word	0x0040214d
  400048:	0040214d 	.word	0x0040214d
  40004c:	0040214d 	.word	0x0040214d
  400050:	0040214d 	.word	0x0040214d
  400054:	0040214d 	.word	0x0040214d
  400058:	0040214d 	.word	0x0040214d
  40005c:	0040214d 	.word	0x0040214d
  400060:	0040214d 	.word	0x0040214d
  400064:	0040214d 	.word	0x0040214d
  400068:	0040214d 	.word	0x0040214d
  40006c:	00401f35 	.word	0x00401f35
  400070:	00401f51 	.word	0x00401f51
  400074:	00401f6d 	.word	0x00401f6d
  400078:	0040214d 	.word	0x0040214d
  40007c:	0040214d 	.word	0x0040214d
  400080:	0040214d 	.word	0x0040214d
  400084:	0040214d 	.word	0x0040214d
  400088:	0040214d 	.word	0x0040214d
  40008c:	0040214d 	.word	0x0040214d
  400090:	0040214d 	.word	0x0040214d
  400094:	0040214d 	.word	0x0040214d
  400098:	0040214d 	.word	0x0040214d
  40009c:	0040214d 	.word	0x0040214d
  4000a0:	0040214d 	.word	0x0040214d
  4000a4:	0040214d 	.word	0x0040214d
  4000a8:	0040214d 	.word	0x0040214d
  4000ac:	0040214d 	.word	0x0040214d
  4000b0:	0040214d 	.word	0x0040214d
  4000b4:	0040214d 	.word	0x0040214d
  4000b8:	0040214d 	.word	0x0040214d
  4000bc:	0040214d 	.word	0x0040214d
  4000c0:	0040214d 	.word	0x0040214d
  4000c4:	0040214d 	.word	0x0040214d
  4000c8:	0040214d 	.word	0x0040214d
  4000cc:	0040214d 	.word	0x0040214d

004000d0 <deregister_tm_clones>:
  4000d0:	b508      	push	{r3, lr}
  4000d2:	4805      	ldr	r0, [pc, #20]	; (4000e8 <deregister_tm_clones+0x18>)
  4000d4:	4b05      	ldr	r3, [pc, #20]	; (4000ec <deregister_tm_clones+0x1c>)
  4000d6:	1a1b      	subs	r3, r3, r0
  4000d8:	2b06      	cmp	r3, #6
  4000da:	d800      	bhi.n	4000de <deregister_tm_clones+0xe>
  4000dc:	bd08      	pop	{r3, pc}
  4000de:	4b04      	ldr	r3, [pc, #16]	; (4000f0 <deregister_tm_clones+0x20>)
  4000e0:	2b00      	cmp	r3, #0
  4000e2:	d0fb      	beq.n	4000dc <deregister_tm_clones+0xc>
  4000e4:	4798      	blx	r3
  4000e6:	e7f9      	b.n	4000dc <deregister_tm_clones+0xc>
  4000e8:	00404d34 	.word	0x00404d34
  4000ec:	00404d37 	.word	0x00404d37
  4000f0:	00000000 	.word	0x00000000

004000f4 <register_tm_clones>:
  4000f4:	b508      	push	{r3, lr}
  4000f6:	4807      	ldr	r0, [pc, #28]	; (400114 <register_tm_clones+0x20>)
  4000f8:	4b07      	ldr	r3, [pc, #28]	; (400118 <register_tm_clones+0x24>)
  4000fa:	1a1b      	subs	r3, r3, r0
  4000fc:	109b      	asrs	r3, r3, #2
  4000fe:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
  400102:	1059      	asrs	r1, r3, #1
  400104:	d100      	bne.n	400108 <register_tm_clones+0x14>
  400106:	bd08      	pop	{r3, pc}
  400108:	4a04      	ldr	r2, [pc, #16]	; (40011c <register_tm_clones+0x28>)
  40010a:	2a00      	cmp	r2, #0
  40010c:	d0fb      	beq.n	400106 <register_tm_clones+0x12>
  40010e:	4790      	blx	r2
  400110:	e7f9      	b.n	400106 <register_tm_clones+0x12>
  400112:	bf00      	nop
  400114:	00404d34 	.word	0x00404d34
  400118:	00404d34 	.word	0x00404d34
  40011c:	00000000 	.word	0x00000000

00400120 <__do_global_dtors_aux>:
  400120:	b510      	push	{r4, lr}
  400122:	4c06      	ldr	r4, [pc, #24]	; (40013c <__do_global_dtors_aux+0x1c>)
  400124:	7823      	ldrb	r3, [r4, #0]
  400126:	b943      	cbnz	r3, 40013a <__do_global_dtors_aux+0x1a>
  400128:	f7ff ffd2 	bl	4000d0 <deregister_tm_clones>
  40012c:	4b04      	ldr	r3, [pc, #16]	; (400140 <__do_global_dtors_aux+0x20>)
  40012e:	b113      	cbz	r3, 400136 <__do_global_dtors_aux+0x16>
  400130:	4804      	ldr	r0, [pc, #16]	; (400144 <__do_global_dtors_aux+0x24>)
  400132:	f3af 8000 	nop.w
  400136:	2301      	movs	r3, #1
  400138:	7023      	strb	r3, [r4, #0]
  40013a:	bd10      	pop	{r4, pc}
  40013c:	2000043c 	.word	0x2000043c
  400140:	00000000 	.word	0x00000000
  400144:	00404d34 	.word	0x00404d34

00400148 <frame_dummy>:
  400148:	b508      	push	{r3, lr}
  40014a:	4b08      	ldr	r3, [pc, #32]	; (40016c <frame_dummy+0x24>)
  40014c:	b11b      	cbz	r3, 400156 <frame_dummy+0xe>
  40014e:	4808      	ldr	r0, [pc, #32]	; (400170 <frame_dummy+0x28>)
  400150:	4908      	ldr	r1, [pc, #32]	; (400174 <frame_dummy+0x2c>)
  400152:	f3af 8000 	nop.w
  400156:	4808      	ldr	r0, [pc, #32]	; (400178 <frame_dummy+0x30>)
  400158:	6803      	ldr	r3, [r0, #0]
  40015a:	b113      	cbz	r3, 400162 <frame_dummy+0x1a>
  40015c:	4b07      	ldr	r3, [pc, #28]	; (40017c <frame_dummy+0x34>)
  40015e:	b103      	cbz	r3, 400162 <frame_dummy+0x1a>
  400160:	4798      	blx	r3
  400162:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400166:	f7ff bfc5 	b.w	4000f4 <register_tm_clones>
  40016a:	bf00      	nop
  40016c:	00000000 	.word	0x00000000
  400170:	00404d34 	.word	0x00404d34
  400174:	20000440 	.word	0x20000440
  400178:	00404d34 	.word	0x00404d34
  40017c:	00000000 	.word	0x00000000

00400180 <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{
  400180:	b538      	push	{r3, r4, r5, lr}
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
	
	WDT->WDT_MR = WDT_MR_WDDIS;
  400182:	f241 4350 	movw	r3, #5200	; 0x1450
  400186:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40018a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40018e:	605a      	str	r2, [r3, #4]
	

	/* Configure pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  400190:	f04f 0000 	mov.w	r0, #0
  400194:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400198:	f641 5465 	movw	r4, #7525	; 0x1d65
  40019c:	f2c0 0440 	movt	r4, #64	; 0x40
  4001a0:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  4001a2:	f04f 0006 	mov.w	r0, #6
  4001a6:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4001aa:	47a0      	blx	r4
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
  4001ac:	f04f 0005 	mov.w	r0, #5
  4001b0:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4001b4:	47a0      	blx	r4
	gpio_configure_pin(SS0_GPIO, SS0_FLAGS);
  4001b6:	f04f 050a 	mov.w	r5, #10
  4001ba:	f6c2 0500 	movt	r5, #10240	; 0x2800
  4001be:	f04f 0013 	mov.w	r0, #19
  4001c2:	4629      	mov	r1, r5
  4001c4:	47a0      	blx	r4
	gpio_configure_pin(SS1_GPIO, SS1_FLAGS);
  4001c6:	f04f 0016 	mov.w	r0, #22
  4001ca:	4629      	mov	r1, r5
  4001cc:	47a0      	blx	r4
	gpio_configure_pin(SS2_GPIO, SS2_FLAGS);
  4001ce:	f04f 0017 	mov.w	r0, #23
  4001d2:	4629      	mov	r1, r5
  4001d4:	47a0      	blx	r4
	gpio_configure_pin(SS3_GPIO, SS3_FLAGS);
  4001d6:	f04f 0014 	mov.w	r0, #20
  4001da:	4629      	mov	r1, r5
  4001dc:	47a0      	blx	r4
	gpio_configure_pin(SS4_GPIO, SS4_FLAGS);
  4001de:	f04f 000f 	mov.w	r0, #15
  4001e2:	4629      	mov	r1, r5
  4001e4:	47a0      	blx	r4
	gpio_configure_pin(SS5_GPIO, SS5_FLAGS);
  4001e6:	f04f 000e 	mov.w	r0, #14
  4001ea:	4629      	mov	r1, r5
  4001ec:	47a0      	blx	r4
	gpio_configure_pin(SS6_GPIO, SS6_FLAGS);
  4001ee:	f04f 000d 	mov.w	r0, #13
  4001f2:	4629      	mov	r1, r5
  4001f4:	47a0      	blx	r4
	gpio_configure_pin(SS7_GPIO, SS7_FLAGS);
  4001f6:	f04f 0018 	mov.w	r0, #24
  4001fa:	4629      	mov	r1, r5
  4001fc:	47a0      	blx	r4
	gpio_configure_pin(BUT0_GPIO, BUT0_FLAGS);
  4001fe:	f04f 0010 	mov.w	r0, #16
  400202:	4629      	mov	r1, r5
  400204:	47a0      	blx	r4
	gpio_configure_pin(D0_GPIO, D0_FLAGS);
  400206:	f04f 000c 	mov.w	r0, #12
  40020a:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  40020e:	47a0      	blx	r4
	gpio_configure_pin(D1_GPIO, D1_FLAGS);
  400210:	f04f 000b 	mov.w	r0, #11
  400214:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400218:	47a0      	blx	r4
	gpio_configure_pin(D2_GPIO, D2_FLAGS);
  40021a:	f04f 000a 	mov.w	r0, #10
  40021e:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400222:	47a0      	blx	r4
	gpio_configure_pin(D3_GPIO, D3_FLAGS);
  400224:	f04f 0009 	mov.w	r0, #9
  400228:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  40022c:	47a0      	blx	r4
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  40022e:	f04f 001c 	mov.w	r0, #28
  400232:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400236:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  400238:	f04f 001d 	mov.w	r0, #29
  40023c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400240:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  400242:	f04f 001e 	mov.w	r0, #30
  400246:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40024a:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  40024c:	f04f 001f 	mov.w	r0, #31
  400250:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400254:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  400256:	f04f 001a 	mov.w	r0, #26
  40025a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40025e:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  400260:	f04f 001b 	mov.w	r0, #27
  400264:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400268:	47a0      	blx	r4
  40026a:	bd38      	pop	{r3, r4, r5, pc}

0040026c <sd_mmc_test_unit_ready>:
 * \name Control Interface
 * @{
 */

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  40026c:	b510      	push	{r4, lr}
  40026e:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  400270:	f240 6351 	movw	r3, #1617	; 0x651
  400274:	f2c0 0340 	movt	r3, #64	; 0x40
  400278:	4798      	blx	r3
  40027a:	2801      	cmp	r0, #1
  40027c:	d005      	beq.n	40028a <sd_mmc_test_unit_ready+0x1e>
  40027e:	b138      	cbz	r0, 400290 <sd_mmc_test_unit_ready+0x24>

	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
  400280:	2802      	cmp	r0, #2
  400282:	bf0c      	ite	eq
  400284:	2002      	moveq	r0, #2
  400286:	2001      	movne	r0, #1
  400288:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  40028a:	f04f 0003 	mov.w	r0, #3
  40028e:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  400290:	4620      	mov	r0, r4
  400292:	f241 03fd 	movw	r3, #4349	; 0x10fd
  400296:	f2c0 0340 	movt	r3, #64	; 0x40
  40029a:	4798      	blx	r3
  40029c:	f000 0003 	and.w	r0, r0, #3
			return CTRL_GOOD;
  4002a0:	2800      	cmp	r0, #0
  4002a2:	bf0c      	ite	eq
  4002a4:	2002      	moveq	r0, #2
  4002a6:	2000      	movne	r0, #0
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  4002a8:	bd10      	pop	{r4, pc}
  4002aa:	bf00      	nop

004002ac <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  4002ac:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  4002ae:	f04f 0000 	mov.w	r0, #0
  4002b2:	f240 236d 	movw	r3, #621	; 0x26d
  4002b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4002ba:	4798      	blx	r3
}
  4002bc:	bd08      	pop	{r3, pc}
  4002be:	bf00      	nop

004002c0 <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  4002c0:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  4002c2:	f04f 0001 	mov.w	r0, #1
  4002c6:	f240 236d 	movw	r3, #621	; 0x26d
  4002ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4002ce:	4798      	blx	r3
}
  4002d0:	bd08      	pop	{r3, pc}
  4002d2:	bf00      	nop

004002d4 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  4002d4:	b538      	push	{r3, r4, r5, lr}
  4002d6:	4604      	mov	r4, r0
  4002d8:	460d      	mov	r5, r1
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  4002da:	f241 1329 	movw	r3, #4393	; 0x1129
  4002de:	f2c0 0340 	movt	r3, #64	; 0x40
  4002e2:	4798      	blx	r3
  4002e4:	ea4f 0040 	mov.w	r0, r0, lsl #1
  4002e8:	f100 30ff 	add.w	r0, r0, #4294967295
  4002ec:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  4002ee:	4620      	mov	r0, r4
  4002f0:	f240 236d 	movw	r3, #621	; 0x26d
  4002f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4002f8:	4798      	blx	r3
}
  4002fa:	bd38      	pop	{r3, r4, r5, pc}

004002fc <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  4002fc:	b508      	push	{r3, lr}
  4002fe:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  400300:	f04f 0000 	mov.w	r0, #0
  400304:	f240 23d5 	movw	r3, #725	; 0x2d5
  400308:	f2c0 0340 	movt	r3, #64	; 0x40
  40030c:	4798      	blx	r3
}
  40030e:	bd08      	pop	{r3, pc}

00400310 <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  400310:	b508      	push	{r3, lr}
  400312:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  400314:	f04f 0001 	mov.w	r0, #1
  400318:	f240 23d5 	movw	r3, #725	; 0x2d5
  40031c:	f2c0 0340 	movt	r3, #64	; 0x40
  400320:	4798      	blx	r3
}
  400322:	bd08      	pop	{r3, pc}

00400324 <sd_mmc_wr_protect>:

bool sd_mmc_wr_protect(uint8_t slot)
{
  400324:	b508      	push	{r3, lr}
	return sd_mmc_is_write_protected(slot);
  400326:	f241 1355 	movw	r3, #4437	; 0x1155
  40032a:	f2c0 0340 	movt	r3, #64	; 0x40
  40032e:	4798      	blx	r3
}
  400330:	bd08      	pop	{r3, pc}
  400332:	bf00      	nop

00400334 <sd_mmc_wr_protect_0>:

bool sd_mmc_wr_protect_0(void)
{
  400334:	b508      	push	{r3, lr}
	return sd_mmc_wr_protect(0);
  400336:	f04f 0000 	mov.w	r0, #0
  40033a:	f240 3325 	movw	r3, #805	; 0x325
  40033e:	f2c0 0340 	movt	r3, #64	; 0x40
  400342:	4798      	blx	r3
}
  400344:	bd08      	pop	{r3, pc}
  400346:	bf00      	nop

00400348 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  400348:	b508      	push	{r3, lr}
	return sd_mmc_wr_protect(1);
  40034a:	f04f 0001 	mov.w	r0, #1
  40034e:	f240 3325 	movw	r3, #805	; 0x325
  400352:	f2c0 0340 	movt	r3, #64	; 0x40
  400356:	4798      	blx	r3
}
  400358:	bd08      	pop	{r3, pc}
  40035a:	bf00      	nop

0040035c <sd_mmc_removal>:

bool sd_mmc_removal(uint8_t slot)
{
	UNUSED(slot);
	return false;
}
  40035c:	f04f 0000 	mov.w	r0, #0
  400360:	4770      	bx	lr
  400362:	bf00      	nop

00400364 <sd_mmc_removal_0>:

bool sd_mmc_removal_0(void)
{
  400364:	b508      	push	{r3, lr}
	return sd_mmc_removal(0);
  400366:	f04f 0000 	mov.w	r0, #0
  40036a:	f240 335d 	movw	r3, #861	; 0x35d
  40036e:	f2c0 0340 	movt	r3, #64	; 0x40
  400372:	4798      	blx	r3
}
  400374:	bd08      	pop	{r3, pc}
  400376:	bf00      	nop

00400378 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
  400378:	b508      	push	{r3, lr}
	return sd_mmc_removal(1);
  40037a:	f04f 0001 	mov.w	r0, #1
  40037e:	f240 335d 	movw	r3, #861	; 0x35d
  400382:	f2c0 0340 	movt	r3, #64	; 0x40
  400386:	4798      	blx	r3
}
  400388:	bd08      	pop	{r3, pc}
  40038a:	bf00      	nop

0040038c <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  40038c:	b510      	push	{r4, lr}
  40038e:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  400390:	f04f 0201 	mov.w	r2, #1
  400394:	f241 135d 	movw	r3, #4445	; 0x115d
  400398:	f2c0 0340 	movt	r3, #64	; 0x40
  40039c:	4798      	blx	r3
  40039e:	b120      	cbz	r0, 4003aa <sd_mmc_mem_2_ram+0x1e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  4003a0:	2802      	cmp	r0, #2
  4003a2:	bf0c      	ite	eq
  4003a4:	2002      	moveq	r0, #2
  4003a6:	2001      	movne	r0, #1
  4003a8:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  4003aa:	4620      	mov	r0, r4
  4003ac:	f04f 0101 	mov.w	r1, #1
  4003b0:	f241 2371 	movw	r3, #4721	; 0x1271
  4003b4:	f2c0 0340 	movt	r3, #64	; 0x40
  4003b8:	4798      	blx	r3
  4003ba:	b940      	cbnz	r0, 4003ce <sd_mmc_mem_2_ram+0x42>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks()) {
  4003bc:	f241 23a9 	movw	r3, #4777	; 0x12a9
  4003c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4003c4:	4798      	blx	r3
{
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
  4003c6:	3000      	adds	r0, #0
  4003c8:	bf18      	it	ne
  4003ca:	2001      	movne	r0, #1
  4003cc:	bd10      	pop	{r4, pc}
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
  4003ce:	f04f 0001 	mov.w	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks()) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  4003d2:	bd10      	pop	{r4, pc}

004003d4 <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  4003d4:	b508      	push	{r3, lr}
  4003d6:	4603      	mov	r3, r0
  4003d8:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  4003da:	f04f 0000 	mov.w	r0, #0
  4003de:	4619      	mov	r1, r3
  4003e0:	f240 338d 	movw	r3, #909	; 0x38d
  4003e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4003e8:	4798      	blx	r3
}
  4003ea:	bd08      	pop	{r3, pc}

004003ec <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  4003ec:	b508      	push	{r3, lr}
  4003ee:	4603      	mov	r3, r0
  4003f0:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  4003f2:	f04f 0001 	mov.w	r0, #1
  4003f6:	4619      	mov	r1, r3
  4003f8:	f240 338d 	movw	r3, #909	; 0x38d
  4003fc:	f2c0 0340 	movt	r3, #64	; 0x40
  400400:	4798      	blx	r3
}
  400402:	bd08      	pop	{r3, pc}

00400404 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  400404:	b510      	push	{r4, lr}
  400406:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  400408:	f04f 0201 	mov.w	r2, #1
  40040c:	f241 3329 	movw	r3, #4905	; 0x1329
  400410:	f2c0 0340 	movt	r3, #64	; 0x40
  400414:	4798      	blx	r3
  400416:	b120      	cbz	r0, 400422 <sd_mmc_ram_2_mem+0x1e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  400418:	2802      	cmp	r0, #2
  40041a:	bf0c      	ite	eq
  40041c:	2002      	moveq	r0, #2
  40041e:	2001      	movne	r0, #1
  400420:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  400422:	4620      	mov	r0, r4
  400424:	f04f 0101 	mov.w	r1, #1
  400428:	f241 33f9 	movw	r3, #5113	; 0x13f9
  40042c:	f2c0 0340 	movt	r3, #64	; 0x40
  400430:	4798      	blx	r3
  400432:	b940      	cbnz	r0, 400446 <sd_mmc_ram_2_mem+0x42>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks()) {
  400434:	f241 4331 	movw	r3, #5169	; 0x1431
  400438:	f2c0 0340 	movt	r3, #64	; 0x40
  40043c:	4798      	blx	r3
{
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
  40043e:	3000      	adds	r0, #0
  400440:	bf18      	it	ne
  400442:	2001      	movne	r0, #1
  400444:	bd10      	pop	{r4, pc}
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
  400446:	f04f 0001 	mov.w	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks()) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  40044a:	bd10      	pop	{r4, pc}

0040044c <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  40044c:	b508      	push	{r3, lr}
  40044e:	4603      	mov	r3, r0
  400450:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  400452:	f04f 0000 	mov.w	r0, #0
  400456:	4619      	mov	r1, r3
  400458:	f240 4305 	movw	r3, #1029	; 0x405
  40045c:	f2c0 0340 	movt	r3, #64	; 0x40
  400460:	4798      	blx	r3
}
  400462:	bd08      	pop	{r3, pc}

00400464 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  400464:	b508      	push	{r3, lr}
  400466:	4603      	mov	r3, r0
  400468:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  40046a:	f04f 0001 	mov.w	r0, #1
  40046e:	4619      	mov	r1, r3
  400470:	f240 4305 	movw	r3, #1029	; 0x405
  400474:	f2c0 0340 	movt	r3, #64	; 0x40
  400478:	4798      	blx	r3
}
  40047a:	bd08      	pop	{r3, pc}

0040047c <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  40047c:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  40047e:	f240 435c 	movw	r3, #1116	; 0x45c
  400482:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400486:	681a      	ldr	r2, [r3, #0]
  400488:	f240 4162 	movw	r1, #1122	; 0x462
  40048c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  400490:	7f93      	ldrb	r3, [r2, #30]
  400492:	7808      	ldrb	r0, [r1, #0]
  400494:	6811      	ldr	r1, [r2, #0]
  400496:	7b52      	ldrb	r2, [r2, #13]
  400498:	3300      	adds	r3, #0
  40049a:	bf18      	it	ne
  40049c:	2301      	movne	r3, #1
  40049e:	f241 74a9 	movw	r4, #6057	; 0x17a9
  4004a2:	f2c0 0440 	movt	r4, #64	; 0x40
  4004a6:	47a0      	blx	r4
  4004a8:	bd10      	pop	{r4, pc}
  4004aa:	bf00      	nop

004004ac <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
  4004ac:	b510      	push	{r4, lr}
	if (slot >= SD_MMC_MEM_CNT) {
  4004ae:	2800      	cmp	r0, #0
  4004b0:	d136      	bne.n	400520 <sd_mmc_select_slot+0x74>
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4004b2:	f240 4364 	movw	r3, #1124	; 0x464
  4004b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
  4004ba:	7a9b      	ldrb	r3, [r3, #10]
  4004bc:	f1a3 0303 	sub.w	r3, r3, #3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4004c0:	b2db      	uxtb	r3, r3
  4004c2:	2b01      	cmp	r3, #1
  4004c4:	d811      	bhi.n	4004ea <sd_mmc_select_slot+0x3e>
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  4004c6:	f240 4364 	movw	r3, #1124	; 0x464
  4004ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004ce:	f04f 0202 	mov.w	r2, #2
  4004d2:	729a      	strb	r2, [r3, #10]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  4004d4:	f44f 52d4 	mov.w	r2, #6784	; 0x1a80
  4004d8:	f2c0 0206 	movt	r2, #6
  4004dc:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
  4004de:	f04f 0201 	mov.w	r2, #1
  4004e2:	735a      	strb	r2, [r3, #13]
		sd_mmc_cards[slot].high_speed = 0;
  4004e4:	f04f 0200 	mov.w	r2, #0
  4004e8:	779a      	strb	r2, [r3, #30]
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  4004ea:	f240 4362 	movw	r3, #1122	; 0x462
  4004ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004f2:	f04f 0200 	mov.w	r2, #0
  4004f6:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  4004f8:	f240 435c 	movw	r3, #1116	; 0x45c
  4004fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400500:	f240 4464 	movw	r4, #1124	; 0x464
  400504:	f2c2 0400 	movt	r4, #8192	; 0x2000
  400508:	601c      	str	r4, [r3, #0]
	sd_mmc_configure_slot();
  40050a:	f240 437d 	movw	r3, #1149	; 0x47d
  40050e:	f2c0 0340 	movt	r3, #64	; 0x40
  400512:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  400514:	7aa0      	ldrb	r0, [r4, #10]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  400516:	2802      	cmp	r0, #2
  400518:	bf14      	ite	ne
  40051a:	2000      	movne	r0, #0
  40051c:	2001      	moveq	r0, #1
  40051e:	bd10      	pop	{r4, pc}
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
		return SD_MMC_ERR_SLOT;
  400520:	f04f 0004 	mov.w	r0, #4
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
}
  400524:	bd10      	pop	{r4, pc}
  400526:	bf00      	nop

00400528 <sdio_cmd53>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd53(uint8_t rw_flag, uint8_t func_nb, uint32_t reg_addr,
		uint8_t inc_addr, uint32_t size, bool access_block)
{
  400528:	b570      	push	{r4, r5, r6, lr}
  40052a:	b082      	sub	sp, #8
  40052c:	9c06      	ldr	r4, [sp, #24]
	Assert(size != 0);
	Assert(size <= 512);

	if (size == 512) {
		size = 0; // 0 = 512B on SDIO command
  40052e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  400532:	bf08      	it	eq
  400534:	2400      	moveq	r4, #0
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
  400536:	f249 3635 	movw	r6, #37685	; 0x9335
  40053a:	f2c0 0601 	movt	r6, #1
  40053e:	f241 3535 	movw	r5, #4917	; 0x1335
  400542:	f2c0 0501 	movt	r5, #1
			SDIO_CMD53_IO_W_BYTE_EXTENDED,
			(size << SDIO_CMD53_COUNT)
			| ((uint32_t)reg_addr << SDIO_CMD53_REG_ADDR)
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
  400546:	ea4f 7101 	mov.w	r1, r1, lsl #28
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
			SDIO_CMD53_IO_R_BYTE_EXTENDED :
			SDIO_CMD53_IO_W_BYTE_EXTENDED,
			(size << SDIO_CMD53_COUNT)
			| ((uint32_t)reg_addr << SDIO_CMD53_REG_ADDR)
  40054a:	ea41 2242 	orr.w	r2, r1, r2, lsl #9
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
  40054e:	ea42 71c0 	orr.w	r1, r2, r0, lsl #31
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
  400552:	ea41 6183 	orr.w	r1, r1, r3, lsl #26
	Assert(size <= 512);

	if (size == 512) {
		size = 0; // 0 = 512B on SDIO command
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
  400556:	f89d 301c 	ldrb.w	r3, [sp, #28]
  40055a:	9300      	str	r3, [sp, #0]
  40055c:	2800      	cmp	r0, #0
  40055e:	bf14      	ite	ne
  400560:	4630      	movne	r0, r6
  400562:	4628      	moveq	r0, r5
  400564:	4321      	orrs	r1, r4
  400566:	b2a2      	uxth	r2, r4
  400568:	f04f 0301 	mov.w	r3, #1
  40056c:	f641 04a9 	movw	r4, #6313	; 0x18a9
  400570:	f2c0 0440 	movt	r4, #64	; 0x40
  400574:	47a0      	blx	r4
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
			| ((uint32_t)rw_flag << SDIO_CMD53_RW_FLAG),
			size, 1, access_block);
}
  400576:	b002      	add	sp, #8
  400578:	bd70      	pop	{r4, r5, r6, pc}
  40057a:	bf00      	nop

0040057c <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
  40057c:	b508      	push	{r3, lr}
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40057e:	f240 4362 	movw	r3, #1122	; 0x462
  400582:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400586:	781b      	ldrb	r3, [r3, #0]
  400588:	b933      	cbnz	r3, 400598 <sd_mmc_deselect_slot+0x1c>
		driver_deselect_device(sd_mmc_slot_sel);
  40058a:	f04f 0000 	mov.w	r0, #0
  40058e:	f641 031d 	movw	r3, #6173	; 0x181d
  400592:	f2c0 0340 	movt	r3, #64	; 0x40
  400596:	4798      	blx	r3
  400598:	bd08      	pop	{r3, pc}
  40059a:	bf00      	nop

0040059c <sdio_cmd52>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
  40059c:	b510      	push	{r4, lr}
  40059e:	9c02      	ldr	r4, [sp, #8]
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
  4005a0:	ea4f 2242 	mov.w	r2, r2, lsl #9
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
  4005a4:	ea42 7101 	orr.w	r1, r2, r1, lsl #28
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
  4005a8:	ea41 70c0 	orr.w	r0, r1, r0, lsl #31
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
  4005ac:	ea40 63c3 	orr.w	r3, r0, r3, lsl #27
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
  4005b0:	7821      	ldrb	r1, [r4, #0]
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  4005b2:	f241 3034 	movw	r0, #4916	; 0x1334
  4005b6:	4319      	orrs	r1, r3
  4005b8:	f641 0345 	movw	r3, #6213	; 0x1845
  4005bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4005c0:	4798      	blx	r3
  4005c2:	b140      	cbz	r0, 4005d6 <sdio_cmd52+0x3a>
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
		return false;
	}
	*io_data = driver_get_response() & 0xFF;
  4005c4:	f641 0375 	movw	r3, #6261	; 0x1875
  4005c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4005cc:	4798      	blx	r3
  4005ce:	7020      	strb	r0, [r4, #0]
	return true;
  4005d0:	f04f 0001 	mov.w	r0, #1
  4005d4:	bd10      	pop	{r4, pc}
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
		return false;
  4005d6:	f04f 0000 	mov.w	r0, #0
	}
	*io_data = driver_get_response() & 0xFF;
	return true;
}
  4005da:	bd10      	pop	{r4, pc}

004005dc <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  4005dc:	b508      	push	{r3, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  4005de:	f240 435c 	movw	r3, #1116	; 0x45c
  4005e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005e6:	681b      	ldr	r3, [r3, #0]
  4005e8:	8919      	ldrh	r1, [r3, #8]
  4005ea:	f641 3009 	movw	r0, #6921	; 0x1b09
  4005ee:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4005f2:	f641 0345 	movw	r3, #6213	; 0x1845
  4005f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4005fa:	4798      	blx	r3
  4005fc:	b170      	cbz	r0, 40061c <sd_mmc_cmd9_mci+0x40>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  4005fe:	f240 435c 	movw	r3, #1116	; 0x45c
  400602:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400606:	6818      	ldr	r0, [r3, #0]
  400608:	f100 000e 	add.w	r0, r0, #14
  40060c:	f641 037d 	movw	r3, #6269	; 0x187d
  400610:	f2c0 0340 	movt	r3, #64	; 0x40
  400614:	4798      	blx	r3
	return true;
  400616:	f04f 0001 	mov.w	r0, #1
  40061a:	bd08      	pop	{r3, pc}
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  40061c:	f04f 0000 	mov.w	r0, #0
	}
	driver_get_response_128(sd_mmc_card->csd);
	return true;
}
  400620:	bd08      	pop	{r3, pc}
  400622:	bf00      	nop

00400624 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  400624:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400626:	f240 4364 	movw	r3, #1124	; 0x464
  40062a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40062e:	f04f 0204 	mov.w	r2, #4
  400632:	729a      	strb	r2, [r3, #10]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400634:	f240 4362 	movw	r3, #1122	; 0x462
  400638:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40063c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  400640:	701a      	strb	r2, [r3, #0]
	driver_init();
  400642:	f241 7365 	movw	r3, #5989	; 0x1765
  400646:	f2c0 0340 	movt	r3, #64	; 0x40
  40064a:	4798      	blx	r3
  40064c:	bd08      	pop	{r3, pc}
  40064e:	bf00      	nop

00400650 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  400650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400654:	b095      	sub	sp, #84	; 0x54
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
  400656:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40065a:	f2c0 0340 	movt	r3, #64	; 0x40
  40065e:	4798      	blx	r3
  400660:	4604      	mov	r4, r0
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  400662:	2801      	cmp	r0, #1
  400664:	d006      	beq.n	400674 <sd_mmc_check+0x24>
		sd_mmc_deselect_slot();
  400666:	f240 537d 	movw	r3, #1405	; 0x57d
  40066a:	f2c0 0340 	movt	r3, #64	; 0x40
  40066e:	4798      	blx	r3
		return sd_mmc_err;
  400670:	f000 bd39 	b.w	4010e6 <sd_mmc_check+0xa96>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  400674:	f240 435c 	movw	r3, #1116	; 0x45c
  400678:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40067c:	681b      	ldr	r3, [r3, #0]
  40067e:	f04f 0201 	mov.w	r2, #1
  400682:	72da      	strb	r2, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  400684:	f04f 0500 	mov.w	r5, #0
  400688:	731d      	strb	r5, [r3, #12]
	sd_mmc_card->rca = 0;
  40068a:	811d      	strh	r5, [r3, #8]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  40068c:	f641 0321 	movw	r3, #6177	; 0x1821
  400690:	f2c0 0340 	movt	r3, #64	; 0x40
  400694:	4798      	blx	r3

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400696:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  40069a:	4629      	mov	r1, r5
  40069c:	f641 0345 	movw	r3, #6213	; 0x1845
  4006a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4006a4:	4798      	blx	r3
  4006a6:	2800      	cmp	r0, #0
  4006a8:	f000 849e 	beq.w	400fe8 <sd_mmc_check+0x998>
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  4006ac:	f245 5008 	movw	r0, #21768	; 0x5508
  4006b0:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  4006b4:	f641 0345 	movw	r3, #6213	; 0x1845
  4006b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4006bc:	4798      	blx	r3
  4006be:	2800      	cmp	r0, #0
  4006c0:	f000 84a0 	beq.w	401004 <sd_mmc_check+0x9b4>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  4006c4:	f641 0375 	movw	r3, #6261	; 0x1875
  4006c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4006cc:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  4006ce:	f1b0 3fff 	cmp.w	r0, #4294967295
  4006d2:	f000 849a 	beq.w	40100a <sd_mmc_check+0x9ba>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  4006d6:	ea4f 5000 	mov.w	r0, r0, lsl #20
  4006da:	ea4f 5010 	mov.w	r0, r0, lsr #20
  4006de:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  4006e2:	bf08      	it	eq
  4006e4:	2701      	moveq	r7, #1
	resp = driver_get_response();
	if (resp == 0xFFFFFFFF) {
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  4006e6:	f000 8492 	beq.w	40100e <sd_mmc_check+0x9be>
  4006ea:	f000 bc7d 	b.w	400fe8 <sd_mmc_check+0x998>
	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
		sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
		return true; // No error but card type not updated
	}
	resp = driver_get_response();
  4006ee:	f641 0375 	movw	r3, #6261	; 0x1875
  4006f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006f6:	4798      	blx	r3
  4006f8:	4601      	mov	r1, r0
	if ((resp & OCR_SDIO_NF) == 0) {
  4006fa:	f010 4fe0 	tst.w	r0, #1879048192	; 0x70000000
  4006fe:	f000 8492 	beq.w	401026 <sd_mmc_check+0x9d6>
  400702:	f241 3589 	movw	r5, #5001	; 0x1389
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  400706:	f244 5805 	movw	r8, #17669	; 0x4505
  40070a:	f641 0645 	movw	r6, #6213	; 0x1845
  40070e:	f2c0 0640 	movt	r6, #64	; 0x40
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400712:	f641 0975 	movw	r9, #6261	; 0x1875
  400716:	f2c0 0940 	movt	r9, #64	; 0x40
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  40071a:	4640      	mov	r0, r8
  40071c:	f401 11fc 	and.w	r1, r1, #2064384	; 0x1f8000
  400720:	47b0      	blx	r6
  400722:	2800      	cmp	r0, #0
  400724:	f000 8460 	beq.w	400fe8 <sd_mmc_check+0x998>
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400728:	47c8      	blx	r9
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
  40072a:	1e01      	subs	r1, r0, #0
  40072c:	db03      	blt.n	400736 <sd_mmc_check+0xe6>
			break;
		}
		if (cmd5_retry-- == 0) {
  40072e:	3d01      	subs	r5, #1
  400730:	d1f3      	bne.n	40071a <sd_mmc_check+0xca>
  400732:	f000 bc59 	b.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD5 Timeout on busy\n\r", __func__);
			return false;
		}
	}
	// Update card type at the end of busy
	if ((resp & OCR_SDIO_MP) > 0) {
  400736:	f011 6f00 	tst.w	r1, #134217728	; 0x8000000
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
  40073a:	f240 435c 	movw	r3, #1116	; 0x45c
  40073e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400742:	681b      	ldr	r3, [r3, #0]
  400744:	bf14      	ite	ne
  400746:	2205      	movne	r2, #5
	} else {
		sd_mmc_card->type = CARD_TYPE_SDIO;
  400748:	2204      	moveq	r2, #4
  40074a:	72da      	strb	r2, [r3, #11]
  40074c:	f000 bc6b 	b.w	401026 <sd_mmc_check+0x9d6>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400750:	f640 0535 	movw	r5, #2101	; 0x835
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400754:	f241 1937 	movw	r9, #4407	; 0x1137
  400758:	f04f 0800 	mov.w	r8, #0
  40075c:	f641 0645 	movw	r6, #6213	; 0x1845
  400760:	f2c0 0640 	movt	r6, #64	; 0x40
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400764:	f44f 4a00 	mov.w	sl, #32768	; 0x8000
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400768:	f641 0b75 	movw	fp, #6261	; 0x1875
  40076c:	f2c0 0b40 	movt	fp, #64	; 0x40
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400770:	4648      	mov	r0, r9
  400772:	4641      	mov	r1, r8
  400774:	47b0      	blx	r6
  400776:	2800      	cmp	r0, #0
  400778:	f000 8461 	beq.w	40103e <sd_mmc_check+0x9ee>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  40077c:	4651      	mov	r1, sl
  40077e:	f2c4 011f 	movt	r1, #16415	; 0x401f
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400782:	f244 5029 	movw	r0, #17705	; 0x4529
  400786:	2f00      	cmp	r7, #0
  400788:	bf08      	it	eq
  40078a:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  40078e:	47b0      	blx	r6
  400790:	2800      	cmp	r0, #0
  400792:	f000 8454 	beq.w	40103e <sd_mmc_check+0x9ee>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400796:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  400798:	2800      	cmp	r0, #0
  40079a:	da0e      	bge.n	4007ba <sd_mmc_check+0x16a>
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  40079c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
  4007a0:	f000 8478 	beq.w	401094 <sd_mmc_check+0xa44>
				sd_mmc_card->type |= CARD_TYPE_HC;
  4007a4:	f240 435c 	movw	r3, #1116	; 0x45c
  4007a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007ac:	681b      	ldr	r3, [r3, #0]
  4007ae:	7ada      	ldrb	r2, [r3, #11]
  4007b0:	f042 0208 	orr.w	r2, r2, #8
  4007b4:	72da      	strb	r2, [r3, #11]
  4007b6:	f000 bc6d 	b.w	401094 <sd_mmc_check+0xa44>
			}
			break;
		}
		if (retry-- == 0) {
  4007ba:	3d01      	subs	r5, #1
  4007bc:	d1d8      	bne.n	400770 <sd_mmc_check+0x120>
  4007be:	f000 bc3e 	b.w	40103e <sd_mmc_check+0x9ee>
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4007c2:	f241 0569 	movw	r5, #4201	; 0x1069
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4007c6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
  4007ca:	f2c4 061f 	movt	r6, #16415	; 0x401f
  4007ce:	f244 5801 	movw	r8, #17665	; 0x4501
  4007d2:	f641 0745 	movw	r7, #6213	; 0x1845
  4007d6:	f2c0 0740 	movt	r7, #64	; 0x40
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4007da:	f641 0975 	movw	r9, #6261	; 0x1875
  4007de:	f2c0 0940 	movt	r9, #64	; 0x40
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4007e2:	4640      	mov	r0, r8
  4007e4:	4631      	mov	r1, r6
  4007e6:	47b8      	blx	r7
  4007e8:	2800      	cmp	r0, #0
  4007ea:	f000 8468 	beq.w	4010be <sd_mmc_check+0xa6e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4007ee:	47c8      	blx	r9
		if (resp & OCR_POWER_UP_BUSY) {
  4007f0:	2800      	cmp	r0, #0
  4007f2:	da0d      	bge.n	400810 <sd_mmc_check+0x1c0>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  4007f4:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  4007f8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  4007fc:	f040 8455 	bne.w	4010aa <sd_mmc_check+0xa5a>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  400800:	4ba2      	ldr	r3, [pc, #648]	; (400a8c <sd_mmc_check+0x43c>)
  400802:	681b      	ldr	r3, [r3, #0]
  400804:	7ada      	ldrb	r2, [r3, #11]
  400806:	f042 0208 	orr.w	r2, r2, #8
  40080a:	72da      	strb	r2, [r3, #11]
  40080c:	f000 bc4d 	b.w	4010aa <sd_mmc_check+0xa5a>
			}
			break;
		}
		if (retry-- == 0) {
  400810:	3d01      	subs	r5, #1
  400812:	d1e6      	bne.n	4007e2 <sd_mmc_check+0x192>
  400814:	f000 bc53 	b.w	4010be <sd_mmc_check+0xa6e>
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  400818:	4b9c      	ldr	r3, [pc, #624]	; (400a8c <sd_mmc_check+0x43c>)
  40081a:	681b      	ldr	r3, [r3, #0]
  40081c:	f04f 0201 	mov.w	r2, #1
  400820:	811a      	strh	r2, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  400822:	f241 1003 	movw	r0, #4355	; 0x1103
  400826:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  40082a:	4b99      	ldr	r3, [pc, #612]	; (400a90 <sd_mmc_check+0x440>)
  40082c:	4798      	blx	r3
  40082e:	2800      	cmp	r0, #0
  400830:	f000 8120 	beq.w	400a74 <sd_mmc_check+0x424>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  400834:	4b97      	ldr	r3, [pc, #604]	; (400a94 <sd_mmc_check+0x444>)
  400836:	4798      	blx	r3
  400838:	2800      	cmp	r0, #0
  40083a:	f000 811e 	beq.w	400a7a <sd_mmc_check+0x42a>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  40083e:	4b93      	ldr	r3, [pc, #588]	; (400a8c <sd_mmc_check+0x43c>)
  400840:	681b      	ldr	r3, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400842:	7b9a      	ldrb	r2, [r3, #14]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400844:	f3c2 0283 	ubfx	r2, r2, #2, #4
  400848:	f102 32ff 	add.w	r2, r2, #4294967295
  40084c:	2a03      	cmp	r2, #3
  40084e:	d803      	bhi.n	400858 <sd_mmc_check+0x208>
  400850:	e8df f002 	tbb	[pc, r2]
  400854:	120e0a06 	.word	0x120e0a06
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  400858:	f04f 0212 	mov.w	r2, #18
  40085c:	731a      	strb	r2, [r3, #12]
  40085e:	e00e      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  400860:	f04f 0214 	mov.w	r2, #20
  400864:	731a      	strb	r2, [r3, #12]
  400866:	e00a      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  400868:	f04f 0222 	mov.w	r2, #34	; 0x22
  40086c:	731a      	strb	r2, [r3, #12]
  40086e:	e006      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  400870:	f04f 0230 	mov.w	r2, #48	; 0x30
  400874:	731a      	strb	r2, [r3, #12]
  400876:	e002      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  400878:	f04f 0240 	mov.w	r2, #64	; 0x40
  40087c:	731a      	strb	r2, [r3, #12]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40087e:	7c5a      	ldrb	r2, [r3, #17]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400880:	f002 0007 	and.w	r0, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400884:	4984      	ldr	r1, [pc, #528]	; (400a98 <sd_mmc_check+0x448>)
  400886:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  40088a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  40088e:	fb00 f101 	mul.w	r1, r0, r1
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  400892:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400896:	4881      	ldr	r0, [pc, #516]	; (400a9c <sd_mmc_check+0x44c>)
  400898:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
  40089c:	fb02 f201 	mul.w	r2, r2, r1
  4008a0:	601a      	str	r2, [r3, #0]
  4008a2:	7d99      	ldrb	r1, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008a4:	7d18      	ldrb	r0, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4008a6:	7d5a      	ldrb	r2, [r3, #21]
  4008a8:	ea4f 0282 	mov.w	r2, r2, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008ac:	ea42 2280 	orr.w	r2, r2, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008b0:	ea42 12a1 	orr.w	r2, r2, r1, asr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  4008b4:	ea4f 5202 	mov.w	r2, r2, lsl #20
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  4008b8:	ea4f 5112 	mov.w	r1, r2, lsr #20
  4008bc:	f512 1f80 	cmn.w	r2, #1048576	; 0x100000
  4008c0:	d015      	beq.n	4008ee <sd_mmc_check+0x29e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4008c2:	7e18      	ldrb	r0, [r3, #24]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4008c4:	7dda      	ldrb	r2, [r3, #23]
  4008c6:	ea4f 0242 	mov.w	r2, r2, lsl #1
  4008ca:	ea42 12e0 	orr.w	r2, r2, r0, asr #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4008ce:	f101 0101 	add.w	r1, r1, #1
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4008d2:	f002 0207 	and.w	r2, r2, #7
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4008d6:	f102 0202 	add.w	r2, r2, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4008da:	fa01 f102 	lsl.w	r1, r1, r2
  4008de:	7cda      	ldrb	r2, [r3, #19]
  4008e0:	f002 020f 	and.w	r2, r2, #15
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4008e4:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4008e8:	ea4f 2292 	mov.w	r2, r2, lsr #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4008ec:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4008ee:	8919      	ldrh	r1, [r3, #8]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4008f0:	f243 1007 	movw	r0, #12551	; 0x3107
  4008f4:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4008f8:	4b65      	ldr	r3, [pc, #404]	; (400a90 <sd_mmc_check+0x440>)
  4008fa:	4798      	blx	r3
  4008fc:	2800      	cmp	r0, #0
  4008fe:	f000 80bf 	beq.w	400a80 <sd_mmc_check+0x430>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  400902:	4b62      	ldr	r3, [pc, #392]	; (400a8c <sd_mmc_check+0x43c>)
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	7b1b      	ldrb	r3, [r3, #12]
  400908:	2b3f      	cmp	r3, #63	; 0x3f
  40090a:	f240 809b 	bls.w	400a44 <sd_mmc_check+0x3f4>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  40090e:	f04f 0100 	mov.w	r1, #0
  400912:	9100      	str	r1, [sp, #0]
  400914:	f241 1008 	movw	r0, #4360	; 0x1108
  400918:	f2c0 0008 	movt	r0, #8
  40091c:	f44f 7200 	mov.w	r2, #512	; 0x200
  400920:	f04f 0301 	mov.w	r3, #1
  400924:	4d5e      	ldr	r5, [pc, #376]	; (400aa0 <sd_mmc_check+0x450>)
  400926:	47a8      	blx	r5
  400928:	2800      	cmp	r0, #0
  40092a:	f000 83cb 	beq.w	4010c4 <sd_mmc_check+0xa74>
  40092e:	f04f 0500 	mov.w	r5, #0
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  400932:	4e5c      	ldr	r6, [pc, #368]	; (400aa4 <sd_mmc_check+0x454>)
  400934:	a802      	add	r0, sp, #8
  400936:	47b0      	blx	r6
  400938:	2800      	cmp	r0, #0
  40093a:	f000 83c3 	beq.w	4010c4 <sd_mmc_check+0xa74>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  40093e:	f105 0501 	add.w	r5, r5, #1
  400942:	b2ad      	uxth	r5, r5
  400944:	2d32      	cmp	r5, #50	; 0x32
  400946:	d1f5      	bne.n	400934 <sd_mmc_check+0x2e4>
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400948:	9b02      	ldr	r3, [sp, #8]
  40094a:	f003 0302 	and.w	r3, r3, #2
  40094e:	b2de      	uxtb	r6, r3
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400950:	4b4e      	ldr	r3, [pc, #312]	; (400a8c <sd_mmc_check+0x43c>)
  400952:	681b      	ldr	r3, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400954:	7d9a      	ldrb	r2, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400956:	7d19      	ldrb	r1, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400958:	7d5b      	ldrb	r3, [r3, #21]
  40095a:	ea4f 0383 	mov.w	r3, r3, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40095e:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400962:	ea43 13a2 	orr.w	r3, r3, r2, asr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  400966:	ea4f 5303 	mov.w	r3, r3, lsl #20
  40096a:	f513 1f80 	cmn.w	r3, #1048576	; 0x100000
  40096e:	d11a      	bne.n	4009a6 <sd_mmc_check+0x356>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  400970:	4f4c      	ldr	r7, [pc, #304]	; (400aa4 <sd_mmc_check+0x454>)
  400972:	a803      	add	r0, sp, #12
  400974:	47b8      	blx	r7
  400976:	2800      	cmp	r0, #0
  400978:	f000 83a4 	beq.w	4010c4 <sd_mmc_check+0xa74>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  40097c:	f105 0501 	add.w	r5, r5, #1
  400980:	b2ad      	uxth	r5, r5
  400982:	2d35      	cmp	r5, #53	; 0x35
  400984:	d9f5      	bls.n	400972 <sd_mmc_check+0x322>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  400986:	4b41      	ldr	r3, [pc, #260]	; (400a8c <sd_mmc_check+0x43c>)
  400988:	681a      	ldr	r2, [r3, #0]
  40098a:	9b03      	ldr	r3, [sp, #12]
  40098c:	ea4f 0353 	mov.w	r3, r3, lsr #1
  400990:	6053      	str	r3, [r2, #4]
  400992:	e008      	b.n	4009a6 <sd_mmc_check+0x356>
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  400994:	a803      	add	r0, sp, #12
  400996:	47b8      	blx	r7
  400998:	2800      	cmp	r0, #0
  40099a:	f000 8393 	beq.w	4010c4 <sd_mmc_check+0xa74>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  40099e:	f105 0501 	add.w	r5, r5, #1
  4009a2:	b2ad      	uxth	r5, r5
  4009a4:	e000      	b.n	4009a8 <sd_mmc_check+0x358>
		if (!driver_read_word(&sec_count)) {
  4009a6:	4f3f      	ldr	r7, [pc, #252]	; (400aa4 <sd_mmc_check+0x454>)
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  4009a8:	2d7f      	cmp	r5, #127	; 0x7f
  4009aa:	d9f3      	bls.n	400994 <sd_mmc_check+0x344>
  4009ac:	e38d      	b.n	4010ca <sd_mmc_check+0xa7a>
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  4009ae:	4b3e      	ldr	r3, [pc, #248]	; (400aa8 <sd_mmc_check+0x458>)
  4009b0:	7818      	ldrb	r0, [r3, #0]
  4009b2:	4b3e      	ldr	r3, [pc, #248]	; (400aac <sd_mmc_check+0x45c>)
  4009b4:	4798      	blx	r3
  4009b6:	4605      	mov	r5, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  4009b8:	2804      	cmp	r0, #4
  4009ba:	d00b      	beq.n	4009d4 <sd_mmc_check+0x384>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4009bc:	f44f 7100 	mov.w	r1, #512	; 0x200
  4009c0:	f2c0 11b7 	movt	r1, #439	; 0x1b7
  4009c4:	f04f 0300 	mov.w	r3, #0
  4009c8:	f2c0 13b7 	movt	r3, #439	; 0x1b7
  4009cc:	2808      	cmp	r0, #8
  4009ce:	bf18      	it	ne
  4009d0:	4619      	movne	r1, r3
  4009d2:	e003      	b.n	4009dc <sd_mmc_check+0x38c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4009d4:	f44f 7180 	mov.w	r1, #256	; 0x100
  4009d8:	f2c0 11b7 	movt	r1, #439	; 0x1b7
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  4009dc:	f243 1006 	movw	r0, #12550	; 0x3106
  4009e0:	4b2b      	ldr	r3, [pc, #172]	; (400a90 <sd_mmc_check+0x440>)
  4009e2:	4798      	blx	r3
  4009e4:	2800      	cmp	r0, #0
  4009e6:	f000 8378 	beq.w	4010da <sd_mmc_check+0xa8a>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  4009ea:	4b31      	ldr	r3, [pc, #196]	; (400ab0 <sd_mmc_check+0x460>)
  4009ec:	4798      	blx	r3
  4009ee:	f010 0f80 	tst.w	r0, #128	; 0x80
  4009f2:	f040 8372 	bne.w	4010da <sd_mmc_check+0xa8a>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  4009f6:	4b25      	ldr	r3, [pc, #148]	; (400a8c <sd_mmc_check+0x43c>)
  4009f8:	681b      	ldr	r3, [r3, #0]
  4009fa:	735d      	strb	r5, [r3, #13]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  4009fc:	4b2d      	ldr	r3, [pc, #180]	; (400ab4 <sd_mmc_check+0x464>)
  4009fe:	4798      	blx	r3
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  400a00:	4b2d      	ldr	r3, [pc, #180]	; (400ab8 <sd_mmc_check+0x468>)
  400a02:	4798      	blx	r3
  400a04:	b330      	cbz	r0, 400a54 <sd_mmc_check+0x404>
  400a06:	b32e      	cbz	r6, 400a54 <sd_mmc_check+0x404>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  400a08:	f243 1006 	movw	r0, #12550	; 0x3106
  400a0c:	f44f 7180 	mov.w	r1, #256	; 0x100
  400a10:	f2c0 31b9 	movt	r1, #953	; 0x3b9
  400a14:	4b1e      	ldr	r3, [pc, #120]	; (400a90 <sd_mmc_check+0x440>)
  400a16:	4798      	blx	r3
  400a18:	2800      	cmp	r0, #0
  400a1a:	f000 8361 	beq.w	4010e0 <sd_mmc_check+0xa90>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400a1e:	4b24      	ldr	r3, [pc, #144]	; (400ab0 <sd_mmc_check+0x460>)
  400a20:	4798      	blx	r3
  400a22:	f010 0f80 	tst.w	r0, #128	; 0x80
  400a26:	f040 835b 	bne.w	4010e0 <sd_mmc_check+0xa90>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400a2a:	4b18      	ldr	r3, [pc, #96]	; (400a8c <sd_mmc_check+0x43c>)
  400a2c:	681b      	ldr	r3, [r3, #0]
  400a2e:	f04f 0201 	mov.w	r2, #1
  400a32:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock = 52000000lu;
  400a34:	f44f 42ea 	mov.w	r2, #29952	; 0x7500
  400a38:	f2c0 3219 	movt	r2, #793	; 0x319
  400a3c:	601a      	str	r2, [r3, #0]
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  400a3e:	4b1d      	ldr	r3, [pc, #116]	; (400ab4 <sd_mmc_check+0x464>)
  400a40:	4798      	blx	r3
  400a42:	e007      	b.n	400a54 <sd_mmc_check+0x404>
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  400a44:	4b1b      	ldr	r3, [pc, #108]	; (400ab4 <sd_mmc_check+0x464>)
  400a46:	4798      	blx	r3
  400a48:	e004      	b.n	400a54 <sd_mmc_check+0x404>
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400a4a:	4640      	mov	r0, r8
  400a4c:	4639      	mov	r1, r7
  400a4e:	47b0      	blx	r6
  400a50:	b140      	cbz	r0, 400a64 <sd_mmc_check+0x414>
  400a52:	e018      	b.n	400a86 <sd_mmc_check+0x436>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400a54:	f04f 050a 	mov.w	r5, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400a58:	f241 1810 	movw	r8, #4368	; 0x1110
  400a5c:	f44f 7700 	mov.w	r7, #512	; 0x200
  400a60:	4e0b      	ldr	r6, [pc, #44]	; (400a90 <sd_mmc_check+0x440>)
  400a62:	e7f2      	b.n	400a4a <sd_mmc_check+0x3fa>
  400a64:	f105 35ff 	add.w	r5, r5, #4294967295
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  400a68:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
  400a6c:	d1ed      	bne.n	400a4a <sd_mmc_check+0x3fa>
		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
			return true;
		}
	}
	return false;
  400a6e:	f04f 0000 	mov.w	r0, #0
  400a72:	e2aa      	b.n	400fca <sd_mmc_check+0x97a>
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  400a74:	f04f 0000 	mov.w	r0, #0
  400a78:	e2a7      	b.n	400fca <sd_mmc_check+0x97a>
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
		return false;
  400a7a:	f04f 0000 	mov.w	r0, #0
  400a7e:	e2a4      	b.n	400fca <sd_mmc_check+0x97a>
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  400a80:	f04f 0000 	mov.w	r0, #0
  400a84:	e2a1      	b.n	400fca <sd_mmc_check+0x97a>
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
			return true;
  400a86:	f04f 0001 	mov.w	r0, #1
  400a8a:	e29e      	b.n	400fca <sd_mmc_check+0x97a>
  400a8c:	2000045c 	.word	0x2000045c
  400a90:	00401845 	.word	0x00401845
  400a94:	004005dd 	.word	0x004005dd
  400a98:	004045d8 	.word	0x004045d8
  400a9c:	004045f4 	.word	0x004045f4
  400aa0:	004018a9 	.word	0x004018a9
  400aa4:	0040197d 	.word	0x0040197d
  400aa8:	20000462 	.word	0x20000462
  400aac:	00401795 	.word	0x00401795
  400ab0:	00401875 	.word	0x00401875
  400ab4:	0040047d 	.word	0x0040047d
  400ab8:	004017a1 	.word	0x004017a1
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  400abc:	f645 3002 	movw	r0, #23298	; 0x5b02
  400ac0:	f04f 0100 	mov.w	r1, #0
  400ac4:	f641 0345 	movw	r3, #6213	; 0x1845
  400ac8:	f2c0 0340 	movt	r3, #64	; 0x40
  400acc:	4798      	blx	r3
  400ace:	2800      	cmp	r0, #0
  400ad0:	f000 828a 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  400ad4:	f245 1003 	movw	r0, #20739	; 0x5103
  400ad8:	f04f 0100 	mov.w	r1, #0
  400adc:	f641 0345 	movw	r3, #6213	; 0x1845
  400ae0:	f2c0 0340 	movt	r3, #64	; 0x40
  400ae4:	4798      	blx	r3
  400ae6:	2800      	cmp	r0, #0
  400ae8:	f000 827e 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  400aec:	f240 455c 	movw	r5, #1116	; 0x45c
  400af0:	f2c2 0500 	movt	r5, #8192	; 0x2000
  400af4:	682e      	ldr	r6, [r5, #0]
  400af6:	f641 0375 	movw	r3, #6261	; 0x1875
  400afa:	f2c0 0340 	movt	r3, #64	; 0x40
  400afe:	4798      	blx	r3
  400b00:	ea4f 4010 	mov.w	r0, r0, lsr #16
  400b04:	8130      	strh	r0, [r6, #8]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400b06:	682b      	ldr	r3, [r5, #0]
  400b08:	7adb      	ldrb	r3, [r3, #11]
  400b0a:	f013 0f01 	tst.w	r3, #1
  400b0e:	d056      	beq.n	400bbe <sd_mmc_check+0x56e>
		if (!sd_mmc_cmd9_mci()) {
  400b10:	f240 53dd 	movw	r3, #1501	; 0x5dd
  400b14:	f2c0 0340 	movt	r3, #64	; 0x40
  400b18:	4798      	blx	r3
  400b1a:	2800      	cmp	r0, #0
  400b1c:	f000 8264 	beq.w	400fe8 <sd_mmc_check+0x998>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  400b20:	682b      	ldr	r3, [r5, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b22:	7c59      	ldrb	r1, [r3, #17]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400b24:	f244 52d8 	movw	r2, #17880	; 0x45d8
  400b28:	f2c0 0240 	movt	r2, #64	; 0x40
  400b2c:	f001 0007 	and.w	r0, r1, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400b30:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
  400b34:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  400b38:	fb00 f002 	mul.w	r0, r0, r2
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  400b3c:	f244 5298 	movw	r2, #17816	; 0x4598
  400b40:	f2c0 0240 	movt	r2, #64	; 0x40
  400b44:	f3c1 01c3 	ubfx	r1, r1, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400b48:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  400b4c:	fb02 f200 	mul.w	r2, r2, r0
  400b50:	601a      	str	r2, [r3, #0]
  400b52:	7b9a      	ldrb	r2, [r3, #14]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400b54:	0992      	lsrs	r2, r2, #6
  400b56:	d00f      	beq.n	400b78 <sd_mmc_check+0x528>
  400b58:	7dda      	ldrb	r2, [r3, #23]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b5a:	7d98      	ldrb	r0, [r3, #22]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b5c:	7d59      	ldrb	r1, [r3, #21]
  400b5e:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400b62:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400b66:	430a      	orrs	r2, r1
  400b68:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  400b6c:	f102 0201 	add.w	r2, r2, #1
  400b70:	ea4f 2242 	mov.w	r2, r2, lsl #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  400b74:	605a      	str	r2, [r3, #4]
  400b76:	e022      	b.n	400bbe <sd_mmc_check+0x56e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b78:	7d99      	ldrb	r1, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b7a:	7d18      	ldrb	r0, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b7c:	7d5a      	ldrb	r2, [r3, #21]
  400b7e:	ea4f 0282 	mov.w	r2, r2, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b82:	ea42 2280 	orr.w	r2, r2, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b86:	ea42 12a1 	orr.w	r2, r2, r1, asr #6
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b8a:	7e18      	ldrb	r0, [r3, #24]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b8c:	7dd9      	ldrb	r1, [r3, #23]
  400b8e:	ea4f 0141 	mov.w	r1, r1, lsl #1
  400b92:	ea41 11e0 	orr.w	r1, r1, r0, asr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400b96:	ea4f 5202 	mov.w	r2, r2, lsl #20
  400b9a:	ea4f 5212 	mov.w	r2, r2, lsr #20
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400b9e:	f102 0201 	add.w	r2, r2, #1
  400ba2:	f001 0107 	and.w	r1, r1, #7
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400ba6:	f101 0102 	add.w	r1, r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400baa:	fa02 f101 	lsl.w	r1, r2, r1
  400bae:	7cda      	ldrb	r2, [r3, #19]
  400bb0:	f002 020f 	and.w	r2, r2, #15
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400bb4:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  400bb8:	ea4f 2292 	mov.w	r2, r2, lsr #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400bbc:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  400bbe:	f240 435c 	movw	r3, #1116	; 0x45c
  400bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bc6:	681b      	ldr	r3, [r3, #0]
  400bc8:	8919      	ldrh	r1, [r3, #8]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400bca:	f243 1007 	movw	r0, #12551	; 0x3107
  400bce:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400bd2:	f641 0345 	movw	r3, #6213	; 0x1845
  400bd6:	f2c0 0340 	movt	r3, #64	; 0x40
  400bda:	4798      	blx	r3
  400bdc:	2800      	cmp	r0, #0
  400bde:	f000 8203 	beq.w	400fe8 <sd_mmc_check+0x998>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400be2:	f240 435c 	movw	r3, #1116	; 0x45c
  400be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bea:	681b      	ldr	r3, [r3, #0]
  400bec:	7ada      	ldrb	r2, [r3, #11]
  400bee:	f012 0f01 	tst.w	r2, #1
  400bf2:	d04e      	beq.n	400c92 <sd_mmc_check+0x642>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400bf4:	8919      	ldrh	r1, [r3, #8]
  400bf6:	f241 1037 	movw	r0, #4407	; 0x1137
  400bfa:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400bfe:	f641 0345 	movw	r3, #6213	; 0x1845
  400c02:	f2c0 0340 	movt	r3, #64	; 0x40
  400c06:	4798      	blx	r3
  400c08:	2800      	cmp	r0, #0
  400c0a:	f000 81ed 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  400c0e:	f04f 0301 	mov.w	r3, #1
  400c12:	9300      	str	r3, [sp, #0]
  400c14:	f241 1033 	movw	r0, #4403	; 0x1133
  400c18:	f2c0 0008 	movt	r0, #8
  400c1c:	f04f 0100 	mov.w	r1, #0
  400c20:	f04f 0208 	mov.w	r2, #8
  400c24:	4d4c      	ldr	r5, [pc, #304]	; (400d58 <sd_mmc_check+0x708>)
  400c26:	47a8      	blx	r5
  400c28:	2800      	cmp	r0, #0
  400c2a:	f000 81dd 	beq.w	400fe8 <sd_mmc_check+0x998>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  400c2e:	a804      	add	r0, sp, #16
  400c30:	f04f 0101 	mov.w	r1, #1
  400c34:	4b49      	ldr	r3, [pc, #292]	; (400d5c <sd_mmc_check+0x70c>)
  400c36:	4798      	blx	r3
  400c38:	2800      	cmp	r0, #0
  400c3a:	f000 81d5 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400c3e:	4b48      	ldr	r3, [pc, #288]	; (400d60 <sd_mmc_check+0x710>)
  400c40:	4798      	blx	r3
  400c42:	2800      	cmp	r0, #0
  400c44:	f000 81d0 	beq.w	400fe8 <sd_mmc_check+0x998>
  400c48:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  400c4c:	f003 030f 	and.w	r3, r3, #15
  400c50:	2b01      	cmp	r3, #1
  400c52:	d009      	beq.n	400c68 <sd_mmc_check+0x618>
  400c54:	b113      	cbz	r3, 400c5c <sd_mmc_check+0x60c>
  400c56:	2b02      	cmp	r3, #2
  400c58:	d116      	bne.n	400c88 <sd_mmc_check+0x638>
  400c5a:	e00b      	b.n	400c74 <sd_mmc_check+0x624>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c5c:	4b41      	ldr	r3, [pc, #260]	; (400d64 <sd_mmc_check+0x714>)
  400c5e:	681b      	ldr	r3, [r3, #0]
  400c60:	f04f 0210 	mov.w	r2, #16
  400c64:	731a      	strb	r2, [r3, #12]
  400c66:	e014      	b.n	400c92 <sd_mmc_check+0x642>
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  400c68:	4b3e      	ldr	r3, [pc, #248]	; (400d64 <sd_mmc_check+0x714>)
  400c6a:	681b      	ldr	r3, [r3, #0]
  400c6c:	f04f 021a 	mov.w	r2, #26
  400c70:	731a      	strb	r2, [r3, #12]
  400c72:	e00e      	b.n	400c92 <sd_mmc_check+0x642>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400c74:	f89d 3012 	ldrb.w	r3, [sp, #18]
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  400c78:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  400c7a:	4b3a      	ldr	r3, [pc, #232]	; (400d64 <sd_mmc_check+0x714>)
  400c7c:	681b      	ldr	r3, [r3, #0]
  400c7e:	bf14      	ite	ne
  400c80:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  400c82:	2220      	moveq	r2, #32
  400c84:	731a      	strb	r2, [r3, #12]
  400c86:	e004      	b.n	400c92 <sd_mmc_check+0x642>
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c88:	4b36      	ldr	r3, [pc, #216]	; (400d64 <sd_mmc_check+0x714>)
  400c8a:	681b      	ldr	r3, [r3, #0]
  400c8c:	f04f 0210 	mov.w	r2, #16
  400c90:	731a      	strb	r2, [r3, #12]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!sd_acmd51()) {
			return false;
		}
	}
	if (IS_SDIO()) {
  400c92:	f240 435c 	movw	r3, #1116	; 0x45c
  400c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c9a:	681b      	ldr	r3, [r3, #0]
  400c9c:	7adb      	ldrb	r3, [r3, #11]
  400c9e:	f003 0304 	and.w	r3, r3, #4
  400ca2:	b2db      	uxtb	r3, r3
  400ca4:	2b00      	cmp	r3, #0
  400ca6:	f000 8095 	beq.w	400dd4 <sd_mmc_check+0x784>
 	uint32_t unit;
	uint32_t mul;
	uint8_t tplfe_max_tran_speed;

	// Read CIS area address in CCCR area
	addr_cis = 0; // Init all bytes, because the next function fill 3 bytes only
  400caa:	f04f 0100 	mov.w	r1, #0
  400cae:	9103      	str	r1, [sp, #12]
	if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, SDIO_CCCR_CIS_PTR,
  400cb0:	f04f 0303 	mov.w	r3, #3
  400cb4:	9300      	str	r3, [sp, #0]
  400cb6:	f04f 0301 	mov.w	r3, #1
  400cba:	9301      	str	r3, [sp, #4]
  400cbc:	4608      	mov	r0, r1
  400cbe:	f04f 0209 	mov.w	r2, #9
  400cc2:	f240 5529 	movw	r5, #1321	; 0x529
  400cc6:	f2c0 0540 	movt	r5, #64	; 0x40
  400cca:	47a8      	blx	r5
  400ccc:	2800      	cmp	r0, #0
  400cce:	f000 818b 	beq.w	400fe8 <sd_mmc_check+0x998>
			1, 3, true)) {
		sd_mmc_debug("%s: CMD53 Read CIS Fail\n\r", __func__);
		return false;
	}
	if (!driver_start_read_blocks((uint8_t *)&addr_cis, 1)) {
  400cd2:	a803      	add	r0, sp, #12
  400cd4:	f04f 0101 	mov.w	r1, #1
  400cd8:	4b20      	ldr	r3, [pc, #128]	; (400d5c <sd_mmc_check+0x70c>)
  400cda:	4798      	blx	r3
  400cdc:	2800      	cmp	r0, #0
  400cde:	f000 8183 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400ce2:	4b1f      	ldr	r3, [pc, #124]	; (400d60 <sd_mmc_check+0x710>)
  400ce4:	4798      	blx	r3
  400ce6:	2800      	cmp	r0, #0
  400ce8:	f000 817e 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	addr_cis = le32_to_cpu(addr_cis);
  400cec:	9d03      	ldr	r5, [sp, #12]

	// Search Fun0 tuple in the CIA area
	addr = addr_cis;
	while (1) {
		// Read a sample of CIA area
		if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 3, true)) {
  400cee:	f8df 8078 	ldr.w	r8, [pc, #120]	; 400d68 <sd_mmc_check+0x718>
			sd_mmc_debug("%s: CMD53 Read CIA Fail\n\r", __func__);
			return false;
		}
		if (!driver_start_read_blocks(buf, 1)) {
  400cf2:	4f1a      	ldr	r7, [pc, #104]	; (400d5c <sd_mmc_check+0x70c>)
			return false;
		}
		if (!driver_wait_end_of_read_blocks()) {
  400cf4:	4e1a      	ldr	r6, [pc, #104]	; (400d60 <sd_mmc_check+0x710>)

	// Search Fun0 tuple in the CIA area
	addr = addr_cis;
	while (1) {
		// Read a sample of CIA area
		if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 3, true)) {
  400cf6:	f04f 0303 	mov.w	r3, #3
  400cfa:	9300      	str	r3, [sp, #0]
  400cfc:	f04f 0301 	mov.w	r3, #1
  400d00:	9301      	str	r3, [sp, #4]
  400d02:	f04f 0000 	mov.w	r0, #0
  400d06:	4601      	mov	r1, r0
  400d08:	462a      	mov	r2, r5
  400d0a:	47c0      	blx	r8
  400d0c:	2800      	cmp	r0, #0
  400d0e:	f000 816b 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Read CIA Fail\n\r", __func__);
			return false;
		}
		if (!driver_start_read_blocks(buf, 1)) {
  400d12:	a804      	add	r0, sp, #16
  400d14:	f04f 0101 	mov.w	r1, #1
  400d18:	47b8      	blx	r7
  400d1a:	2800      	cmp	r0, #0
  400d1c:	f000 8164 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
		if (!driver_wait_end_of_read_blocks()) {
  400d20:	47b0      	blx	r6
  400d22:	2800      	cmp	r0, #0
  400d24:	f000 8160 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
		if (buf[0] == SDIO_CISTPL_END) {
  400d28:	f89d 3010 	ldrb.w	r3, [sp, #16]
  400d2c:	2bff      	cmp	r3, #255	; 0xff
  400d2e:	f000 815b 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Tuple error\n\r", __func__);
			return false; // Tuple error
		}
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
  400d32:	2b22      	cmp	r3, #34	; 0x22
  400d34:	d102      	bne.n	400d3c <sd_mmc_check+0x6ec>
  400d36:	f89d 3012 	ldrb.w	r3, [sp, #18]
  400d3a:	b1bb      	cbz	r3, 400d6c <sd_mmc_check+0x71c>
			break; // Fun0 tuple found
		}
		if (buf[1] == 0) {
  400d3c:	f89d 3011 	ldrb.w	r3, [sp, #17]
  400d40:	2b00      	cmp	r3, #0
  400d42:	f000 8151 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Tuple error\n\r", __func__);
			return false; // Tuple error
		}

		// Next address
		addr += (buf[1] + 2);
  400d46:	f103 0302 	add.w	r3, r3, #2
  400d4a:	18ed      	adds	r5, r5, r3
		if (addr > (addr_cis + 256)) {
  400d4c:	9b03      	ldr	r3, [sp, #12]
  400d4e:	f503 7380 	add.w	r3, r3, #256	; 0x100
  400d52:	429d      	cmp	r5, r3
  400d54:	d9cf      	bls.n	400cf6 <sd_mmc_check+0x6a6>
  400d56:	e147      	b.n	400fe8 <sd_mmc_check+0x998>
  400d58:	004018a9 	.word	0x004018a9
  400d5c:	00401a11 	.word	0x00401a11
  400d60:	00401a5d 	.word	0x00401a5d
  400d64:	2000045c 	.word	0x2000045c
  400d68:	00400529 	.word	0x00400529
			return false; // Outoff CIS area
		}
	}

	// Read all Fun0 tuple fields: fn0_blk_siz & max_tran_speed
	if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 6, true)) {
  400d6c:	f04f 0306 	mov.w	r3, #6
  400d70:	9300      	str	r3, [sp, #0]
  400d72:	f04f 0301 	mov.w	r3, #1
  400d76:	9301      	str	r3, [sp, #4]
  400d78:	f04f 0000 	mov.w	r0, #0
  400d7c:	4601      	mov	r1, r0
  400d7e:	462a      	mov	r2, r5
  400d80:	4db9      	ldr	r5, [pc, #740]	; (401068 <sd_mmc_check+0xa18>)
  400d82:	47a8      	blx	r5
  400d84:	2800      	cmp	r0, #0
  400d86:	f000 812f 	beq.w	400fe8 <sd_mmc_check+0x998>
		sd_mmc_debug("%s: CMD53 Read all Fun0 Fail\n\r", __func__);
		return false;
	}
	if (!driver_start_read_blocks(buf, 1)) {
  400d8a:	a804      	add	r0, sp, #16
  400d8c:	f04f 0101 	mov.w	r1, #1
  400d90:	4bb6      	ldr	r3, [pc, #728]	; (40106c <sd_mmc_check+0xa1c>)
  400d92:	4798      	blx	r3
  400d94:	2800      	cmp	r0, #0
  400d96:	f000 8127 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400d9a:	4bb5      	ldr	r3, [pc, #724]	; (401070 <sd_mmc_check+0xa20>)
  400d9c:	4798      	blx	r3
  400d9e:	2800      	cmp	r0, #0
  400da0:	f000 8122 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	tplfe_max_tran_speed = buf[5];
  400da4:	f89d 3015 	ldrb.w	r3, [sp, #21]
  400da8:	2b32      	cmp	r3, #50	; 0x32
  400daa:	bf28      	it	cs
  400dac:	2332      	movcs	r3, #50	; 0x32
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400dae:	4ab1      	ldr	r2, [pc, #708]	; (401074 <sd_mmc_check+0xa24>)
  400db0:	6812      	ldr	r2, [r2, #0]
		 */
		tplfe_max_tran_speed = 0x32; // 25Mhz
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
  400db2:	f003 0007 	and.w	r0, r3, #7
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400db6:	49b0      	ldr	r1, [pc, #704]	; (401078 <sd_mmc_check+0xa28>)
  400db8:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  400dbc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  400dc0:	fb00 f101 	mul.w	r1, r0, r1
		tplfe_max_tran_speed = 0x32; // 25Mhz
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
  400dc4:	f3c3 03c3 	ubfx	r3, r3, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400dc8:	48ac      	ldr	r0, [pc, #688]	; (40107c <sd_mmc_check+0xa2c>)
  400dca:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  400dce:	fb03 f301 	mul.w	r3, r3, r1
  400dd2:	6013      	str	r3, [r2, #0]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  400dd4:	f240 4362 	movw	r3, #1122	; 0x462
  400dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ddc:	7818      	ldrb	r0, [r3, #0]
  400dde:	f241 7395 	movw	r3, #6037	; 0x1795
  400de2:	f2c0 0340 	movt	r3, #64	; 0x40
  400de6:	4798      	blx	r3
  400de8:	2803      	cmp	r0, #3
  400dea:	d959      	bls.n	400ea0 <sd_mmc_check+0x850>
		// TRY to enable 4-bit mode
		if (IS_SDIO()) {
  400dec:	f240 435c 	movw	r3, #1116	; 0x45c
  400df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400df4:	681b      	ldr	r3, [r3, #0]
  400df6:	7adb      	ldrb	r3, [r3, #11]
  400df8:	f003 0304 	and.w	r3, r3, #4
  400dfc:	b2db      	uxtb	r3, r3
  400dfe:	b333      	cbz	r3, 400e4e <sd_mmc_check+0x7fe>
	 * A SDIO Low-Speed alone can supports 4bit (Optional)
	 */
	uint8_t u8_value;

	// Check 4bit support in 4BLS of "Card Capability" register
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP,
  400e00:	ab03      	add	r3, sp, #12
  400e02:	9300      	str	r3, [sp, #0]
  400e04:	f04f 0000 	mov.w	r0, #0
  400e08:	4601      	mov	r1, r0
  400e0a:	f04f 0208 	mov.w	r2, #8
  400e0e:	4603      	mov	r3, r0
  400e10:	4d9b      	ldr	r5, [pc, #620]	; (401080 <sd_mmc_check+0xa30>)
  400e12:	47a8      	blx	r5
  400e14:	2800      	cmp	r0, #0
  400e16:	f000 80e7 	beq.w	400fe8 <sd_mmc_check+0x998>
			0, &u8_value)) {
		return false;
	}
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
  400e1a:	f99d 300c 	ldrsb.w	r3, [sp, #12]
  400e1e:	2b00      	cmp	r3, #0
  400e20:	da15      	bge.n	400e4e <sd_mmc_check+0x7fe>
		// No supported, it is not a protocol error
		return true;
	}
	// HS mode possible, then enable
	u8_value = SDIO_BUSWIDTH_4B;
  400e22:	ab14      	add	r3, sp, #80	; 0x50
  400e24:	f04f 0202 	mov.w	r2, #2
  400e28:	f803 2d44 	strb.w	r2, [r3, #-68]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL,
  400e2c:	9300      	str	r3, [sp, #0]
  400e2e:	f04f 0001 	mov.w	r0, #1
  400e32:	f04f 0100 	mov.w	r1, #0
  400e36:	f04f 0207 	mov.w	r2, #7
  400e3a:	4603      	mov	r3, r0
  400e3c:	47a8      	blx	r5
  400e3e:	2800      	cmp	r0, #0
  400e40:	f000 80d2 	beq.w	400fe8 <sd_mmc_check+0x998>
			1, &u8_value)) {
		return false;
	}
	sd_mmc_card->bus_width = 4;
  400e44:	4b8b      	ldr	r3, [pc, #556]	; (401074 <sd_mmc_check+0xa24>)
  400e46:	681b      	ldr	r3, [r3, #0]
  400e48:	f04f 0204 	mov.w	r2, #4
  400e4c:	735a      	strb	r2, [r3, #13]
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400e4e:	f240 435c 	movw	r3, #1116	; 0x45c
  400e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e56:	681b      	ldr	r3, [r3, #0]
  400e58:	7ada      	ldrb	r2, [r3, #11]
  400e5a:	f012 0f01 	tst.w	r2, #1
  400e5e:	d01a      	beq.n	400e96 <sd_mmc_check+0x846>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400e60:	8919      	ldrh	r1, [r3, #8]
  400e62:	f241 1037 	movw	r0, #4407	; 0x1137
  400e66:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400e6a:	f641 0345 	movw	r3, #6213	; 0x1845
  400e6e:	f2c0 0340 	movt	r3, #64	; 0x40
  400e72:	4798      	blx	r3
  400e74:	2800      	cmp	r0, #0
  400e76:	f000 80b7 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  400e7a:	f241 1006 	movw	r0, #4358	; 0x1106
  400e7e:	f04f 0102 	mov.w	r1, #2
  400e82:	4b80      	ldr	r3, [pc, #512]	; (401084 <sd_mmc_check+0xa34>)
  400e84:	4798      	blx	r3
  400e86:	2800      	cmp	r0, #0
  400e88:	f000 80ae 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  400e8c:	4b79      	ldr	r3, [pc, #484]	; (401074 <sd_mmc_check+0xa24>)
  400e8e:	681b      	ldr	r3, [r3, #0]
  400e90:	f04f 0204 	mov.w	r2, #4
  400e94:	735a      	strb	r2, [r3, #13]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  400e96:	f240 437d 	movw	r3, #1149	; 0x47d
  400e9a:	f2c0 0340 	movt	r3, #64	; 0x40
  400e9e:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  400ea0:	f241 73a1 	movw	r3, #6049	; 0x17a1
  400ea4:	f2c0 0340 	movt	r3, #64	; 0x40
  400ea8:	4798      	blx	r3
  400eaa:	2800      	cmp	r0, #0
  400eac:	d07e      	beq.n	400fac <sd_mmc_check+0x95c>
		// TRY to enable High-Speed Mode
		if (IS_SDIO()) {
  400eae:	f240 435c 	movw	r3, #1116	; 0x45c
  400eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400eb6:	681b      	ldr	r3, [r3, #0]
  400eb8:	7adb      	ldrb	r3, [r3, #11]
  400eba:	f003 0304 	and.w	r3, r3, #4
  400ebe:	b2db      	uxtb	r3, r3
  400ec0:	b353      	cbz	r3, 400f18 <sd_mmc_check+0x8c8>
static bool sdio_cmd52_set_high_speed(void)
{
	uint8_t u8_value;

	// Check CIA.HS
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
  400ec2:	ab03      	add	r3, sp, #12
  400ec4:	9300      	str	r3, [sp, #0]
  400ec6:	f04f 0000 	mov.w	r0, #0
  400eca:	4601      	mov	r1, r0
  400ecc:	f04f 0213 	mov.w	r2, #19
  400ed0:	4603      	mov	r3, r0
  400ed2:	4d6b      	ldr	r5, [pc, #428]	; (401080 <sd_mmc_check+0xa30>)
  400ed4:	47a8      	blx	r5
  400ed6:	2800      	cmp	r0, #0
  400ed8:	f000 8086 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
  400edc:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400ee0:	f013 0f01 	tst.w	r3, #1
  400ee4:	d018      	beq.n	400f18 <sd_mmc_check+0x8c8>
		// No supported, it is not a protocol error
		return true;
	}
	// HS mode possible, then enable
	u8_value = SDIO_EHS;
  400ee6:	ab14      	add	r3, sp, #80	; 0x50
  400ee8:	f04f 0202 	mov.w	r2, #2
  400eec:	f803 2d44 	strb.w	r2, [r3, #-68]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS,
  400ef0:	9300      	str	r3, [sp, #0]
  400ef2:	f04f 0001 	mov.w	r0, #1
  400ef6:	f04f 0100 	mov.w	r1, #0
  400efa:	f04f 0213 	mov.w	r2, #19
  400efe:	4603      	mov	r3, r0
  400f00:	47a8      	blx	r5
  400f02:	2800      	cmp	r0, #0
  400f04:	d070      	beq.n	400fe8 <sd_mmc_check+0x998>
			1, &u8_value)) {
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400f06:	4b5b      	ldr	r3, [pc, #364]	; (401074 <sd_mmc_check+0xa24>)
  400f08:	681b      	ldr	r3, [r3, #0]
  400f0a:	f04f 0201 	mov.w	r2, #1
  400f0e:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f10:	681a      	ldr	r2, [r3, #0]
  400f12:	ea4f 0242 	mov.w	r2, r2, lsl #1
  400f16:	601a      	str	r2, [r3, #0]
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400f18:	f240 435c 	movw	r3, #1116	; 0x45c
  400f1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400f20:	681b      	ldr	r3, [r3, #0]
  400f22:	7ada      	ldrb	r2, [r3, #11]
  400f24:	f012 0f01 	tst.w	r2, #1
  400f28:	d03b      	beq.n	400fa2 <sd_mmc_check+0x952>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  400f2a:	7b1b      	ldrb	r3, [r3, #12]
  400f2c:	2b10      	cmp	r3, #16
  400f2e:	d938      	bls.n	400fa2 <sd_mmc_check+0x952>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400f30:	f04f 0301 	mov.w	r3, #1
  400f34:	9300      	str	r3, [sp, #0]
  400f36:	f241 1006 	movw	r0, #4358	; 0x1106
  400f3a:	f2c0 0008 	movt	r0, #8
  400f3e:	f64f 7101 	movw	r1, #65281	; 0xff01
  400f42:	f2c8 01ff 	movt	r1, #33023	; 0x80ff
  400f46:	f04f 0240 	mov.w	r2, #64	; 0x40
  400f4a:	4d4f      	ldr	r5, [pc, #316]	; (401088 <sd_mmc_check+0xa38>)
  400f4c:	47a8      	blx	r5
  400f4e:	2800      	cmp	r0, #0
  400f50:	d04a      	beq.n	400fe8 <sd_mmc_check+0x998>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  400f52:	a804      	add	r0, sp, #16
  400f54:	f04f 0101 	mov.w	r1, #1
  400f58:	4b44      	ldr	r3, [pc, #272]	; (40106c <sd_mmc_check+0xa1c>)
  400f5a:	4798      	blx	r3
  400f5c:	2800      	cmp	r0, #0
  400f5e:	d043      	beq.n	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400f60:	4b43      	ldr	r3, [pc, #268]	; (401070 <sd_mmc_check+0xa20>)
  400f62:	4798      	blx	r3
  400f64:	2800      	cmp	r0, #0
  400f66:	d03f      	beq.n	400fe8 <sd_mmc_check+0x998>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400f68:	4b48      	ldr	r3, [pc, #288]	; (40108c <sd_mmc_check+0xa3c>)
  400f6a:	4798      	blx	r3
  400f6c:	f010 0f80 	tst.w	r0, #128	; 0x80
  400f70:	d13a      	bne.n	400fe8 <sd_mmc_check+0x998>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400f72:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  400f76:	f003 030f 	and.w	r3, r3, #15
  400f7a:	2b0f      	cmp	r3, #15
  400f7c:	d011      	beq.n	400fa2 <sd_mmc_check+0x952>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400f7e:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f82:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  400f86:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  400f8a:	d12d      	bne.n	400fe8 <sd_mmc_check+0x998>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  400f8c:	4b40      	ldr	r3, [pc, #256]	; (401090 <sd_mmc_check+0xa40>)
  400f8e:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
  400f90:	4b38      	ldr	r3, [pc, #224]	; (401074 <sd_mmc_check+0xa24>)
  400f92:	681b      	ldr	r3, [r3, #0]
  400f94:	f04f 0201 	mov.w	r2, #1
  400f98:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f9a:	681a      	ldr	r2, [r3, #0]
  400f9c:	ea4f 0242 	mov.w	r2, r2, lsl #1
  400fa0:	601a      	str	r2, [r3, #0]
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  400fa2:	f240 437d 	movw	r3, #1149	; 0x47d
  400fa6:	f2c0 0340 	movt	r3, #64	; 0x40
  400faa:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400fac:	f240 435c 	movw	r3, #1116	; 0x45c
  400fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400fb4:	681b      	ldr	r3, [r3, #0]
  400fb6:	7adb      	ldrb	r3, [r3, #11]
  400fb8:	f013 0f01 	tst.w	r3, #1
  400fbc:	d006      	beq.n	400fcc <sd_mmc_check+0x97c>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400fbe:	f241 1010 	movw	r0, #4368	; 0x1110
  400fc2:	f44f 7100 	mov.w	r1, #512	; 0x200
  400fc6:	4b2f      	ldr	r3, [pc, #188]	; (401084 <sd_mmc_check+0xa34>)
  400fc8:	4798      	blx	r3
		sd_mmc_deselect_slot();
		return sd_mmc_err;
	}

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
  400fca:	b168      	cbz	r0, 400fe8 <sd_mmc_check+0x998>
			: sd_mmc_mci_card_init()) {
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  400fcc:	f240 435c 	movw	r3, #1116	; 0x45c
  400fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400fd4:	681b      	ldr	r3, [r3, #0]
  400fd6:	f04f 0200 	mov.w	r2, #0
  400fda:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
  400fdc:	f240 537d 	movw	r3, #1405	; 0x57d
  400fe0:	f2c0 0340 	movt	r3, #64	; 0x40
  400fe4:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
  400fe6:	e07e      	b.n	4010e6 <sd_mmc_check+0xa96>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  400fe8:	f240 435c 	movw	r3, #1116	; 0x45c
  400fec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ff0:	681b      	ldr	r3, [r3, #0]
  400ff2:	f04f 0403 	mov.w	r4, #3
  400ff6:	729c      	strb	r4, [r3, #10]
	sd_mmc_deselect_slot();
  400ff8:	f240 537d 	movw	r3, #1405	; 0x57d
  400ffc:	f2c0 0340 	movt	r3, #64	; 0x40
  401000:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
  401002:	e070      	b.n	4010e6 <sd_mmc_check+0xa96>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  401004:	f04f 0700 	mov.w	r7, #0
  401008:	e001      	b.n	40100e <sd_mmc_check+0x9be>
  40100a:	f04f 0700 	mov.w	r7, #0
static bool sdio_op_cond(void)
{
	uint32_t resp;

	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
  40100e:	f244 5005 	movw	r0, #17669	; 0x4505
  401012:	f04f 0100 	mov.w	r1, #0
  401016:	f641 0345 	movw	r3, #6213	; 0x1845
  40101a:	f2c0 0340 	movt	r3, #64	; 0x40
  40101e:	4798      	blx	r3
  401020:	2800      	cmp	r0, #0
  401022:	f47f ab64 	bne.w	4006ee <sd_mmc_check+0x9e>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401026:	f240 435c 	movw	r3, #1116	; 0x45c
  40102a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40102e:	681b      	ldr	r3, [r3, #0]
  401030:	7adb      	ldrb	r3, [r3, #11]
  401032:	f013 0f01 	tst.w	r3, #1
  401036:	f43f ad4d 	beq.w	400ad4 <sd_mmc_check+0x484>
  40103a:	f7ff bb89 	b.w	400750 <sd_mmc_check+0x100>
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  40103e:	f240 435c 	movw	r3, #1116	; 0x45c
  401042:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401046:	681b      	ldr	r3, [r3, #0]
  401048:	f04f 0202 	mov.w	r2, #2
  40104c:	72da      	strb	r2, [r3, #11]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40104e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401052:	f04f 0100 	mov.w	r1, #0
  401056:	f641 0345 	movw	r3, #6213	; 0x1845
  40105a:	f2c0 0340 	movt	r3, #64	; 0x40
  40105e:	4798      	blx	r3
  401060:	2800      	cmp	r0, #0
  401062:	f47f abae 	bne.w	4007c2 <sd_mmc_check+0x172>
  401066:	e7b0      	b.n	400fca <sd_mmc_check+0x97a>
  401068:	00400529 	.word	0x00400529
  40106c:	00401a11 	.word	0x00401a11
  401070:	00401a5d 	.word	0x00401a5d
  401074:	2000045c 	.word	0x2000045c
  401078:	004045d8 	.word	0x004045d8
  40107c:	00404598 	.word	0x00404598
  401080:	0040059d 	.word	0x0040059d
  401084:	00401845 	.word	0x00401845
  401088:	004018a9 	.word	0x004018a9
  40108c:	00401875 	.word	0x00401875
  401090:	00401821 	.word	0x00401821
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401094:	f240 435c 	movw	r3, #1116	; 0x45c
  401098:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40109c:	681b      	ldr	r3, [r3, #0]
  40109e:	7adb      	ldrb	r3, [r3, #11]
  4010a0:	f013 0f01 	tst.w	r3, #1
  4010a4:	f47f ad0a 	bne.w	400abc <sd_mmc_check+0x46c>
  4010a8:	e514      	b.n	400ad4 <sd_mmc_check+0x484>
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4010aa:	f645 3002 	movw	r0, #23298	; 0x5b02
  4010ae:	f04f 0100 	mov.w	r1, #0
  4010b2:	4b0f      	ldr	r3, [pc, #60]	; (4010f0 <sd_mmc_check+0xaa0>)
  4010b4:	4798      	blx	r3
  4010b6:	2800      	cmp	r0, #0
  4010b8:	f47f abae 	bne.w	400818 <sd_mmc_check+0x1c8>
  4010bc:	e785      	b.n	400fca <sd_mmc_check+0x97a>
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
		return false;
	}

	if (!mmc_mci_op_cond()) {
		return false;
  4010be:	f04f 0000 	mov.w	r0, #0
  4010c2:	e782      	b.n	400fca <sd_mmc_check+0x97a>
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
  4010c4:	f04f 0000 	mov.w	r0, #0
  4010c8:	e77f      	b.n	400fca <sd_mmc_check+0x97a>
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  4010ca:	4b0a      	ldr	r3, [pc, #40]	; (4010f4 <sd_mmc_check+0xaa4>)
  4010cc:	7818      	ldrb	r0, [r3, #0]
  4010ce:	4b0a      	ldr	r3, [pc, #40]	; (4010f8 <sd_mmc_check+0xaa8>)
  4010d0:	4798      	blx	r3
  4010d2:	2803      	cmp	r0, #3
  4010d4:	f63f ac6b 	bhi.w	4009ae <sd_mmc_check+0x35e>
  4010d8:	e492      	b.n	400a00 <sd_mmc_check+0x3b0>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
  4010da:	f04f 0000 	mov.w	r0, #0
  4010de:	e774      	b.n	400fca <sd_mmc_check+0x97a>
			sd_mmc_configure_slot();
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
  4010e0:	f04f 0000 	mov.w	r0, #0
  4010e4:	e771      	b.n	400fca <sd_mmc_check+0x97a>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  4010e6:	4620      	mov	r0, r4
  4010e8:	b015      	add	sp, #84	; 0x54
  4010ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4010ee:	bf00      	nop
  4010f0:	00401845 	.word	0x00401845
  4010f4:	20000462 	.word	0x20000462
  4010f8:	00401795 	.word	0x00401795

004010fc <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
  4010fc:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4010fe:	f240 43ad 	movw	r3, #1197	; 0x4ad
  401102:	f2c0 0340 	movt	r3, #64	; 0x40
  401106:	4798      	blx	r3
  401108:	b958      	cbnz	r0, 401122 <sd_mmc_get_type+0x26>
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
  40110a:	f240 537d 	movw	r3, #1405	; 0x57d
  40110e:	f2c0 0340 	movt	r3, #64	; 0x40
  401112:	4798      	blx	r3
	return sd_mmc_card->type;
  401114:	f240 435c 	movw	r3, #1116	; 0x45c
  401118:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40111c:	681b      	ldr	r3, [r3, #0]
  40111e:	7ad8      	ldrb	r0, [r3, #11]
  401120:	bd08      	pop	{r3, pc}
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  401122:	f04f 0000 	mov.w	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
}
  401126:	bd08      	pop	{r3, pc}

00401128 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  401128:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  40112a:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40112e:	f2c0 0340 	movt	r3, #64	; 0x40
  401132:	4798      	blx	r3
  401134:	b958      	cbnz	r0, 40114e <sd_mmc_get_capacity+0x26>
		return 0;
	}
	sd_mmc_deselect_slot();
  401136:	f240 537d 	movw	r3, #1405	; 0x57d
  40113a:	f2c0 0340 	movt	r3, #64	; 0x40
  40113e:	4798      	blx	r3
	return sd_mmc_card->capacity;
  401140:	f240 435c 	movw	r3, #1116	; 0x45c
  401144:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401148:	681b      	ldr	r3, [r3, #0]
  40114a:	6858      	ldr	r0, [r3, #4]
  40114c:	bd08      	pop	{r3, pc}
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  40114e:	f04f 0000 	mov.w	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
}
  401152:	bd08      	pop	{r3, pc}

00401154 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  401154:	f04f 0000 	mov.w	r0, #0
  401158:	4770      	bx	lr
  40115a:	bf00      	nop

0040115c <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  40115c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401160:	b083      	sub	sp, #12
  401162:	468b      	mov	fp, r1
  401164:	4692      	mov	sl, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401166:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40116a:	f2c0 0340 	movt	r3, #64	; 0x40
  40116e:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
  401170:	4681      	mov	r9, r0
  401172:	2800      	cmp	r0, #0
  401174:	d178      	bne.n	401268 <sd_mmc_init_read_blocks+0x10c>
  401176:	f640 5441 	movw	r4, #3393	; 0xd41
  40117a:	f2c0 0403 	movt	r4, #3
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40117e:	f240 475c 	movw	r7, #1116	; 0x45c
  401182:	f2c2 0700 	movt	r7, #8192	; 0x2000
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  401186:	f241 160d 	movw	r6, #4365	; 0x110d
  40118a:	f641 0545 	movw	r5, #6213	; 0x1845
  40118e:	f2c0 0540 	movt	r5, #64	; 0x40
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401192:	f641 0875 	movw	r8, #6261	; 0x1875
  401196:	f2c0 0840 	movt	r8, #64	; 0x40
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40119a:	683b      	ldr	r3, [r7, #0]
  40119c:	8919      	ldrh	r1, [r3, #8]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  40119e:	4630      	mov	r0, r6
  4011a0:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4011a4:	47a8      	blx	r5
  4011a6:	2800      	cmp	r0, #0
  4011a8:	d03d      	beq.n	401226 <sd_mmc_init_read_blocks+0xca>
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  4011aa:	47c0      	blx	r8
  4011ac:	f410 7f80 	tst.w	r0, #256	; 0x100
  4011b0:	d141      	bne.n	401236 <sd_mmc_init_read_blocks+0xda>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  4011b2:	3c01      	subs	r4, #1
  4011b4:	d1f1      	bne.n	40119a <sd_mmc_init_read_blocks+0x3e>
  4011b6:	e036      	b.n	401226 <sd_mmc_init_read_blocks+0xca>
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4011b8:	ea4f 214b 	mov.w	r1, fp, lsl #9
  4011bc:	e7ff      	b.n	4011be <sd_mmc_init_read_blocks+0x62>
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4011be:	f04f 0201 	mov.w	r2, #1
  4011c2:	9200      	str	r2, [sp, #0]
  4011c4:	f44f 7200 	mov.w	r2, #512	; 0x200
  4011c8:	4653      	mov	r3, sl
  4011ca:	f641 04a9 	movw	r4, #6313	; 0x18a9
  4011ce:	f2c0 0440 	movt	r4, #64	; 0x40
  4011d2:	47a0      	blx	r4
  4011d4:	b938      	cbnz	r0, 4011e6 <sd_mmc_init_read_blocks+0x8a>
		sd_mmc_deselect_slot();
  4011d6:	f240 537d 	movw	r3, #1405	; 0x57d
  4011da:	f2c0 0340 	movt	r3, #64	; 0x40
  4011de:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  4011e0:	f04f 0905 	mov.w	r9, #5
  4011e4:	e040      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4011e6:	f641 0375 	movw	r3, #6261	; 0x1875
  4011ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4011ee:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4011f0:	f04f 0300 	mov.w	r3, #0
  4011f4:	f2ce 4358 	movt	r3, #58456	; 0xe458
  4011f8:	4003      	ands	r3, r0
  4011fa:	b13b      	cbz	r3, 40120c <sd_mmc_init_read_blocks+0xb0>
			sd_mmc_debug("%s: Read blocks %02d resp32 0x%08x CARD_STATUS_ERR_RD_WR\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
  4011fc:	f240 537d 	movw	r3, #1405	; 0x57d
  401200:	f2c0 0340 	movt	r3, #64	; 0x40
  401204:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  401206:	f04f 0905 	mov.w	r9, #5
  40120a:	e02d      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40120c:	f240 4360 	movw	r3, #1120	; 0x460
  401210:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401214:	f8a3 a000 	strh.w	sl, [r3]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401218:	f240 4358 	movw	r3, #1112	; 0x458
  40121c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401220:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  401224:	e020      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
		return sd_mmc_err;
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
  401226:	f240 537d 	movw	r3, #1405	; 0x57d
  40122a:	f2c0 0340 	movt	r3, #64	; 0x40
  40122e:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  401230:	f04f 0905 	mov.w	r9, #5
  401234:	e018      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
  401236:	f241 1011 	movw	r0, #4369	; 0x1111
  40123a:	f2c0 0008 	movt	r0, #8
  40123e:	f241 1312 	movw	r3, #4370	; 0x1112
  401242:	f2c0 0310 	movt	r3, #16
  401246:	f1ba 0f01 	cmp.w	sl, #1
  40124a:	bf88      	it	hi
  40124c:	4618      	movhi	r0, r3
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40124e:	f240 435c 	movw	r3, #1116	; 0x45c
  401252:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401256:	681b      	ldr	r3, [r3, #0]
  401258:	7adb      	ldrb	r3, [r3, #11]
  40125a:	f003 0308 	and.w	r3, r3, #8
  40125e:	b2db      	uxtb	r3, r3
		arg = start;
  401260:	4659      	mov	r1, fp
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401262:	2b00      	cmp	r3, #0
  401264:	d1ab      	bne.n	4011be <sd_mmc_init_read_blocks+0x62>
  401266:	e7a7      	b.n	4011b8 <sd_mmc_init_read_blocks+0x5c>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401268:	4648      	mov	r0, r9
  40126a:	b003      	add	sp, #12
  40126c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00401270 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401270:	b510      	push	{r4, lr}
  401272:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  401274:	f641 2311 	movw	r3, #6673	; 0x1a11
  401278:	f2c0 0340 	movt	r3, #64	; 0x40
  40127c:	4798      	blx	r3
  40127e:	b948      	cbnz	r0, 401294 <sd_mmc_start_read_blocks+0x24>
		sd_mmc_nb_block_remaining = 0;
  401280:	f240 4360 	movw	r3, #1120	; 0x460
  401284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401288:	f04f 0200 	mov.w	r2, #0
  40128c:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  40128e:	f04f 0005 	mov.w	r0, #5
  401292:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401294:	f240 4360 	movw	r3, #1120	; 0x460
  401298:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40129c:	881a      	ldrh	r2, [r3, #0]
  40129e:	1b14      	subs	r4, r2, r4
  4012a0:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  4012a2:	f04f 0000 	mov.w	r0, #0
}
  4012a6:	bd10      	pop	{r4, pc}

004012a8 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(void)
{
  4012a8:	b508      	push	{r3, lr}
	if (!driver_wait_end_of_read_blocks()) {
  4012aa:	f641 235d 	movw	r3, #6749	; 0x1a5d
  4012ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4012b2:	4798      	blx	r3
  4012b4:	2800      	cmp	r0, #0
  4012b6:	d030      	beq.n	40131a <sd_mmc_wait_end_of_read_blocks+0x72>
		return SD_MMC_ERR_COMM;
	}
	if (sd_mmc_nb_block_remaining) {
  4012b8:	f240 4360 	movw	r3, #1120	; 0x460
  4012bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012c0:	881b      	ldrh	r3, [r3, #0]
  4012c2:	2b00      	cmp	r3, #0
  4012c4:	d12c      	bne.n	401320 <sd_mmc_wait_end_of_read_blocks+0x78>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4012c6:	f240 4358 	movw	r3, #1112	; 0x458
  4012ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012ce:	881b      	ldrh	r3, [r3, #0]
  4012d0:	2b01      	cmp	r3, #1
  4012d2:	d107      	bne.n	4012e4 <sd_mmc_wait_end_of_read_blocks+0x3c>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
  4012d4:	f240 537d 	movw	r3, #1405	; 0x57d
  4012d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4012dc:	4798      	blx	r3
		return SD_MMC_OK;
  4012de:	f04f 0000 	mov.w	r0, #0
  4012e2:	bd08      	pop	{r3, pc}
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4012e4:	f243 100c 	movw	r0, #12556	; 0x310c
  4012e8:	f04f 0100 	mov.w	r1, #0
  4012ec:	f641 0345 	movw	r3, #6213	; 0x1845
  4012f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4012f4:	4798      	blx	r3
  4012f6:	b940      	cbnz	r0, 40130a <sd_mmc_wait_end_of_read_blocks+0x62>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  4012f8:	f243 100c 	movw	r0, #12556	; 0x310c
  4012fc:	f04f 0100 	mov.w	r1, #0
  401300:	f641 0345 	movw	r3, #6213	; 0x1845
  401304:	f2c0 0340 	movt	r3, #64	; 0x40
  401308:	4798      	blx	r3
	}
	sd_mmc_deselect_slot();
  40130a:	f240 537d 	movw	r3, #1405	; 0x57d
  40130e:	f2c0 0340 	movt	r3, #64	; 0x40
  401312:	4798      	blx	r3
	return SD_MMC_OK;
  401314:	f04f 0000 	mov.w	r0, #0
  401318:	bd08      	pop	{r3, pc}
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(void)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
  40131a:	f04f 0005 	mov.w	r0, #5
  40131e:	bd08      	pop	{r3, pc}
	}
	if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
  401320:	f04f 0000 	mov.w	r0, #0
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  401324:	bd08      	pop	{r3, pc}
  401326:	bf00      	nop

00401328 <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401328:	b5f0      	push	{r4, r5, r6, r7, lr}
  40132a:	b083      	sub	sp, #12
  40132c:	4605      	mov	r5, r0
  40132e:	460f      	mov	r7, r1
  401330:	4616      	mov	r6, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401332:	f240 44ad 	movw	r4, #1197	; 0x4ad
  401336:	f2c0 0440 	movt	r4, #64	; 0x40
  40133a:	47a0      	blx	r4
	if (sd_mmc_err != SD_MMC_OK) {
  40133c:	4604      	mov	r4, r0
  40133e:	2800      	cmp	r0, #0
  401340:	d157      	bne.n	4013f2 <sd_mmc_init_write_blocks+0xca>
		return sd_mmc_err;
	}
	if (sd_mmc_is_write_protected(slot)) {
  401342:	4628      	mov	r0, r5
  401344:	f241 1555 	movw	r5, #4437	; 0x1155
  401348:	f2c0 0540 	movt	r5, #64	; 0x40
  40134c:	47a8      	blx	r5
  40134e:	b138      	cbz	r0, 401360 <sd_mmc_init_write_blocks+0x38>
		sd_mmc_deselect_slot();
  401350:	f240 537d 	movw	r3, #1405	; 0x57d
  401354:	f2c0 0340 	movt	r3, #64	; 0x40
  401358:	4798      	blx	r3
		return SD_MMC_ERR_WP;
  40135a:	f04f 0407 	mov.w	r4, #7
  40135e:	e048      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  401360:	f249 1018 	movw	r0, #37144	; 0x9118
  401364:	f2c0 0008 	movt	r0, #8
  401368:	f249 1319 	movw	r3, #37145	; 0x9119
  40136c:	f2c0 0310 	movt	r3, #16
  401370:	2e01      	cmp	r6, #1
  401372:	bf88      	it	hi
  401374:	4618      	movhi	r0, r3
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401376:	f240 435c 	movw	r3, #1116	; 0x45c
  40137a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40137e:	681b      	ldr	r3, [r3, #0]
  401380:	7adb      	ldrb	r3, [r3, #11]
  401382:	f003 0308 	and.w	r3, r3, #8
  401386:	b2db      	uxtb	r3, r3
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401388:	ea4f 2147 	mov.w	r1, r7, lsl #9
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40138c:	b103      	cbz	r3, 401390 <sd_mmc_init_write_blocks+0x68>
		arg = start;
  40138e:	4639      	mov	r1, r7
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401390:	f04f 0301 	mov.w	r3, #1
  401394:	9300      	str	r3, [sp, #0]
  401396:	f44f 7200 	mov.w	r2, #512	; 0x200
  40139a:	4633      	mov	r3, r6
  40139c:	f641 05a9 	movw	r5, #6313	; 0x18a9
  4013a0:	f2c0 0540 	movt	r5, #64	; 0x40
  4013a4:	47a8      	blx	r5
  4013a6:	b938      	cbnz	r0, 4013b8 <sd_mmc_init_write_blocks+0x90>
		sd_mmc_deselect_slot();
  4013a8:	f240 537d 	movw	r3, #1405	; 0x57d
  4013ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4013b0:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  4013b2:	f04f 0405 	mov.w	r4, #5
  4013b6:	e01c      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4013b8:	f641 0375 	movw	r3, #6261	; 0x1875
  4013bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4013c0:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4013c2:	f04f 0300 	mov.w	r3, #0
  4013c6:	f2ce 4358 	movt	r3, #58456	; 0xe458
  4013ca:	4003      	ands	r3, r0
  4013cc:	b13b      	cbz	r3, 4013de <sd_mmc_init_write_blocks+0xb6>
			sd_mmc_debug("%s: Write blocks %02d r1 0x%08x CARD_STATUS_ERR_RD_WR\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
  4013ce:	f240 537d 	movw	r3, #1405	; 0x57d
  4013d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4013d6:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  4013d8:	f04f 0405 	mov.w	r4, #5
  4013dc:	e009      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4013de:	f240 4360 	movw	r3, #1120	; 0x460
  4013e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4013e6:	801e      	strh	r6, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  4013e8:	f240 4358 	movw	r3, #1112	; 0x458
  4013ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4013f0:	801e      	strh	r6, [r3, #0]
	return SD_MMC_OK;
}
  4013f2:	4620      	mov	r0, r4
  4013f4:	b003      	add	sp, #12
  4013f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

004013f8 <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4013f8:	b510      	push	{r4, lr}
  4013fa:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4013fc:	f641 23ed 	movw	r3, #6893	; 0x1aed
  401400:	f2c0 0340 	movt	r3, #64	; 0x40
  401404:	4798      	blx	r3
  401406:	b948      	cbnz	r0, 40141c <sd_mmc_start_write_blocks+0x24>
		sd_mmc_nb_block_remaining = 0;
  401408:	f240 4360 	movw	r3, #1120	; 0x460
  40140c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401410:	f04f 0200 	mov.w	r2, #0
  401414:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  401416:	f04f 0005 	mov.w	r0, #5
  40141a:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  40141c:	f240 4360 	movw	r3, #1120	; 0x460
  401420:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401424:	881a      	ldrh	r2, [r3, #0]
  401426:	1b14      	subs	r4, r2, r4
  401428:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  40142a:	f04f 0000 	mov.w	r0, #0
}
  40142e:	bd10      	pop	{r4, pc}

00401430 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(void)
{
  401430:	b508      	push	{r3, lr}
	if (!driver_wait_end_of_write_blocks()) {
  401432:	f641 333d 	movw	r3, #6973	; 0x1b3d
  401436:	f2c0 0340 	movt	r3, #64	; 0x40
  40143a:	4798      	blx	r3
  40143c:	2800      	cmp	r0, #0
  40143e:	d02f      	beq.n	4014a0 <sd_mmc_wait_end_of_write_blocks+0x70>
		return SD_MMC_ERR_COMM;
	}
	if (sd_mmc_nb_block_remaining) {
  401440:	f240 4360 	movw	r3, #1120	; 0x460
  401444:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401448:	881b      	ldrh	r3, [r3, #0]
  40144a:	2b00      	cmp	r3, #0
  40144c:	d12b      	bne.n	4014a6 <sd_mmc_wait_end_of_write_blocks+0x76>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40144e:	f240 4358 	movw	r3, #1112	; 0x458
  401452:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401456:	881b      	ldrh	r3, [r3, #0]
  401458:	2b01      	cmp	r3, #1
  40145a:	d107      	bne.n	40146c <sd_mmc_wait_end_of_write_blocks+0x3c>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
  40145c:	f240 537d 	movw	r3, #1405	; 0x57d
  401460:	f2c0 0340 	movt	r3, #64	; 0x40
  401464:	4798      	blx	r3
		return SD_MMC_OK;
  401466:	f04f 0000 	mov.w	r0, #0
  40146a:	bd08      	pop	{r3, pc}
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  40146c:	f243 100c 	movw	r0, #12556	; 0x310c
  401470:	f04f 0100 	mov.w	r1, #0
  401474:	f641 0345 	movw	r3, #6213	; 0x1845
  401478:	f2c0 0340 	movt	r3, #64	; 0x40
  40147c:	4798      	blx	r3
  40147e:	b938      	cbnz	r0, 401490 <sd_mmc_wait_end_of_write_blocks+0x60>
			sd_mmc_deselect_slot();
  401480:	f240 537d 	movw	r3, #1405	; 0x57d
  401484:	f2c0 0340 	movt	r3, #64	; 0x40
  401488:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  40148a:	f04f 0005 	mov.w	r0, #5
  40148e:	bd08      	pop	{r3, pc}
		}
	}
	sd_mmc_deselect_slot();
  401490:	f240 537d 	movw	r3, #1405	; 0x57d
  401494:	f2c0 0340 	movt	r3, #64	; 0x40
  401498:	4798      	blx	r3
	return SD_MMC_OK;
  40149a:	f04f 0000 	mov.w	r0, #0
  40149e:	bd08      	pop	{r3, pc}
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(void)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
  4014a0:	f04f 0005 	mov.w	r0, #5
  4014a4:	bd08      	pop	{r3, pc}
	}
	if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
  4014a6:	f04f 0000 	mov.w	r0, #0
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  4014aa:	bd08      	pop	{r3, pc}

004014ac <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  4014ac:	b510      	push	{r4, lr}
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4014ae:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4014b2:	f2c0 7027 	movt	r0, #1831	; 0x727
  4014b6:	f242 33e9 	movw	r3, #9193	; 0x23e9
  4014ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4014be:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  4014c0:	f04f 0000 	mov.w	r0, #0
  4014c4:	f04f 013e 	mov.w	r1, #62	; 0x3e
  4014c8:	f242 0311 	movw	r3, #8209	; 0x2011
  4014cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4014d0:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4014d2:	f242 0481 	movw	r4, #8321	; 0x2081
  4014d6:	f2c0 0440 	movt	r4, #64	; 0x40
  4014da:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4014dc:	2800      	cmp	r0, #0
  4014de:	d0fc      	beq.n	4014da <sysclk_init+0x2e>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4014e0:	f242 0391 	movw	r3, #8337	; 0x2091
  4014e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4014e8:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4014ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014ee:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014f2:	f643 7201 	movw	r2, #16129	; 0x3f01
  4014f6:	f2c2 0209 	movt	r2, #8201	; 0x2009
  4014fa:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
		return pmc_is_locked_pllack();
  4014fc:	f242 04a1 	movw	r4, #8353	; 0x20a1
  401500:	f2c0 0440 	movt	r4, #64	; 0x40
  401504:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  401506:	2800      	cmp	r0, #0
  401508:	d0fc      	beq.n	401504 <sysclk_init+0x58>
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  40150a:	f04f 0000 	mov.w	r0, #0
  40150e:	f641 7389 	movw	r3, #8073	; 0x1f89
  401512:	f2c0 0340 	movt	r3, #64	; 0x40
  401516:	4798      	blx	r3
		break;
#endif	
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  401518:	f242 2331 	movw	r3, #8753	; 0x2231
  40151c:	f2c0 0340 	movt	r3, #64	; 0x40
  401520:	4798      	blx	r3
  401522:	bd10      	pop	{r4, pc}

00401524 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  401524:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401526:	2801      	cmp	r0, #1
  401528:	d809      	bhi.n	40153e <mem_test_unit_ready+0x1a>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  40152a:	f244 6334 	movw	r3, #17972	; 0x4634
  40152e:	f2c0 0340 	movt	r3, #64	; 0x40
  401532:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401536:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  40153a:	4798      	blx	r3
  40153c:	bd08      	pop	{r3, pc}
  40153e:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401542:	bd08      	pop	{r3, pc}

00401544 <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  401544:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401546:	2801      	cmp	r0, #1
  401548:	d80b      	bhi.n	401562 <mem_read_capacity+0x1e>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  40154a:	f244 6334 	movw	r3, #17972	; 0x4634
  40154e:	f2c0 0340 	movt	r3, #64	; 0x40
  401552:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  401556:	eb03 0380 	add.w	r3, r3, r0, lsl #2
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  40155a:	685b      	ldr	r3, [r3, #4]
  40155c:	4608      	mov	r0, r1
  40155e:	4798      	blx	r3
  401560:	bd08      	pop	{r3, pc}
  401562:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401566:	bd08      	pop	{r3, pc}

00401568 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  401568:	2801      	cmp	r0, #1
  40156a:	bf8c      	ite	hi
  40156c:	2000      	movhi	r0, #0
  40156e:	2001      	movls	r0, #1
  401570:	4770      	bx	lr
  401572:	bf00      	nop

00401574 <mem_wr_protect>:


bool mem_wr_protect(U8 lun)
{
  401574:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401576:	2801      	cmp	r0, #1
  401578:	d80a      	bhi.n	401590 <mem_wr_protect+0x1c>
  40157a:	f244 6334 	movw	r3, #17972	; 0x4634
  40157e:	f2c0 0340 	movt	r3, #64	; 0x40
  401582:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  401586:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  40158a:	689b      	ldr	r3, [r3, #8]
  40158c:	4798      	blx	r3
  40158e:	bd08      	pop	{r3, pc}
  401590:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  401594:	bd08      	pop	{r3, pc}
  401596:	bf00      	nop

00401598 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  401598:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  40159a:	2801      	cmp	r0, #1
  40159c:	d80c      	bhi.n	4015b8 <memory_2_ram+0x20>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  40159e:	f244 6334 	movw	r3, #17972	; 0x4634
  4015a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4015a6:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  4015aa:	eb03 0380 	add.w	r3, r3, r0, lsl #2
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  4015ae:	691b      	ldr	r3, [r3, #16]
  4015b0:	4608      	mov	r0, r1
  4015b2:	4611      	mov	r1, r2
  4015b4:	4798      	blx	r3
  4015b6:	bd08      	pop	{r3, pc}
  4015b8:	f04f 0001 	mov.w	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  4015bc:	bd08      	pop	{r3, pc}
  4015be:	bf00      	nop

004015c0 <dacc_reset>:
 *
 * \param p_dacc Pointer to a DACC instance. 
 */
void dacc_reset(Dacc *p_dacc)
{
	p_dacc->DACC_CR = DACC_CR_SWRST;
  4015c0:	f04f 0301 	mov.w	r3, #1
  4015c4:	6003      	str	r3, [r0, #0]
  4015c6:	4770      	bx	lr

004015c8 <dacc_set_transfer_mode>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_transfer_mode(Dacc *p_dacc, uint32_t ul_mode)
{
	if (ul_mode) {
  4015c8:	b121      	cbz	r1, 4015d4 <dacc_set_transfer_mode+0xc>
#if (SAM3N) || (SAM4L)
		p_dacc->DACC_MR |= DACC_MR_WORD;
#else
		p_dacc->DACC_MR |= DACC_MR_WORD_WORD;
  4015ca:	6843      	ldr	r3, [r0, #4]
  4015cc:	f043 0310 	orr.w	r3, r3, #16
  4015d0:	6043      	str	r3, [r0, #4]
  4015d2:	e003      	b.n	4015dc <dacc_set_transfer_mode+0x14>
#endif
	} else {
#if (SAM3N) || (SAM4L)
		p_dacc->DACC_MR &= (~DACC_MR_WORD);
#else
		p_dacc->DACC_MR &= (~DACC_MR_WORD_WORD);
  4015d4:	6843      	ldr	r3, [r0, #4]
  4015d6:	f023 0310 	bic.w	r3, r3, #16
  4015da:	6043      	str	r3, [r0, #4]
#endif
	}
	return DACC_RC_OK;
}
  4015dc:	f04f 0000 	mov.w	r0, #0
  4015e0:	4770      	bx	lr
  4015e2:	bf00      	nop

004015e4 <dacc_get_interrupt_status>:
 *
 * \return The interrupt status.
 */
uint32_t dacc_get_interrupt_status(Dacc *p_dacc)
{
	return p_dacc->DACC_ISR;
  4015e4:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
  4015e6:	4770      	bx	lr

004015e8 <dacc_write_conversion_data>:
 * \param p_dacc Pointer to a DACC instance. 
 * \param ul_data The data to be transferred to analog value. 
 */
void dacc_write_conversion_data(Dacc *p_dacc, uint32_t ul_data)
{
	p_dacc->DACC_CDR = ul_data;
  4015e8:	6201      	str	r1, [r0, #32]
  4015ea:	4770      	bx	lr

004015ec <dacc_enable_flexible_selection>:
 *
 * \param p_dacc Pointer to a DACC instance. 
 */
void dacc_enable_flexible_selection(Dacc *p_dacc)
{
	p_dacc->DACC_MR |= DACC_MR_TAG;
  4015ec:	6843      	ldr	r3, [r0, #4]
  4015ee:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4015f2:	6043      	str	r3, [r0, #4]
  4015f4:	4770      	bx	lr
  4015f6:	bf00      	nop

004015f8 <dacc_set_power_save>:
 * \return \ref DACC_RC_OK if successful.
 */
uint32_t dacc_set_power_save(Dacc *p_dacc,
		uint32_t ul_sleep_mode, uint32_t ul_fast_wakeup_mode)
{
	if (ul_sleep_mode) {
  4015f8:	b121      	cbz	r1, 401604 <dacc_set_power_save+0xc>
		p_dacc->DACC_MR |= DACC_MR_SLEEP;
  4015fa:	6843      	ldr	r3, [r0, #4]
  4015fc:	f043 0320 	orr.w	r3, r3, #32
  401600:	6043      	str	r3, [r0, #4]
  401602:	e003      	b.n	40160c <dacc_set_power_save+0x14>
	} else {
		p_dacc->DACC_MR &= (~DACC_MR_SLEEP);
  401604:	6843      	ldr	r3, [r0, #4]
  401606:	f023 0320 	bic.w	r3, r3, #32
  40160a:	6043      	str	r3, [r0, #4]
	}
	if (ul_fast_wakeup_mode) {
  40160c:	b122      	cbz	r2, 401618 <dacc_set_power_save+0x20>
		p_dacc->DACC_MR |= DACC_MR_FASTWKUP;
  40160e:	6843      	ldr	r3, [r0, #4]
  401610:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401614:	6043      	str	r3, [r0, #4]
  401616:	e003      	b.n	401620 <dacc_set_power_save+0x28>
	} else {
		p_dacc->DACC_MR &= (~DACC_MR_FASTWKUP);
  401618:	6843      	ldr	r3, [r0, #4]
  40161a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  40161e:	6043      	str	r3, [r0, #4]
	}
	return DACC_RC_OK;
}
  401620:	f04f 0000 	mov.w	r0, #0
  401624:	4770      	bx	lr
  401626:	bf00      	nop

00401628 <dacc_set_timing>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_timing(Dacc *p_dacc,
		uint32_t ul_refresh, uint32_t ul_maxs, uint32_t ul_startup)
{
  401628:	b410      	push	{r4}
	uint32_t mr = p_dacc->DACC_MR
  40162a:	6844      	ldr	r4, [r0, #4]
  40162c:	f024 547c 	bic.w	r4, r4, #1056964608	; 0x3f000000
  401630:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
		& (~(DACC_MR_REFRESH_Msk | DACC_MR_STARTUP_Msk));
	mr |= DACC_MR_REFRESH(ul_refresh);
  401634:	ea4f 6101 	mov.w	r1, r1, lsl #24
  401638:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
	if (ul_maxs) {
  40163c:	b112      	cbz	r2, 401644 <dacc_set_timing+0x1c>
		mr |= DACC_MR_MAXS;
  40163e:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
  401642:	e001      	b.n	401648 <dacc_set_timing+0x20>
	} else {
		mr &= ~DACC_MR_MAXS;
  401644:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
	}
	mr |= (DACC_MR_STARTUP_Msk & ((ul_startup) << DACC_MR_STARTUP_Pos));
  401648:	ea4f 6303 	mov.w	r3, r3, lsl #24
  40164c:	f003 537c 	and.w	r3, r3, #1056964608	; 0x3f000000
  401650:	431c      	orrs	r4, r3
	p_dacc->DACC_MR = mr;
  401652:	6044      	str	r4, [r0, #4]
	return DACC_RC_OK;
}
  401654:	f04f 0000 	mov.w	r0, #0
  401658:	bc10      	pop	{r4}
  40165a:	4770      	bx	lr

0040165c <dacc_enable_channel>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_enable_channel(Dacc *p_dacc, uint32_t ul_channel)
{
	if (ul_channel > MAX_CH_NB)
  40165c:	2901      	cmp	r1, #1
		return DACC_RC_INVALID_PARAM;

	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
  40165e:	bf9f      	itttt	ls
  401660:	2301      	movls	r3, #1
  401662:	fa03 f101 	lslls.w	r1, r3, r1
  401666:	6101      	strls	r1, [r0, #16]
	return DACC_RC_OK;
  401668:	2000      	movls	r0, #0
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_enable_channel(Dacc *p_dacc, uint32_t ul_channel)
{
	if (ul_channel > MAX_CH_NB)
		return DACC_RC_INVALID_PARAM;
  40166a:	bf88      	it	hi
  40166c:	2001      	movhi	r0, #1

	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
	return DACC_RC_OK;
}
  40166e:	4770      	bx	lr

00401670 <dacc_set_analog_control>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_analog_control(Dacc *p_dacc, uint32_t ul_analog_control)
{
	p_dacc->DACC_ACR = ul_analog_control;
  401670:	f8c0 1094 	str.w	r1, [r0, #148]	; 0x94
	return DACC_RC_OK;
}
  401674:	f04f 0000 	mov.w	r0, #0
  401678:	4770      	bx	lr
  40167a:	bf00      	nop

0040167c <hsmci_reset>:

/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
  40167c:	b470      	push	{r4, r5, r6}
	uint32_t mr = HSMCI->HSMCI_MR;
  40167e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401682:	685d      	ldr	r5, [r3, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401684:	689c      	ldr	r4, [r3, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401686:	68d8      	ldr	r0, [r3, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401688:	69d9      	ldr	r1, [r3, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40168a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40168c:	f04f 0680 	mov.w	r6, #128	; 0x80
  401690:	601e      	str	r6, [r3, #0]
	HSMCI->HSMCI_MR = mr;
  401692:	605d      	str	r5, [r3, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401694:	609c      	str	r4, [r3, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401696:	60d8      	str	r0, [r3, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401698:	61d9      	str	r1, [r3, #28]
	HSMCI->HSMCI_CFG = cfg;
  40169a:	655a      	str	r2, [r3, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40169c:	f04f 0205 	mov.w	r2, #5
  4016a0:	601a      	str	r2, [r3, #0]
}
  4016a2:	bc70      	pop	{r4, r5, r6}
  4016a4:	4770      	bx	lr
  4016a6:	bf00      	nop

004016a8 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  4016a8:	b508      	push	{r3, lr}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  4016aa:	f001 033f 	and.w	r3, r1, #63	; 0x3f
  4016ae:	4318      	orrs	r0, r3
	if (cmd & SDMMC_RESP_PRESENT) {
  4016b0:	f411 7f80 	tst.w	r1, #256	; 0x100
  4016b4:	d00c      	beq.n	4016d0 <hsmci_send_cmd_execute+0x28>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  4016b6:	f411 6f00 	tst.w	r1, #2048	; 0x800
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  4016ba:	bf18      	it	ne
  4016bc:	f440 5084 	orrne.w	r0, r0, #4224	; 0x1080
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  4016c0:	d106      	bne.n	4016d0 <hsmci_send_cmd_execute+0x28>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  4016c2:	f411 5f00 	tst.w	r1, #8192	; 0x2000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  4016c6:	bf14      	ite	ne
  4016c8:	f440 5086 	orrne.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  4016cc:	f440 5082 	orreq.w	r0, r0, #4160	; 0x1040
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  4016d0:	f411 4f80 	tst.w	r1, #16384	; 0x4000
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  4016d4:	bf18      	it	ne
  4016d6:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  4016da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4016de:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  4016e0:	6158      	str	r0, [r3, #20]

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  4016e2:	4618      	mov	r0, r3
		if (cmd & SDMMC_RESP_CRC) {
  4016e4:	f401 5280 	and.w	r2, r1, #4096	; 0x1000
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  4016e8:	6c03      	ldr	r3, [r0, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  4016ea:	b152      	cbz	r2, 401702 <hsmci_send_cmd_execute+0x5a>
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  4016ec:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  4016f0:	d012      	beq.n	401718 <hsmci_send_cmd_execute+0x70>
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  4016f2:	f241 637d 	movw	r3, #5757	; 0x167d
  4016f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4016fa:	4798      	blx	r3
				return false;
  4016fc:	f04f 0000 	mov.w	r0, #0
  401700:	bd08      	pop	{r3, pc}
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401702:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401706:	d007      	beq.n	401718 <hsmci_send_cmd_execute+0x70>
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  401708:	f241 637d 	movw	r3, #5757	; 0x167d
  40170c:	f2c0 0340 	movt	r3, #64	; 0x40
  401710:	4798      	blx	r3
				return false;
  401712:	f04f 0000 	mov.w	r0, #0
  401716:	bd08      	pop	{r3, pc}
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401718:	f013 0f01 	tst.w	r3, #1
  40171c:	d0e4      	beq.n	4016e8 <hsmci_send_cmd_execute+0x40>

	if (cmd & SDMMC_RESP_BUSY) {
  40171e:	f411 5f00 	tst.w	r1, #8192	; 0x2000
  401722:	d114      	bne.n	40174e <hsmci_send_cmd_execute+0xa6>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401724:	f04f 0001 	mov.w	r0, #1
  401728:	bd08      	pop	{r3, pc}
{
	uint32_t busy_wait = 1000000;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  40172a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  40172c:	3b01      	subs	r3, #1
  40172e:	d107      	bne.n	401740 <hsmci_send_cmd_execute+0x98>
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
  401730:	f241 637d 	movw	r3, #5757	; 0x167d
  401734:	f2c0 0340 	movt	r3, #64	; 0x40
  401738:	4798      	blx	r3
			return false;
  40173a:	f04f 0000 	mov.w	r0, #0
  40173e:	bd08      	pop	{r3, pc}
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401740:	f002 0230 	and.w	r2, r2, #48	; 0x30
  401744:	2a20      	cmp	r2, #32
  401746:	d1f0      	bne.n	40172a <hsmci_send_cmd_execute+0x82>
	return true;
  401748:	f04f 0001 	mov.w	r0, #1
  40174c:	bd08      	pop	{r3, pc}
{
	uint32_t busy_wait = 1000000;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  40174e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401752:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  401754:	f244 2340 	movw	r3, #16960	; 0x4240
  401758:	f2c0 030f 	movt	r3, #15
  40175c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401760:	e7ee      	b.n	401740 <hsmci_send_cmd_execute+0x98>
  401762:	bf00      	nop

00401764 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401764:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  401766:	f04f 0012 	mov.w	r0, #18
  40176a:	f242 03b1 	movw	r3, #8369	; 0x20b1
  40176e:	f2c0 0340 	movt	r3, #64	; 0x40
  401772:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401774:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401778:	f04f 0272 	mov.w	r2, #114	; 0x72
  40177c:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  40177e:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401780:	f04f 0211 	mov.w	r2, #17
  401784:	655a      	str	r2, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401786:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  40178a:	605a      	str	r2, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  40178c:	f04f 0205 	mov.w	r2, #5
  401790:	601a      	str	r2, [r3, #0]
  401792:	bd08      	pop	{r3, pc}

00401794 <hsmci_get_bus_width>:
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401794:	2800      	cmp	r0, #0
  401796:	bf0c      	ite	eq
  401798:	2004      	moveq	r0, #4
  40179a:	2000      	movne	r0, #0
  40179c:	4770      	bx	lr
  40179e:	bf00      	nop

004017a0 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  4017a0:	f04f 0001 	mov.w	r0, #1
  4017a4:	4770      	bx	lr
  4017a6:	bf00      	nop

004017a8 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  4017a8:	b133      	cbz	r3, 4017b8 <hsmci_select_device+0x10>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  4017aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017ae:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4017b0:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  4017b4:	6558      	str	r0, [r3, #84]	; 0x54
  4017b6:	e005      	b.n	4017c4 <hsmci_select_device+0x1c>
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4017b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017bc:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4017be:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  4017c2:	6558      	str	r0, [r3, #84]	; 0x54
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
  4017c4:	f04f 0000 	mov.w	r0, #0
{
	uint32_t clkdiv;
	uint32_t rest;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if (speed > 0) {
  4017c8:	b181      	cbz	r1, 4017ec <hsmci_select_device+0x44>
		clkdiv = mck / (2 * speed);
  4017ca:	ea4f 0141 	mov.w	r1, r1, lsl #1
  4017ce:	f44f 6360 	mov.w	r3, #3584	; 0xe00
  4017d2:	f2c0 7327 	movt	r3, #1831	; 0x727
  4017d6:	fbb3 f0f1 	udiv	r0, r3, r1
		rest = mck % (2 * speed);
  4017da:	fb01 3110 	mls	r1, r1, r0, r3
		if (rest > 0) {
  4017de:	b109      	cbz	r1, 4017e4 <hsmci_select_device+0x3c>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  4017e0:	f100 0001 	add.w	r0, r0, #1
		}
		if (clkdiv > 0) {
  4017e4:	b110      	cbz	r0, 4017ec <hsmci_select_device+0x44>
			clkdiv -= 1;
  4017e6:	f100 30ff 	add.w	r0, r0, #4294967295
  4017ea:	e7ff      	b.n	4017ec <hsmci_select_device+0x44>
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  4017ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017f0:	6859      	ldr	r1, [r3, #4]
  4017f2:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  4017f6:	6059      	str	r1, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  4017f8:	6859      	ldr	r1, [r3, #4]
  4017fa:	b2c0      	uxtb	r0, r0
  4017fc:	4308      	orrs	r0, r1
  4017fe:	6058      	str	r0, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401800:	2a04      	cmp	r2, #4
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401802:	bf08      	it	eq
  401804:	2280      	moveq	r2, #128	; 0x80
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401806:	d004      	beq.n	401812 <hsmci_select_device+0x6a>
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401808:	2a08      	cmp	r2, #8
  40180a:	bf0c      	ite	eq
  40180c:	22c0      	moveq	r2, #192	; 0xc0
  40180e:	2200      	movne	r2, #0
  401810:	e7ff      	b.n	401812 <hsmci_select_device+0x6a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401812:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401816:	60da      	str	r2, [r3, #12]
  401818:	4770      	bx	lr
  40181a:	bf00      	nop

0040181c <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  40181c:	4770      	bx	lr
  40181e:	bf00      	nop

00401820 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401820:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401824:	685a      	ldr	r2, [r3, #4]
  401826:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  40182a:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  40182c:	f04f 0200 	mov.w	r2, #0
  401830:	611a      	str	r2, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401832:	f44f 6210 	mov.w	r2, #2304	; 0x900
  401836:	615a      	str	r2, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401838:	461a      	mov	r2, r3
  40183a:	6c13      	ldr	r3, [r2, #64]	; 0x40
  40183c:	f013 0f01 	tst.w	r3, #1
  401840:	d0fb      	beq.n	40183a <hsmci_send_clock+0x1a>
}
  401842:	4770      	bx	lr

00401844 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401844:	b510      	push	{r4, lr}
  401846:	4604      	mov	r4, r0
  401848:	460a      	mov	r2, r1
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  40184a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  40184e:	6859      	ldr	r1, [r3, #4]
  401850:	f421 5160 	bic.w	r1, r1, #14336	; 0x3800
  401854:	6059      	str	r1, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401856:	6859      	ldr	r1, [r3, #4]
  401858:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
  40185c:	6059      	str	r1, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
  40185e:	f04f 0000 	mov.w	r0, #0
  401862:	6198      	str	r0, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401864:	4621      	mov	r1, r4
  401866:	f241 63a9 	movw	r3, #5801	; 0x16a9
  40186a:	f2c0 0340 	movt	r3, #64	; 0x40
  40186e:	4798      	blx	r3
}
  401870:	bd10      	pop	{r4, pc}
  401872:	bf00      	nop

00401874 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401874:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401878:	6a18      	ldr	r0, [r3, #32]
}
  40187a:	4770      	bx	lr

0040187c <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  40187c:	b410      	push	{r4}
uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
}

void hsmci_get_response_128(uint8_t* response)
  40187e:	f100 0410 	add.w	r4, r0, #16
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  401882:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401886:	6a0b      	ldr	r3, [r1, #32]
		*response = (response_32 >> 24) & 0xFF;
  401888:	ea4f 6213 	mov.w	r2, r3, lsr #24
  40188c:	7002      	strb	r2, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  40188e:	ea4f 4213 	mov.w	r2, r3, lsr #16
  401892:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401894:	ea4f 2213 	mov.w	r2, r3, lsr #8
  401898:	7082      	strb	r2, [r0, #2]
		response++;
		*response = (response_32 >>  0) & 0xFF;
  40189a:	70c3      	strb	r3, [r0, #3]
uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
}

void hsmci_get_response_128(uint8_t* response)
  40189c:	f100 0004 	add.w	r0, r0, #4
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  4018a0:	4284      	cmp	r4, r0
  4018a2:	d1f0      	bne.n	401886 <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  4018a4:	bc10      	pop	{r4}
  4018a6:	4770      	bx	lr

004018a8 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  4018a8:	b570      	push	{r4, r5, r6, lr}
  4018aa:	4604      	mov	r4, r0
  4018ac:	460e      	mov	r6, r1
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  4018ae:	f89d 1010 	ldrb.w	r1, [sp, #16]
  4018b2:	b131      	cbz	r1, 4018c2 <hsmci_adtc_start+0x1a>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  4018b4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4018b8:	6848      	ldr	r0, [r1, #4]
  4018ba:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  4018be:	6048      	str	r0, [r1, #4]
  4018c0:	e005      	b.n	4018ce <hsmci_adtc_start+0x26>
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  4018c2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4018c6:	6848      	ldr	r0, [r1, #4]
  4018c8:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  4018cc:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  4018ce:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4018d2:	6841      	ldr	r1, [r0, #4]
  4018d4:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  4018d8:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
  4018da:	f012 0f03 	tst.w	r2, #3
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4018de:	bf1d      	ittte	ne
  4018e0:	4601      	movne	r1, r0
  4018e2:	6848      	ldrne	r0, [r1, #4]
  4018e4:	f440 5000 	orrne.w	r0, r0, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4018e8:	f04f 4180 	moveq.w	r1, #1073741824	; 0x40000000
  4018ec:	bf04      	itt	eq
  4018ee:	6848      	ldreq	r0, [r1, #4]
  4018f0:	f420 5000 	biceq.w	r0, r0, #8192	; 0x2000
  4018f4:	6048      	str	r0, [r1, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
  4018f6:	f404 4000 	and.w	r0, r4, #32768	; 0x8000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  4018fa:	2800      	cmp	r0, #0
  4018fc:	bf0c      	ite	eq
  4018fe:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  401902:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401906:	f414 3f80 	tst.w	r4, #65536	; 0x10000
  40190a:	d005      	beq.n	401918 <hsmci_adtc_start+0x70>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  40190c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BCNT_Pos);
  401910:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401914:	618a      	str	r2, [r1, #24]
  401916:	e018      	b.n	40194a <hsmci_adtc_start+0xa2>
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401918:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  40191c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401920:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  401922:	f414 3f00 	tst.w	r4, #131072	; 0x20000
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  401926:	bf18      	it	ne
  401928:	f440 1020 	orrne.w	r0, r0, #2621440	; 0x280000
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  40192c:	d10d      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  40192e:	f414 2f80 	tst.w	r4, #262144	; 0x40000
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  401932:	bf18      	it	ne
  401934:	f440 1080 	orrne.w	r0, r0, #1048576	; 0x100000
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401938:	d107      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  40193a:	f414 2f00 	tst.w	r4, #524288	; 0x80000
  40193e:	d104      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  401940:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401944:	bf18      	it	ne
  401946:	f440 2000 	orrne.w	r0, r0, #524288	; 0x80000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  40194a:	f240 4588 	movw	r5, #1160	; 0x488
  40194e:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401952:	f04f 0100 	mov.w	r1, #0
  401956:	6029      	str	r1, [r5, #0]
	hsmci_block_size = block_size;
  401958:	f240 4584 	movw	r5, #1156	; 0x484
  40195c:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401960:	802a      	strh	r2, [r5, #0]
	hsmci_nb_block = nb_block;
  401962:	f240 4586 	movw	r5, #1158	; 0x486
  401966:	f2c2 0500 	movt	r5, #8192	; 0x2000
  40196a:	802b      	strh	r3, [r5, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  40196c:	4621      	mov	r1, r4
  40196e:	4632      	mov	r2, r6
  401970:	f241 63a9 	movw	r3, #5801	; 0x16a9
  401974:	f2c0 0340 	movt	r3, #64	; 0x40
  401978:	4798      	blx	r3
}
  40197a:	bd70      	pop	{r4, r5, r6, pc}

0040197c <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  40197c:	b508      	push	{r3, lr}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40197e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401982:	f04f 0200 	mov.w	r2, #0
  401986:	f2cc 0260 	movt	r2, #49248	; 0xc060

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40198a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40198c:	4213      	tst	r3, r2
  40198e:	d007      	beq.n	4019a0 <hsmci_read_word+0x24>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  401990:	f241 637d 	movw	r3, #5757	; 0x167d
  401994:	f2c0 0340 	movt	r3, #64	; 0x40
  401998:	4798      	blx	r3
			return false;
  40199a:	f04f 0000 	mov.w	r0, #0
  40199e:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  4019a0:	f013 0f02 	tst.w	r3, #2
  4019a4:	d0f1      	beq.n	40198a <hsmci_read_word+0xe>

	// Read data
	*value = HSMCI->HSMCI_RDR;
  4019a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4019aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4019ac:	6003      	str	r3, [r0, #0]
	hsmci_transfert_pos += 4;
  4019ae:	f240 4388 	movw	r3, #1160	; 0x488
  4019b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019b6:	681a      	ldr	r2, [r3, #0]
  4019b8:	f102 0204 	add.w	r2, r2, #4
  4019bc:	601a      	str	r2, [r3, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  4019be:	f240 4386 	movw	r3, #1158	; 0x486
  4019c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019c6:	8819      	ldrh	r1, [r3, #0]
  4019c8:	f240 4384 	movw	r3, #1156	; 0x484
  4019cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019d0:	881b      	ldrh	r3, [r3, #0]
  4019d2:	fb03 f301 	mul.w	r3, r3, r1
  4019d6:	429a      	cmp	r2, r3
  4019d8:	d316      	bcc.n	401a08 <hsmci_read_word+0x8c>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  4019da:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4019de:	f04f 0200 	mov.w	r2, #0
  4019e2:	f2cc 0260 	movt	r2, #49248	; 0xc060
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  4019e6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4019e8:	4213      	tst	r3, r2
  4019ea:	d007      	beq.n	4019fc <hsmci_read_word+0x80>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  4019ec:	f241 637d 	movw	r3, #5757	; 0x167d
  4019f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4019f4:	4798      	blx	r3
			return false;
  4019f6:	f04f 0000 	mov.w	r0, #0
  4019fa:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  4019fc:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401a00:	d0f1      	beq.n	4019e6 <hsmci_read_word+0x6a>
	return true;
  401a02:	f04f 0001 	mov.w	r0, #1
  401a06:	bd08      	pop	{r3, pc}

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  401a08:	f04f 0001 	mov.w	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401a0c:	bd08      	pop	{r3, pc}
  401a0e:	bf00      	nop

00401a10 <hsmci_start_read_blocks>:
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401a10:	f240 4384 	movw	r3, #1156	; 0x484
  401a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a18:	881b      	ldrh	r3, [r3, #0]
  401a1a:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  401a1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a22:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401a26:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  401a28:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401a2c:	bf0c      	ite	eq
  401a2e:	088a      	lsreq	r2, r1, #2
  401a30:	460a      	movne	r2, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401a32:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a36:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  401a3a:	f04f 0200 	mov.w	r2, #0
  401a3e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	// Start transfert
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  401a42:	f04f 0001 	mov.w	r0, #1
  401a46:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401a4a:	f240 4388 	movw	r3, #1160	; 0x488
  401a4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a52:	681a      	ldr	r2, [r3, #0]
  401a54:	1889      	adds	r1, r1, r2
  401a56:	6019      	str	r1, [r3, #0]
	return true;
}
  401a58:	4770      	bx	lr
  401a5a:	bf00      	nop

00401a5c <hsmci_wait_end_of_read_blocks>:

bool hsmci_wait_end_of_read_blocks(void)
{
  401a5c:	b508      	push	{r3, lr}
	uint32_t sr;
	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401a5e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401a62:	f04f 0200 	mov.w	r2, #0
  401a66:	f2cc 0260 	movt	r2, #49248	; 0xc060
{
	uint32_t sr;
	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401a6a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401a6c:	4213      	tst	r3, r2
  401a6e:	d00d      	beq.n	401a8c <hsmci_wait_end_of_read_blocks+0x30>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401a70:	f240 2202 	movw	r2, #514	; 0x202
  401a74:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a78:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			hsmci_reset();
  401a7c:	f241 637d 	movw	r3, #5757	; 0x167d
  401a80:	f2c0 0340 	movt	r3, #64	; 0x40
  401a84:	4798      	blx	r3
			return false;
  401a86:	f04f 0000 	mov.w	r0, #0
  401a8a:	bd08      	pop	{r3, pc}
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  401a8c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  401a90:	d0eb      	beq.n	401a6a <hsmci_wait_end_of_read_blocks+0xe>

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401a92:	f240 4386 	movw	r3, #1158	; 0x486
  401a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a9a:	881a      	ldrh	r2, [r3, #0]
  401a9c:	f240 4384 	movw	r3, #1156	; 0x484
  401aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401aa4:	881b      	ldrh	r3, [r3, #0]
  401aa6:	fb03 f202 	mul.w	r2, r3, r2
  401aaa:	f240 4388 	movw	r3, #1160	; 0x488
  401aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401ab2:	681b      	ldr	r3, [r3, #0]
  401ab4:	429a      	cmp	r2, r3
  401ab6:	d816      	bhi.n	401ae6 <hsmci_wait_end_of_read_blocks+0x8a>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ab8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401abc:	f04f 0200 	mov.w	r2, #0
  401ac0:	f2cc 0260 	movt	r2, #49248	; 0xc060
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ac4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401ac6:	4213      	tst	r3, r2
  401ac8:	d007      	beq.n	401ada <hsmci_wait_end_of_read_blocks+0x7e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  401aca:	f241 637d 	movw	r3, #5757	; 0x167d
  401ace:	f2c0 0340 	movt	r3, #64	; 0x40
  401ad2:	4798      	blx	r3
			return false;
  401ad4:	f04f 0000 	mov.w	r0, #0
  401ad8:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401ada:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401ade:	d0f1      	beq.n	401ac4 <hsmci_wait_end_of_read_blocks+0x68>
	return true;
  401ae0:	f04f 0001 	mov.w	r0, #1
  401ae4:	bd08      	pop	{r3, pc}
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401ae6:	f04f 0001 	mov.w	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401aea:	bd08      	pop	{r3, pc}

00401aec <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401aec:	f240 4384 	movw	r3, #1156	; 0x484
  401af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401af4:	881b      	ldrh	r3, [r3, #0]
  401af6:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_TPR = (uint32_t)src;
  401afa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401afe:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401b02:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  401b04:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401b08:	bf0c      	ite	eq
  401b0a:	088a      	lsreq	r2, r1, #2
  401b0c:	460a      	movne	r2, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401b0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401b12:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  401b16:	f04f 0200 	mov.w	r2, #0
  401b1a:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
	// Start transfert
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401b1e:	f44f 7280 	mov.w	r2, #256	; 0x100
  401b22:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401b26:	f240 4388 	movw	r3, #1160	; 0x488
  401b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b2e:	681a      	ldr	r2, [r3, #0]
  401b30:	1889      	adds	r1, r1, r2
  401b32:	6019      	str	r1, [r3, #0]
	return true;
}
  401b34:	f04f 0001 	mov.w	r0, #1
  401b38:	4770      	bx	lr
  401b3a:	bf00      	nop

00401b3c <hsmci_wait_end_of_write_blocks>:

bool hsmci_wait_end_of_write_blocks(void)
{
  401b3c:	b508      	push	{r3, lr}
	uint32_t sr;

	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b3e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  401b42:	f04f 0200 	mov.w	r2, #0
  401b46:	f2cc 0260 	movt	r2, #49248	; 0xc060
	uint32_t sr;

	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b4a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr &
  401b4c:	4213      	tst	r3, r2
  401b4e:	d00d      	beq.n	401b6c <hsmci_wait_end_of_write_blocks+0x30>
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  401b50:	f241 637d 	movw	r3, #5757	; 0x167d
  401b54:	f2c0 0340 	movt	r3, #64	; 0x40
  401b58:	4798      	blx	r3
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401b5a:	f240 2202 	movw	r2, #514	; 0x202
  401b5e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401b62:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			return false;
  401b66:	f04f 0000 	mov.w	r0, #0
  401b6a:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  401b6c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401b70:	d0eb      	beq.n	401b4a <hsmci_wait_end_of_write_blocks+0xe>


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401b72:	f240 4386 	movw	r3, #1158	; 0x486
  401b76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b7a:	881a      	ldrh	r2, [r3, #0]
  401b7c:	f240 4384 	movw	r3, #1156	; 0x484
  401b80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b84:	881b      	ldrh	r3, [r3, #0]
  401b86:	fb03 f202 	mul.w	r2, r3, r2
  401b8a:	f240 4388 	movw	r3, #1160	; 0x488
  401b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b92:	681b      	ldr	r3, [r3, #0]
  401b94:	429a      	cmp	r2, r3
  401b96:	d816      	bhi.n	401bc6 <hsmci_wait_end_of_write_blocks+0x8a>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b98:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401b9c:	f04f 0200 	mov.w	r2, #0
  401ba0:	f2cc 0260 	movt	r2, #49248	; 0xc060
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ba4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401ba6:	4213      	tst	r3, r2
  401ba8:	d007      	beq.n	401bba <hsmci_wait_end_of_write_blocks+0x7e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  401baa:	f241 637d 	movw	r3, #5757	; 0x167d
  401bae:	f2c0 0340 	movt	r3, #64	; 0x40
  401bb2:	4798      	blx	r3
			return false;
  401bb4:	f04f 0000 	mov.w	r0, #0
  401bb8:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  401bba:	f013 0f20 	tst.w	r3, #32
  401bbe:	d0f1      	beq.n	401ba4 <hsmci_wait_end_of_write_blocks+0x68>
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
  401bc0:	f04f 0001 	mov.w	r0, #1
  401bc4:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401bc6:	f04f 0001 	mov.w	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  401bca:	bd08      	pop	{r3, pc}

00401bcc <pio_pull_up>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  401bcc:	b10a      	cbz	r2, 401bd2 <pio_pull_up+0x6>
		p_pio->PIO_PUER = ul_mask;
  401bce:	6641      	str	r1, [r0, #100]	; 0x64
  401bd0:	4770      	bx	lr
	} else {
		p_pio->PIO_PUDR = ul_mask;
  401bd2:	6601      	str	r1, [r0, #96]	; 0x60
  401bd4:	4770      	bx	lr
  401bd6:	bf00      	nop

00401bd8 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  401bd8:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  401bda:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S)
	switch (ul_type) {
  401bdc:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  401be0:	d02f      	beq.n	401c42 <pio_set_peripheral+0x6a>
  401be2:	d808      	bhi.n	401bf6 <pio_set_peripheral+0x1e>
  401be4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  401be8:	d014      	beq.n	401c14 <pio_set_peripheral+0x3c>
  401bea:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  401bee:	d01e      	beq.n	401c2e <pio_set_peripheral+0x56>
  401bf0:	2900      	cmp	r1, #0
  401bf2:	d037      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401bf4:	e035      	b.n	401c62 <pio_set_peripheral+0x8a>
  401bf6:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  401bfa:	d033      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401bfc:	d803      	bhi.n	401c06 <pio_set_peripheral+0x2e>
  401bfe:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  401c02:	d12e      	bne.n	401c62 <pio_set_peripheral+0x8a>
  401c04:	e027      	b.n	401c56 <pio_set_peripheral+0x7e>
  401c06:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  401c0a:	d02b      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401c0c:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  401c10:	d127      	bne.n	401c62 <pio_set_peripheral+0x8a>
  401c12:	e027      	b.n	401c64 <pio_set_peripheral+0x8c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c14:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401c16:	6f04      	ldr	r4, [r0, #112]	; 0x70
  401c18:	ea6f 0302 	mvn.w	r3, r2
  401c1c:	4021      	ands	r1, r4
  401c1e:	4019      	ands	r1, r3
  401c20:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c22:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401c24:	6f44      	ldr	r4, [r0, #116]	; 0x74
  401c26:	4021      	ands	r1, r4
  401c28:	400b      	ands	r3, r1
  401c2a:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c2c:	e019      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c2e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401c30:	4313      	orrs	r3, r2
  401c32:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c34:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401c36:	6f41      	ldr	r1, [r0, #116]	; 0x74
  401c38:	400b      	ands	r3, r1
  401c3a:	ea23 0302 	bic.w	r3, r3, r2
  401c3e:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c40:	e00f      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c42:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401c44:	6f01      	ldr	r1, [r0, #112]	; 0x70
  401c46:	400b      	ands	r3, r1
  401c48:	ea23 0302 	bic.w	r3, r3, r2
  401c4c:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c4e:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401c50:	4313      	orrs	r3, r2
  401c52:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c54:	e005      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c56:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401c58:	4313      	orrs	r3, r2
  401c5a:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c5c:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401c5e:	4313      	orrs	r3, r2
  401c60:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
  401c62:	6042      	str	r2, [r0, #4]
}
  401c64:	bc10      	pop	{r4}
  401c66:	4770      	bx	lr

00401c68 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  401c68:	6441      	str	r1, [r0, #68]	; 0x44
  401c6a:	4770      	bx	lr

00401c6c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  401c6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401c70:	4604      	mov	r4, r0
  401c72:	460d      	mov	r5, r1
  401c74:	4617      	mov	r7, r2
  401c76:	4698      	mov	r8, r3
	pio_disable_interrupt(p_pio, ul_mask);
  401c78:	f641 4669 	movw	r6, #7273	; 0x1c69
  401c7c:	f2c0 0640 	movt	r6, #64	; 0x40
  401c80:	47b0      	blx	r6
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  401c82:	4620      	mov	r0, r4
  401c84:	4629      	mov	r1, r5
  401c86:	9a06      	ldr	r2, [sp, #24]
  401c88:	f641 36cd 	movw	r6, #7117	; 0x1bcd
  401c8c:	f2c0 0640 	movt	r6, #64	; 0x40
  401c90:	47b0      	blx	r6

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  401c92:	f1b8 0f00 	cmp.w	r8, #0
  401c96:	d001      	beq.n	401c9c <pio_set_output+0x30>
		p_pio->PIO_MDER = ul_mask;
  401c98:	6525      	str	r5, [r4, #80]	; 0x50
  401c9a:	e000      	b.n	401c9e <pio_set_output+0x32>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  401c9c:	6565      	str	r5, [r4, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  401c9e:	b10f      	cbz	r7, 401ca4 <pio_set_output+0x38>
		p_pio->PIO_SODR = ul_mask;
  401ca0:	6325      	str	r5, [r4, #48]	; 0x30
  401ca2:	e000      	b.n	401ca6 <pio_set_output+0x3a>
	} else {
		p_pio->PIO_CODR = ul_mask;
  401ca4:	6365      	str	r5, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  401ca6:	6125      	str	r5, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  401ca8:	6025      	str	r5, [r4, #0]
  401caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401cae:	bf00      	nop

00401cb0 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  401cb0:	b570      	push	{r4, r5, r6, lr}
  401cb2:	4604      	mov	r4, r0
  401cb4:	460d      	mov	r5, r1
  401cb6:	4616      	mov	r6, r2
	pio_disable_interrupt(p_pio, ul_mask);
  401cb8:	f641 4369 	movw	r3, #7273	; 0x1c69
  401cbc:	f2c0 0340 	movt	r3, #64	; 0x40
  401cc0:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  401cc2:	4620      	mov	r0, r4
  401cc4:	4629      	mov	r1, r5
  401cc6:	f006 0201 	and.w	r2, r6, #1
  401cca:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401cce:	f2c0 0340 	movt	r3, #64	; 0x40
  401cd2:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  401cd4:	f016 0f0a 	tst.w	r6, #10
		p_pio->PIO_IFER = ul_mask;
  401cd8:	bf14      	ite	ne
  401cda:	6225      	strne	r5, [r4, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  401cdc:	6265      	streq	r5, [r4, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  401cde:	f016 0f02 	tst.w	r6, #2
		p_pio->PIO_IFSCDR = ul_mask;
  401ce2:	bf18      	it	ne
  401ce4:	f8c4 5080 	strne.w	r5, [r4, #128]	; 0x80
		p_pio->PIO_IFDR = ul_mask;
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  401ce8:	d104      	bne.n	401cf4 <pio_set_input+0x44>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  401cea:	f016 0f08 	tst.w	r6, #8
			p_pio->PIO_IFSCER = ul_mask;
  401cee:	bf18      	it	ne
  401cf0:	f8c4 5084 	strne.w	r5, [r4, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  401cf4:	6165      	str	r5, [r4, #20]
	p_pio->PIO_PER = ul_mask;
  401cf6:	6025      	str	r5, [r4, #0]
  401cf8:	bd70      	pop	{r4, r5, r6, pc}
  401cfa:	bf00      	nop

00401cfc <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  401cfc:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  401cfe:	4770      	bx	lr

00401d00 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  401d00:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  401d02:	4770      	bx	lr

00401d04 <pio_get_pin_value>:
 * \note If pin is input: PIOx must be clocked to sample the signal.
 *       See PMC driver.
 */
uint32_t pio_get_pin_value(uint32_t ul_pin)
{
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d04:	ea4f 1350 	mov.w	r3, r0, lsr #5
  401d08:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d0c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d10:	ea4f 2343 	mov.w	r3, r3, lsl #9
	return (p_pio->PIO_PDSR >> (ul_pin & 0x1F)) & 1;
  401d14:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  401d16:	f000 001f 	and.w	r0, r0, #31
  401d1a:	fa23 f000 	lsr.w	r0, r3, r0
}
  401d1e:	f000 0001 	and.w	r0, r0, #1
  401d22:	4770      	bx	lr

00401d24 <pio_set_pin_high>:
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d24:	ea4f 1350 	mov.w	r3, r0, lsr #5
  401d28:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d2c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d30:	ea4f 2343 	mov.w	r3, r3, lsl #9
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  401d34:	f000 001f 	and.w	r0, r0, #31
  401d38:	f04f 0201 	mov.w	r2, #1
  401d3c:	fa02 f000 	lsl.w	r0, r2, r0
  401d40:	6318      	str	r0, [r3, #48]	; 0x30
  401d42:	4770      	bx	lr

00401d44 <pio_set_pin_low>:
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d44:	ea4f 1350 	mov.w	r3, r0, lsr #5
  401d48:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d4c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d50:	ea4f 2343 	mov.w	r3, r3, lsl #9
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  401d54:	f000 001f 	and.w	r0, r0, #31
  401d58:	f04f 0201 	mov.w	r2, #1
  401d5c:	fa02 f000 	lsl.w	r0, r2, r0
  401d60:	6358      	str	r0, [r3, #52]	; 0x34
  401d62:	4770      	bx	lr

00401d64 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  401d64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401d68:	b082      	sub	sp, #8
  401d6a:	460d      	mov	r5, r1
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d6c:	ea4f 1650 	mov.w	r6, r0, lsr #5
  401d70:	f506 1600 	add.w	r6, r6, #2097152	; 0x200000
  401d74:	f206 7607 	addw	r6, r6, #1799	; 0x707
  401d78:	ea4f 2646 	mov.w	r6, r6, lsl #9

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  401d7c:	f001 44f0 	and.w	r4, r1, #2013265920	; 0x78000000
  401d80:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  401d84:	d064      	beq.n	401e50 <pio_configure_pin+0xec>
  401d86:	d80a      	bhi.n	401d9e <pio_configure_pin+0x3a>
  401d88:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  401d8c:	d02c      	beq.n	401de8 <pio_configure_pin+0x84>
  401d8e:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  401d92:	d043      	beq.n	401e1c <pio_configure_pin+0xb8>
  401d94:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  401d98:	f040 809d 	bne.w	401ed6 <pio_configure_pin+0x172>
  401d9c:	e00a      	b.n	401db4 <pio_configure_pin+0x50>
  401d9e:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  401da2:	d07e      	beq.n	401ea2 <pio_configure_pin+0x13e>
  401da4:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  401da8:	d07b      	beq.n	401ea2 <pio_configure_pin+0x13e>
  401daa:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  401dae:	f040 8092 	bne.w	401ed6 <pio_configure_pin+0x172>
  401db2:	e067      	b.n	401e84 <pio_configure_pin+0x120>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  401db4:	f000 031f 	and.w	r3, r0, #31
  401db8:	f04f 0701 	mov.w	r7, #1
  401dbc:	fa07 f803 	lsl.w	r8, r7, r3
  401dc0:	4630      	mov	r0, r6
  401dc2:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401dc6:	4642      	mov	r2, r8
  401dc8:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401dcc:	f2c0 0440 	movt	r4, #64	; 0x40
  401dd0:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401dd2:	4630      	mov	r0, r6
  401dd4:	4641      	mov	r1, r8
  401dd6:	ea05 0207 	and.w	r2, r5, r7
  401dda:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401dde:	f2c0 0340 	movt	r3, #64	; 0x40
  401de2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401de4:	4638      	mov	r0, r7
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401de6:	e078      	b.n	401eda <pio_configure_pin+0x176>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  401de8:	f000 031f 	and.w	r3, r0, #31
  401dec:	f04f 0701 	mov.w	r7, #1
  401df0:	fa07 f803 	lsl.w	r8, r7, r3
  401df4:	4630      	mov	r0, r6
  401df6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  401dfa:	4642      	mov	r2, r8
  401dfc:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401e00:	f2c0 0440 	movt	r4, #64	; 0x40
  401e04:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401e06:	4630      	mov	r0, r6
  401e08:	4641      	mov	r1, r8
  401e0a:	ea05 0207 	and.w	r2, r5, r7
  401e0e:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401e12:	f2c0 0340 	movt	r3, #64	; 0x40
  401e16:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e18:	4638      	mov	r0, r7
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401e1a:	e05e      	b.n	401eda <pio_configure_pin+0x176>
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  401e1c:	f000 031f 	and.w	r3, r0, #31
  401e20:	f04f 0701 	mov.w	r7, #1
  401e24:	fa07 f803 	lsl.w	r8, r7, r3
  401e28:	4630      	mov	r0, r6
  401e2a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  401e2e:	4642      	mov	r2, r8
  401e30:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401e34:	f2c0 0440 	movt	r4, #64	; 0x40
  401e38:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401e3a:	4630      	mov	r0, r6
  401e3c:	4641      	mov	r1, r8
  401e3e:	ea05 0207 	and.w	r2, r5, r7
  401e42:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401e46:	f2c0 0340 	movt	r3, #64	; 0x40
  401e4a:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e4c:	4638      	mov	r0, r7
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401e4e:	e044      	b.n	401eda <pio_configure_pin+0x176>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  401e50:	f000 031f 	and.w	r3, r0, #31
  401e54:	f04f 0701 	mov.w	r7, #1
  401e58:	fa07 f803 	lsl.w	r8, r7, r3
  401e5c:	4630      	mov	r0, r6
  401e5e:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  401e62:	4642      	mov	r2, r8
  401e64:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401e68:	f2c0 0440 	movt	r4, #64	; 0x40
  401e6c:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401e6e:	4630      	mov	r0, r6
  401e70:	4641      	mov	r1, r8
  401e72:	ea05 0207 	and.w	r2, r5, r7
  401e76:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401e7a:	f2c0 0340 	movt	r3, #64	; 0x40
  401e7e:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e80:	4638      	mov	r0, r7
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401e82:	e02a      	b.n	401eda <pio_configure_pin+0x176>
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  401e84:	f000 011f 	and.w	r1, r0, #31
  401e88:	f04f 0401 	mov.w	r4, #1
  401e8c:	4630      	mov	r0, r6
  401e8e:	fa04 f101 	lsl.w	r1, r4, r1
  401e92:	462a      	mov	r2, r5
  401e94:	f641 43b1 	movw	r3, #7345	; 0x1cb1
  401e98:	f2c0 0340 	movt	r3, #64	; 0x40
  401e9c:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e9e:	4620      	mov	r0, r4
		break;
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  401ea0:	e01b      	b.n	401eda <pio_configure_pin+0x176>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401ea2:	f000 031f 	and.w	r3, r0, #31
  401ea6:	f04f 0701 	mov.w	r7, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  401eaa:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401eae:	ea05 0107 	and.w	r1, r5, r7
  401eb2:	9100      	str	r1, [sp, #0]
  401eb4:	4630      	mov	r0, r6
  401eb6:	fa07 f103 	lsl.w	r1, r7, r3
  401eba:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  401ebe:	bf14      	ite	ne
  401ec0:	2200      	movne	r2, #0
  401ec2:	2201      	moveq	r2, #1
  401ec4:	f3c5 0380 	ubfx	r3, r5, #2, #1
  401ec8:	f641 446d 	movw	r4, #7277	; 0x1c6d
  401ecc:	f2c0 0440 	movt	r4, #64	; 0x40
  401ed0:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
  401ed2:	4638      	mov	r0, r7
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  401ed4:	e001      	b.n	401eda <pio_configure_pin+0x176>

	default:
		return 0;
  401ed6:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  401eda:	b002      	add	sp, #8
  401edc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00401ee0 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  401ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401ee2:	4604      	mov	r4, r0
  401ee4:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  401ee6:	f641 43fd 	movw	r3, #7421	; 0x1cfd
  401eea:	f2c0 0340 	movt	r3, #64	; 0x40
  401eee:	4798      	blx	r3
  401ef0:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  401ef2:	4620      	mov	r0, r4
  401ef4:	f641 5301 	movw	r3, #7425	; 0x1d01
  401ef8:	f2c0 0340 	movt	r3, #64	; 0x40
  401efc:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  401efe:	4005      	ands	r5, r0
  401f00:	d014      	beq.n	401f2c <pio_handler_process+0x4c>
  401f02:	4c0b      	ldr	r4, [pc, #44]	; (401f30 <pio_handler_process+0x50>)
 * \brief Process an interrupt request on the given PIO controller.
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
  401f04:	4627      	mov	r7, r4
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  401f06:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  401f0a:	42b3      	cmp	r3, r6
  401f0c:	d10a      	bne.n	401f24 <pio_handler_process+0x44>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  401f0e:	f854 1c08 	ldr.w	r1, [r4, #-8]
  401f12:	4229      	tst	r1, r5
  401f14:	d006      	beq.n	401f24 <pio_handler_process+0x44>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  401f16:	6823      	ldr	r3, [r4, #0]
  401f18:	4630      	mov	r0, r6
  401f1a:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  401f1c:	f854 3c08 	ldr.w	r3, [r4, #-8]
  401f20:	ea25 0503 	bic.w	r5, r5, r3
  401f24:	f104 0410 	add.w	r4, r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  401f28:	2d00      	cmp	r5, #0
  401f2a:	d1eb      	bne.n	401f04 <pio_handler_process+0x24>
  401f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401f2e:	bf00      	nop
  401f30:	20000498 	.word	0x20000498

00401f34 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  401f34:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  401f36:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  401f3a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f3e:	f04f 010b 	mov.w	r1, #11
  401f42:	f641 63e1 	movw	r3, #7905	; 0x1ee1
  401f46:	f2c0 0340 	movt	r3, #64	; 0x40
  401f4a:	4798      	blx	r3
  401f4c:	bd08      	pop	{r3, pc}
  401f4e:	bf00      	nop

00401f50 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  401f50:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  401f52:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  401f56:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f5a:	f04f 010c 	mov.w	r1, #12
  401f5e:	f641 63e1 	movw	r3, #7905	; 0x1ee1
  401f62:	f2c0 0340 	movt	r3, #64	; 0x40
  401f66:	4798      	blx	r3
  401f68:	bd08      	pop	{r3, pc}
  401f6a:	bf00      	nop

00401f6c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  401f6c:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  401f6e:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  401f72:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f76:	f04f 010d 	mov.w	r1, #13
  401f7a:	f641 63e1 	movw	r3, #7905	; 0x1ee1
  401f7e:	f2c0 0340 	movt	r3, #64	; 0x40
  401f82:	4798      	blx	r3
  401f84:	bd08      	pop	{r3, pc}
  401f86:	bf00      	nop

00401f88 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  401f88:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401f8c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401f90:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401f92:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  401f96:	4310      	orrs	r0, r2
  401f98:	6318      	str	r0, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401f9a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401f9c:	f013 0f08 	tst.w	r3, #8
  401fa0:	bf02      	ittt	eq
  401fa2:	f44f 6300 	moveq.w	r3, #2048	; 0x800
  401fa6:	f44f 6180 	moveq.w	r1, #1024	; 0x400
  401faa:	f2c4 010e 	movteq	r1, #16398	; 0x400e
  401fae:	d003      	beq.n	401fb8 <pmc_switch_mck_to_pllack+0x30>
  401fb0:	e006      	b.n	401fc0 <pmc_switch_mck_to_pllack+0x38>
			--ul_timeout) {
		if (ul_timeout == 0) {
  401fb2:	3b01      	subs	r3, #1
  401fb4:	d100      	bne.n	401fb8 <pmc_switch_mck_to_pllack+0x30>
  401fb6:	e025      	b.n	402004 <pmc_switch_mck_to_pllack+0x7c>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401fb8:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  401fba:	f012 0f08 	tst.w	r2, #8
  401fbe:	d0f8      	beq.n	401fb2 <pmc_switch_mck_to_pllack+0x2a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  401fc0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401fc4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401fc8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401fca:	f022 0203 	bic.w	r2, r2, #3
  401fce:	f042 0202 	orr.w	r2, r2, #2
  401fd2:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401fd4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401fd6:	f013 0f08 	tst.w	r3, #8
  401fda:	bf02      	ittt	eq
  401fdc:	f44f 6300 	moveq.w	r3, #2048	; 0x800
  401fe0:	f44f 6180 	moveq.w	r1, #1024	; 0x400
  401fe4:	f2c4 010e 	movteq	r1, #16398	; 0x400e
  401fe8:	d005      	beq.n	401ff6 <pmc_switch_mck_to_pllack+0x6e>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401fea:	f04f 0000 	mov.w	r0, #0
  401fee:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  401ff0:	3b01      	subs	r3, #1
  401ff2:	d100      	bne.n	401ff6 <pmc_switch_mck_to_pllack+0x6e>
  401ff4:	e009      	b.n	40200a <pmc_switch_mck_to_pllack+0x82>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401ff6:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  401ff8:	f012 0f08 	tst.w	r2, #8
  401ffc:	d0f8      	beq.n	401ff0 <pmc_switch_mck_to_pllack+0x68>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401ffe:	f04f 0000 	mov.w	r0, #0
  402002:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  402004:	f04f 0001 	mov.w	r0, #1
  402008:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  40200a:	f04f 0001 	mov.w	r0, #1
		}
	}

	return 0;
}
  40200e:	4770      	bx	lr

00402010 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  402010:	b180      	cbz	r0, 402034 <pmc_switch_mainck_to_xtal+0x24>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402012:	f44f 6180 	mov.w	r1, #1024	; 0x400
  402016:	f2c4 010e 	movt	r1, #16398	; 0x400e
  40201a:	6a0b      	ldr	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
  40201c:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  402020:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  402024:	401a      	ands	r2, r3
  402026:	f04f 0302 	mov.w	r3, #2
  40202a:	f2c0 1337 	movt	r3, #311	; 0x137
  40202e:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402030:	620b      	str	r3, [r1, #32]
  402032:	4770      	bx	lr
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402034:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402038:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40203c:	6a1a      	ldr	r2, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  40203e:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  402042:	f022 0203 	bic.w	r2, r2, #3
  402046:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  40204a:	f042 0201 	orr.w	r2, r2, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40204e:	ea4f 6101 	mov.w	r1, r1, lsl #24
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  402052:	ea42 4111 	orr.w	r1, r2, r1, lsr #16
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402056:	6219      	str	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  402058:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40205c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  402060:	6e93      	ldr	r3, [r2, #104]	; 0x68
  402062:	f013 0f01 	tst.w	r3, #1
  402066:	d0fb      	beq.n	402060 <pmc_switch_mainck_to_xtal+0x50>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
  402068:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40206c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402070:	6a1a      	ldr	r2, [r3, #32]
  402072:	f042 729b 	orr.w	r2, r2, #20316160	; 0x1360000
  402076:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  40207a:	621a      	str	r2, [r3, #32]
  40207c:	4770      	bx	lr
  40207e:	bf00      	nop

00402080 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  402080:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402084:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402088:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40208a:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  40208e:	4770      	bx	lr

00402090 <pmc_disable_pllack>:
/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  402090:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402094:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402098:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40209c:	629a      	str	r2, [r3, #40]	; 0x28
  40209e:	4770      	bx	lr

004020a0 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4020a0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020a4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020a8:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4020aa:	f000 0002 	and.w	r0, r0, #2
  4020ae:	4770      	bx	lr

004020b0 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  4020b0:	2822      	cmp	r0, #34	; 0x22
  4020b2:	d835      	bhi.n	402120 <pmc_enable_periph_clk+0x70>
		return 1;
	}

	if (ul_id < 32) {
  4020b4:	281f      	cmp	r0, #31
  4020b6:	d817      	bhi.n	4020e8 <pmc_enable_periph_clk+0x38>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  4020b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020bc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020c0:	699a      	ldr	r2, [r3, #24]
  4020c2:	f04f 0301 	mov.w	r3, #1
  4020c6:	fa03 f300 	lsl.w	r3, r3, r0
  4020ca:	401a      	ands	r2, r3
  4020cc:	4293      	cmp	r3, r2
  4020ce:	d02a      	beq.n	402126 <pmc_enable_periph_clk+0x76>
			PMC->PMC_PCER0 = 1 << ul_id;
  4020d0:	f04f 0301 	mov.w	r3, #1
  4020d4:	fa03 f000 	lsl.w	r0, r3, r0
  4020d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020dc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020e0:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  4020e2:	f04f 0000 	mov.w	r0, #0
  4020e6:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4020e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020ec:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020f0:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
  4020f4:	f1a0 0020 	sub.w	r0, r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4020f8:	f04f 0301 	mov.w	r3, #1
  4020fc:	fa03 f300 	lsl.w	r3, r3, r0
  402100:	401a      	ands	r2, r3
  402102:	4293      	cmp	r3, r2
  402104:	d012      	beq.n	40212c <pmc_enable_periph_clk+0x7c>
			PMC->PMC_PCER1 = 1 << ul_id;
  402106:	f04f 0301 	mov.w	r3, #1
  40210a:	fa03 f000 	lsl.w	r0, r3, r0
  40210e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402112:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402116:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  40211a:	f04f 0000 	mov.w	r0, #0
  40211e:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  402120:	f04f 0001 	mov.w	r0, #1
  402124:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  402126:	f04f 0000 	mov.w	r0, #0
  40212a:	4770      	bx	lr
  40212c:	f04f 0000 	mov.w	r0, #0
}
  402130:	4770      	bx	lr
  402132:	bf00      	nop

00402134 <rtc_set_hour_mode>:
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode. 
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  402134:	b121      	cbz	r1, 402140 <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  402136:	6843      	ldr	r3, [r0, #4]
  402138:	f043 0301 	orr.w	r3, r3, #1
  40213c:	6043      	str	r3, [r0, #4]
  40213e:	4770      	bx	lr
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  402140:	6843      	ldr	r3, [r0, #4]
  402142:	f023 0301 	bic.w	r3, r3, #1
  402146:	6043      	str	r3, [r0, #4]
  402148:	4770      	bx	lr
  40214a:	bf00      	nop

0040214c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40214c:	e7fe      	b.n	40214c <Dummy_Handler>
  40214e:	bf00      	nop

00402150 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  402150:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
  402152:	f644 5234 	movw	r2, #19764	; 0x4d34
  402156:	f2c0 0240 	movt	r2, #64	; 0x40
  40215a:	f240 0300 	movw	r3, #0
  40215e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402162:	429a      	cmp	r2, r3
  402164:	d003      	beq.n	40216e <Reset_Handler+0x1e>
		for (; pDest < &_erelocate;) {
  402166:	4b2a      	ldr	r3, [pc, #168]	; (402210 <Reset_Handler+0xc0>)
  402168:	4a2a      	ldr	r2, [pc, #168]	; (402214 <Reset_Handler+0xc4>)
  40216a:	429a      	cmp	r2, r3
  40216c:	d304      	bcc.n	402178 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40216e:	4b2a      	ldr	r3, [pc, #168]	; (402218 <Reset_Handler+0xc8>)
  402170:	4a2a      	ldr	r2, [pc, #168]	; (40221c <Reset_Handler+0xcc>)
  402172:	429a      	cmp	r2, r3
  402174:	d318      	bcc.n	4021a8 <Reset_Handler+0x58>
  402176:	e027      	b.n	4021c8 <Reset_Handler+0x78>

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  402178:	4b29      	ldr	r3, [pc, #164]	; (402220 <Reset_Handler+0xd0>)
  40217a:	4c2a      	ldr	r4, [pc, #168]	; (402224 <Reset_Handler+0xd4>)
  40217c:	1ae4      	subs	r4, r4, r3
  40217e:	f024 0403 	bic.w	r4, r4, #3
  402182:	f104 0404 	add.w	r4, r4, #4
  402186:	f04f 0300 	mov.w	r3, #0
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  40218a:	f240 0000 	movw	r0, #0
  40218e:	f2c2 0000 	movt	r0, #8192	; 0x2000
  402192:	f644 5134 	movw	r1, #19764	; 0x4d34
  402196:	f2c0 0140 	movt	r1, #64	; 0x40
  40219a:	585a      	ldr	r2, [r3, r1]
  40219c:	501a      	str	r2, [r3, r0]
  40219e:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  4021a2:	42a3      	cmp	r3, r4
  4021a4:	d1f9      	bne.n	40219a <Reset_Handler+0x4a>
  4021a6:	e7e2      	b.n	40216e <Reset_Handler+0x1e>
  4021a8:	4b1f      	ldr	r3, [pc, #124]	; (402228 <Reset_Handler+0xd8>)

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  4021aa:	4920      	ldr	r1, [pc, #128]	; (40222c <Reset_Handler+0xdc>)
  4021ac:	1ac9      	subs	r1, r1, r3
  4021ae:	f021 0103 	bic.w	r1, r1, #3
  4021b2:	f240 423c 	movw	r2, #1084	; 0x43c
  4021b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4021ba:	188a      	adds	r2, r1, r2
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  4021bc:	f04f 0100 	mov.w	r1, #0
  4021c0:	f843 1f04 	str.w	r1, [r3, #4]!
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4021c4:	4293      	cmp	r3, r2
  4021c6:	d1fb      	bne.n	4021c0 <Reset_Handler+0x70>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4021c8:	f240 0300 	movw	r3, #0
  4021cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4021d0:	f023 017f 	bic.w	r1, r3, #127	; 0x7f
  4021d4:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4021d8:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4021dc:	6091      	str	r1, [r2, #8]

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4021de:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  4021e2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4021e6:	bf3f      	itttt	cc
  4021e8:	f44f 436d 	movcc.w	r3, #60672	; 0xed00
  4021ec:	f2ce 0300 	movtcc	r3, #57344	; 0xe000
  4021f0:	689a      	ldrcc	r2, [r3, #8]
  4021f2:	f042 5200 	orrcc.w	r2, r2, #536870912	; 0x20000000
  4021f6:	bf38      	it	cc
  4021f8:	609a      	strcc	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4021fa:	f244 23e9 	movw	r3, #17129	; 0x42e9
  4021fe:	f2c0 0340 	movt	r3, #64	; 0x40
  402202:	4798      	blx	r3

	/* Branch to main function */
	main();
  402204:	f244 0315 	movw	r3, #16405	; 0x4015
  402208:	f2c0 0340 	movt	r3, #64	; 0x40
  40220c:	4798      	blx	r3
  40220e:	e7fe      	b.n	40220e <Reset_Handler+0xbe>
  402210:	2000043c 	.word	0x2000043c
  402214:	20000000 	.word	0x20000000
  402218:	20000e84 	.word	0x20000e84
  40221c:	2000043c 	.word	0x2000043c
  402220:	20000004 	.word	0x20000004
  402224:	2000043f 	.word	0x2000043f
  402228:	20000438 	.word	0x20000438
  40222c:	20000e7f 	.word	0x20000e7f

00402230 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  402230:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402234:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402238:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40223a:	f003 0303 	and.w	r3, r3, #3
  40223e:	2b03      	cmp	r3, #3
  402240:	f200 80a9 	bhi.w	402396 <SystemCoreClockUpdate+0x166>
  402244:	e8df f003 	tbb	[pc, r3]
  402248:	4f4f1402 	.word	0x4f4f1402
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  40224c:	f241 4310 	movw	r3, #5136	; 0x1410
  402250:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402254:	695b      	ldr	r3, [r3, #20]
  402256:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40225a:	f240 0300 	movw	r3, #0
  40225e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402262:	bf14      	ite	ne
  402264:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  402268:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  40226c:	601a      	str	r2, [r3, #0]
  40226e:	e092      	b.n	402396 <SystemCoreClockUpdate+0x166>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  402270:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402274:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402278:	6a1b      	ldr	r3, [r3, #32]
  40227a:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40227e:	d009      	beq.n	402294 <SystemCoreClockUpdate+0x64>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  402280:	f240 0300 	movw	r3, #0
  402284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402288:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  40228c:	f2c0 02b7 	movt	r2, #183	; 0xb7
  402290:	601a      	str	r2, [r3, #0]
  402292:	e080      	b.n	402396 <SystemCoreClockUpdate+0x166>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  402294:	f240 0300 	movw	r3, #0
  402298:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40229c:	f44f 6210 	mov.w	r2, #2304	; 0x900
  4022a0:	f2c0 023d 	movt	r2, #61	; 0x3d
  4022a4:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  4022a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4022aa:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4022ae:	6a1b      	ldr	r3, [r3, #32]
  4022b0:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4022b4:	2b10      	cmp	r3, #16
  4022b6:	d002      	beq.n	4022be <SystemCoreClockUpdate+0x8e>
  4022b8:	2b20      	cmp	r3, #32
  4022ba:	d16c      	bne.n	402396 <SystemCoreClockUpdate+0x166>
  4022bc:	e009      	b.n	4022d2 <SystemCoreClockUpdate+0xa2>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  4022be:	f240 0300 	movw	r3, #0
  4022c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022c6:	f44f 5290 	mov.w	r2, #4608	; 0x1200
  4022ca:	f2c0 027a 	movt	r2, #122	; 0x7a
  4022ce:	601a      	str	r2, [r3, #0]
				break;
  4022d0:	e061      	b.n	402396 <SystemCoreClockUpdate+0x166>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  4022d2:	f240 0300 	movw	r3, #0
  4022d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022da:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  4022de:	f2c0 02b7 	movt	r2, #183	; 0xb7
  4022e2:	601a      	str	r2, [r3, #0]
				break;
  4022e4:	e057      	b.n	402396 <SystemCoreClockUpdate+0x166>
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4022e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4022ea:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4022ee:	6a1b      	ldr	r3, [r3, #32]
  4022f0:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  4022f4:	d009      	beq.n	40230a <SystemCoreClockUpdate+0xda>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  4022f6:	f240 0300 	movw	r3, #0
  4022fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022fe:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  402302:	f2c0 02b7 	movt	r2, #183	; 0xb7
  402306:	601a      	str	r2, [r3, #0]
  402308:	e027      	b.n	40235a <SystemCoreClockUpdate+0x12a>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40230a:	f240 0300 	movw	r3, #0
  40230e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402312:	f44f 6210 	mov.w	r2, #2304	; 0x900
  402316:	f2c0 023d 	movt	r2, #61	; 0x3d
  40231a:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  40231c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402320:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402324:	6a1b      	ldr	r3, [r3, #32]
  402326:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40232a:	2b10      	cmp	r3, #16
  40232c:	d002      	beq.n	402334 <SystemCoreClockUpdate+0x104>
  40232e:	2b20      	cmp	r3, #32
  402330:	d113      	bne.n	40235a <SystemCoreClockUpdate+0x12a>
  402332:	e009      	b.n	402348 <SystemCoreClockUpdate+0x118>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  402334:	f240 0300 	movw	r3, #0
  402338:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40233c:	f44f 5290 	mov.w	r2, #4608	; 0x1200
  402340:	f2c0 027a 	movt	r2, #122	; 0x7a
  402344:	601a      	str	r2, [r3, #0]
				break;
  402346:	e008      	b.n	40235a <SystemCoreClockUpdate+0x12a>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  402348:	f240 0300 	movw	r3, #0
  40234c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402350:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  402354:	f2c0 02b7 	movt	r2, #183	; 0xb7
  402358:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40235a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40235e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402362:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402364:	f003 0303 	and.w	r3, r3, #3
  402368:	2b02      	cmp	r3, #2
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40236a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40236e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402372:	bf07      	ittee	eq
  402374:	6a98      	ldreq	r0, [r3, #40]	; 0x28
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
  402376:	6a99      	ldreq	r1, [r3, #40]	; 0x28
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  402378:	6ad8      	ldrne	r0, [r3, #44]	; 0x2c
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  40237a:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
  40237c:	f240 0300 	movw	r3, #0
  402380:	f2c2 0300 	movt	r3, #8192	; 0x2000
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  402384:	f3c0 400a 	ubfx	r0, r0, #16, #11
  402388:	681a      	ldr	r2, [r3, #0]
  40238a:	fb00 2202 	mla	r2, r0, r2, r2
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  40238e:	b2c9      	uxtb	r1, r1
  402390:	fbb2 f2f1 	udiv	r2, r2, r1
  402394:	601a      	str	r2, [r3, #0]
		break;
	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  402396:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40239a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40239e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4023a0:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4023a4:	2b70      	cmp	r3, #112	; 0x70
  4023a6:	d10e      	bne.n	4023c6 <SystemCoreClockUpdate+0x196>
		SystemCoreClock /= 3U;
  4023a8:	f240 0300 	movw	r3, #0
  4023ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4023b0:	6819      	ldr	r1, [r3, #0]
  4023b2:	f64a 22ab 	movw	r2, #43691	; 0xaaab
  4023b6:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
  4023ba:	fba2 0201 	umull	r0, r2, r2, r1
  4023be:	ea4f 0252 	mov.w	r2, r2, lsr #1
  4023c2:	601a      	str	r2, [r3, #0]
  4023c4:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4023c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4023ca:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023ce:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4023d0:	f240 0300 	movw	r3, #0
  4023d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4023d8:	f3c1 1102 	ubfx	r1, r1, #4, #3
  4023dc:	681a      	ldr	r2, [r3, #0]
  4023de:	fa22 f201 	lsr.w	r2, r2, r1
  4023e2:	601a      	str	r2, [r3, #0]
  4023e4:	4770      	bx	lr
  4023e6:	bf00      	nop

004023e8 <system_init_flash>:
 */
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if (ul_clk < CHIP_FREQ_FWS_0) {
  4023e8:	f642 43ff 	movw	r3, #11519	; 0x2cff
  4023ec:	f2c0 1331 	movt	r3, #305	; 0x131
  4023f0:	4298      	cmp	r0, r3
  4023f2:	d807      	bhi.n	402404 <system_init_flash+0x1c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
  4023f4:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4023f8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023fc:	f04f 0200 	mov.w	r2, #0
  402400:	601a      	str	r2, [r3, #0]
  402402:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  402404:	f645 13ff 	movw	r3, #23039	; 0x59ff
  402408:	f2c0 2362 	movt	r3, #610	; 0x262
  40240c:	4298      	cmp	r0, r3
  40240e:	d807      	bhi.n	402420 <system_init_flash+0x38>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
  402410:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402414:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402418:	f44f 7280 	mov.w	r2, #256	; 0x100
  40241c:	601a      	str	r2, [r3, #0]
  40241e:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  402420:	f248 63ff 	movw	r3, #34559	; 0x86ff
  402424:	f2c0 3393 	movt	r3, #915	; 0x393
  402428:	4298      	cmp	r0, r3
  40242a:	d807      	bhi.n	40243c <system_init_flash+0x54>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
  40242c:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402430:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402434:	f44f 7200 	mov.w	r2, #512	; 0x200
  402438:	601a      	str	r2, [r3, #0]
  40243a:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  40243c:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  402440:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  402444:	4298      	cmp	r0, r3
  402446:	d807      	bhi.n	402458 <system_init_flash+0x70>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
  402448:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  40244c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402450:	f44f 7240 	mov.w	r2, #768	; 0x300
  402454:	601a      	str	r2, [r3, #0]
  402456:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  402458:	f24e 03ff 	movw	r3, #57599	; 0xe0ff
  40245c:	f2c0 53f5 	movt	r3, #1525	; 0x5f5
  402460:	4298      	cmp	r0, r3
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
  402462:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402466:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40246a:	bf94      	ite	ls
  40246c:	f44f 6280 	movls.w	r2, #1024	; 0x400
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
  402470:	f44f 62a0 	movhi.w	r2, #1280	; 0x500
  402474:	601a      	str	r2, [r3, #0]
  402476:	4770      	bx	lr

00402478 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  402478:	b510      	push	{r4, lr}
  40247a:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3 || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  40247c:	f44f 50a3 	mov.w	r0, #5216	; 0x1460
  402480:	f2c4 000e 	movt	r0, #16398	; 0x400e
  402484:	f04f 0100 	mov.w	r1, #0
  402488:	f242 1335 	movw	r3, #8501	; 0x2135
  40248c:	f2c0 0340 	movt	r3, #64	; 0x40
  402490:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  402492:	2c02      	cmp	r4, #2
  402494:	d81b      	bhi.n	4024ce <disk_initialize+0x56>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  402496:	4620      	mov	r0, r4
  402498:	f241 5325 	movw	r3, #5413	; 0x1525
  40249c:	f2c0 0340 	movt	r3, #64	; 0x40
  4024a0:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  4024a2:	2803      	cmp	r0, #3
  4024a4:	d107      	bne.n	4024b6 <disk_initialize+0x3e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4024a6:	4620      	mov	r0, r4
  4024a8:	f241 5325 	movw	r3, #5413	; 0x1525
  4024ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4024b0:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  4024b2:	2803      	cmp	r0, #3
  4024b4:	d00e      	beq.n	4024d4 <disk_initialize+0x5c>
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  4024b6:	b980      	cbnz	r0, 4024da <disk_initialize+0x62>
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  4024b8:	4620      	mov	r0, r4
  4024ba:	f241 5375 	movw	r3, #5493	; 0x1575
  4024be:	f2c0 0340 	movt	r3, #64	; 0x40
  4024c2:	4798      	blx	r3
		return STA_PROTECT;
  4024c4:	2800      	cmp	r0, #0
  4024c6:	bf14      	ite	ne
  4024c8:	2004      	movne	r0, #4
  4024ca:	2000      	moveq	r0, #0
  4024cc:	bd10      	pop	{r4, pc}
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  4024ce:	f04f 0001 	mov.w	r0, #1
  4024d2:	bd10      	pop	{r4, pc}
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
  4024d4:	f04f 0001 	mov.w	r0, #1
  4024d8:	bd10      	pop	{r4, pc}
  4024da:	f04f 0001 	mov.w	r0, #1
		return STA_PROTECT;
	}

	/* The memory should already be initialized */
	return 0;
}
  4024de:	bd10      	pop	{r4, pc}

004024e0 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  4024e0:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  4024e2:	f241 5325 	movw	r3, #5413	; 0x1525
  4024e6:	f2c0 0340 	movt	r3, #64	; 0x40
  4024ea:	4798      	blx	r3
  4024ec:	b120      	cbz	r0, 4024f8 <disk_status+0x18>
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  4024ee:	2802      	cmp	r0, #2
  4024f0:	bf0c      	ite	eq
  4024f2:	2003      	moveq	r0, #3
  4024f4:	2001      	movne	r0, #1
  4024f6:	bd08      	pop	{r3, pc}
 */
DSTATUS disk_status(BYTE drv)
{
	switch (mem_test_unit_ready(drv)) {
	case CTRL_GOOD:
		return 0;
  4024f8:	f04f 0000 	mov.w	r0, #0
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
	}
}
  4024fc:	bd08      	pop	{r3, pc}
  4024fe:	bf00      	nop

00402500 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  402500:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402504:	b082      	sub	sp, #8
  402506:	4606      	mov	r6, r0
  402508:	4688      	mov	r8, r1
  40250a:	4617      	mov	r7, r2
  40250c:	461d      	mov	r5, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  40250e:	f241 5469 	movw	r4, #5481	; 0x1569
  402512:	f2c0 0440 	movt	r4, #64	; 0x40
  402516:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  402518:	4604      	mov	r4, r0
  40251a:	b340      	cbz	r0, 40256e <disk_read+0x6e>
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  40251c:	4630      	mov	r0, r6
  40251e:	a901      	add	r1, sp, #4
  402520:	f241 5345 	movw	r3, #5445	; 0x1545
  402524:	f2c0 0340 	movt	r3, #64	; 0x40
  402528:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
  40252a:	fb04 7205 	mla	r2, r4, r5, r7
			(ul_last_sector_num + 1) * uc_sector_size) {
  40252e:	9b01      	ldr	r3, [sp, #4]
  402530:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402534:	429a      	cmp	r2, r3
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  402536:	bf88      	it	hi
  402538:	2004      	movhi	r0, #4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  40253a:	d820      	bhi.n	40257e <disk_read+0x7e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  40253c:	46a9      	mov	r9, r5
  40253e:	b1cd      	cbz	r5, 402574 <disk_read+0x74>
		if (memory_2_ram(drv, sector + uc_sector_size *
				SECTOR_SIZE_DEFAULT * i,
  402540:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  402544:	463c      	mov	r4, r7
  402546:	f04f 0500 	mov.w	r5, #0
 * \param sector Sector address (LBA).
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
  40254a:	ebc7 0808 	rsb	r8, r7, r8
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
		if (memory_2_ram(drv, sector + uc_sector_size *
  40254e:	f241 5799 	movw	r7, #5529	; 0x1599
  402552:	f2c0 0740 	movt	r7, #64	; 0x40
  402556:	4630      	mov	r0, r6
  402558:	4621      	mov	r1, r4
  40255a:	eb08 0204 	add.w	r2, r8, r4
  40255e:	47b8      	blx	r7
  402560:	b958      	cbnz	r0, 40257a <disk_read+0x7a>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402562:	f105 0501 	add.w	r5, r5, #1
  402566:	4454      	add	r4, sl
  402568:	454d      	cmp	r5, r9
  40256a:	d3f4      	bcc.n	402556 <disk_read+0x56>
  40256c:	e007      	b.n	40257e <disk_read+0x7e>
	uint8_t uc_sector_size = mem_sector_size(drv);
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
		return RES_ERROR;
  40256e:	f04f 0001 	mov.w	r0, #1
  402572:	e004      	b.n	40257e <disk_read+0x7e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  402574:	f04f 0000 	mov.w	r0, #0
  402578:	e001      	b.n	40257e <disk_read+0x7e>
				SECTOR_SIZE_DEFAULT * i,
				buff +
				uc_sector_size *
				SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
  40257a:	f04f 0001 	mov.w	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40257e:	b002      	add	sp, #8
  402580:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00402584 <chk_chr>:
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  402584:	7803      	ldrb	r3, [r0, #0]
  402586:	b133      	cbz	r3, 402596 <chk_chr+0x12>
  402588:	428b      	cmp	r3, r1
  40258a:	d004      	beq.n	402596 <chk_chr+0x12>
  40258c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  402590:	b10b      	cbz	r3, 402596 <chk_chr+0x12>
  402592:	428b      	cmp	r3, r1
  402594:	d1fa      	bne.n	40258c <chk_chr+0x8>
	return *str;
}
  402596:	4618      	mov	r0, r3
  402598:	4770      	bx	lr
  40259a:	bf00      	nop

0040259c <clust2sect>:
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  40259c:	f1a1 0102 	sub.w	r1, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4025a0:	68c3      	ldr	r3, [r0, #12]
  4025a2:	f1a3 0302 	sub.w	r3, r3, #2
  4025a6:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
  4025a8:	bf3d      	ittte	cc
  4025aa:	7882      	ldrbcc	r2, [r0, #2]
  4025ac:	69c3      	ldrcc	r3, [r0, #28]
  4025ae:	fb02 3001 	mlacc	r0, r2, r1, r3
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4025b2:	2000      	movcs	r0, #0
	return clst * fs->csize + fs->database;
}
  4025b4:	4770      	bx	lr
  4025b6:	bf00      	nop

004025b8 <sum_sfn>:
/*-----------------------------------------------------------------------*/
/* Calculate sum of an SFN                                               */
/*-----------------------------------------------------------------------*/
#if _USE_LFN
static
BYTE sum_sfn (
  4025b8:	f100 010b 	add.w	r1, r0, #11
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  4025bc:	f04f 0300 	mov.w	r3, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  4025c0:	ea4f 0253 	mov.w	r2, r3, lsr #1
  4025c4:	ea42 13c3 	orr.w	r3, r2, r3, lsl #7
  4025c8:	f810 2b01 	ldrb.w	r2, [r0], #1
  4025cc:	fa52 f383 	uxtab	r3, r2, r3
  4025d0:	b2db      	uxtb	r3, r3
  4025d2:	4288      	cmp	r0, r1
  4025d4:	d1f4      	bne.n	4025c0 <sum_sfn+0x8>
	return sum;
}
  4025d6:	4618      	mov	r0, r3
  4025d8:	4770      	bx	lr
  4025da:	bf00      	nop

004025dc <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  4025dc:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  4025de:	b188      	cbz	r0, 402604 <validate+0x28>
  4025e0:	7802      	ldrb	r2, [r0, #0]
  4025e2:	b192      	cbz	r2, 40260a <validate+0x2e>
  4025e4:	88c2      	ldrh	r2, [r0, #6]
  4025e6:	428a      	cmp	r2, r1
  4025e8:	d112      	bne.n	402610 <validate+0x34>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  4025ea:	7840      	ldrb	r0, [r0, #1]
  4025ec:	f242 43e1 	movw	r3, #9441	; 0x24e1
  4025f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4025f4:	4798      	blx	r3
  4025f6:	f000 0001 	and.w	r0, r0, #1
		return FR_NOT_READY;
  4025fa:	2800      	cmp	r0, #0
  4025fc:	bf14      	ite	ne
  4025fe:	2003      	movne	r0, #3
  402600:	2000      	moveq	r0, #0
  402602:	bd08      	pop	{r3, pc}
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
  402604:	f04f 0009 	mov.w	r0, #9
  402608:	bd08      	pop	{r3, pc}
  40260a:	f04f 0009 	mov.w	r0, #9
  40260e:	bd08      	pop	{r3, pc}
  402610:	f04f 0009 	mov.w	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  402614:	bd08      	pop	{r3, pc}
  402616:	bf00      	nop

00402618 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  402618:	b538      	push	{r3, r4, r5, lr}
  40261a:	4604      	mov	r4, r0
  40261c:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  40261e:	7840      	ldrb	r0, [r0, #1]
  402620:	f104 0124 	add.w	r1, r4, #36	; 0x24
  402624:	f04f 0301 	mov.w	r3, #1
  402628:	f242 5501 	movw	r5, #9473	; 0x2501
  40262c:	f2c0 0540 	movt	r5, #64	; 0x40
  402630:	47a8      	blx	r5
  402632:	2800      	cmp	r0, #0
  402634:	d13c      	bne.n	4026b0 <check_fs+0x98>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  402636:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
  40263a:	f894 3222 	ldrb.w	r3, [r4, #546]	; 0x222
  40263e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  402642:	b212      	sxth	r2, r2
  402644:	f64a 2355 	movw	r3, #43605	; 0xaa55
  402648:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  40264c:	429a      	cmp	r2, r3
  40264e:	d132      	bne.n	4026b6 <check_fs+0x9e>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  402650:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  402654:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  402658:	ea4f 4303 	mov.w	r3, r3, lsl #16
  40265c:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  402660:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
  402664:	4313      	orrs	r3, r2
  402666:	f894 205b 	ldrb.w	r2, [r4, #91]	; 0x5b
  40266a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  40266e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  402672:	f244 1346 	movw	r3, #16710	; 0x4146
  402676:	f2c0 0354 	movt	r3, #84	; 0x54
  40267a:	429a      	cmp	r2, r3
  40267c:	d01e      	beq.n	4026bc <check_fs+0xa4>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  40267e:	f894 0079 	ldrb.w	r0, [r4, #121]	; 0x79
  402682:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
  402686:	ea4f 4303 	mov.w	r3, r3, lsl #16
  40268a:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
  40268e:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  402692:	4303      	orrs	r3, r0
  402694:	f894 0077 	ldrb.w	r0, [r4, #119]	; 0x77
  402698:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  40269c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  4026a0:	f244 1346 	movw	r3, #16710	; 0x4146
  4026a4:	f2c0 0354 	movt	r3, #84	; 0x54
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
  4026a8:	1ac0      	subs	r0, r0, r3
  4026aa:	bf18      	it	ne
  4026ac:	2001      	movne	r0, #1
  4026ae:	bd38      	pop	{r3, r4, r5, pc}
  4026b0:	f04f 0003 	mov.w	r0, #3
  4026b4:	bd38      	pop	{r3, r4, r5, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
  4026b6:	f04f 0002 	mov.w	r0, #2
  4026ba:	bd38      	pop	{r3, r4, r5, pc}

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
  4026bc:	f04f 0000 	mov.w	r0, #0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  4026c0:	bd38      	pop	{r3, r4, r5, pc}
  4026c2:	bf00      	nop

004026c4 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  4026c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  4026c8:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  4026ca:	781a      	ldrb	r2, [r3, #0]
  4026cc:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  4026d0:	2a09      	cmp	r2, #9
  4026d2:	d808      	bhi.n	4026e6 <chk_mounted+0x22>
  4026d4:	785c      	ldrb	r4, [r3, #1]
  4026d6:	2c3a      	cmp	r4, #58	; 0x3a
  4026d8:	d105      	bne.n	4026e6 <chk_mounted+0x22>
		p += 2; *path = p;				/* Return pointer to the path name */
  4026da:	f103 0302 	add.w	r3, r3, #2
  4026de:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  4026e0:	2a00      	cmp	r2, #0
  4026e2:	f040 8108 	bne.w	4028f6 <chk_mounted+0x232>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  4026e6:	f240 5300 	movw	r3, #1280	; 0x500
  4026ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4026ee:	681c      	ldr	r4, [r3, #0]
  4026f0:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4026f2:	2c00      	cmp	r4, #0
  4026f4:	f000 8103 	beq.w	4028fe <chk_mounted+0x23a>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  4026f8:	7823      	ldrb	r3, [r4, #0]
  4026fa:	b14b      	cbz	r3, 402710 <chk_mounted+0x4c>
		stat = disk_status(fs->drv);
  4026fc:	7860      	ldrb	r0, [r4, #1]
  4026fe:	f242 43e1 	movw	r3, #9441	; 0x24e1
  402702:	f2c0 0340 	movt	r3, #64	; 0x40
  402706:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  402708:	f010 0f01 	tst.w	r0, #1
  40270c:	f000 80fb 	beq.w	402906 <chk_mounted+0x242>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  402710:	f04f 0000 	mov.w	r0, #0
  402714:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  402716:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  402718:	f242 4379 	movw	r3, #9337	; 0x2479
  40271c:	f2c0 0340 	movt	r3, #64	; 0x40
  402720:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  402722:	f010 0f01 	tst.w	r0, #1
  402726:	f040 80f2 	bne.w	40290e <chk_mounted+0x24a>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40272a:	4620      	mov	r0, r4
  40272c:	f04f 0100 	mov.w	r1, #0
  402730:	f242 6319 	movw	r3, #9753	; 0x2619
  402734:	f2c0 0340 	movt	r3, #64	; 0x40
  402738:	4798      	blx	r3
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  40273a:	2801      	cmp	r0, #1
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40273c:	bf18      	it	ne
  40273e:	2500      	movne	r5, #0
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  402740:	d11b      	bne.n	40277a <chk_mounted+0xb6>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  402742:	f894 31e6 	ldrb.w	r3, [r4, #486]	; 0x1e6
  402746:	2b00      	cmp	r3, #0
  402748:	f000 80e5 	beq.w	402916 <chk_mounted+0x252>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  40274c:	f894 21ed 	ldrb.w	r2, [r4, #493]	; 0x1ed
  402750:	f894 31ec 	ldrb.w	r3, [r4, #492]	; 0x1ec
  402754:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402758:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  40275c:	f894 31ea 	ldrb.w	r3, [r4, #490]	; 0x1ea
  402760:	4313      	orrs	r3, r2
  402762:	f894 51eb 	ldrb.w	r5, [r4, #491]	; 0x1eb
  402766:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  40276a:	4620      	mov	r0, r4
  40276c:	4629      	mov	r1, r5
  40276e:	f242 6319 	movw	r3, #9753	; 0x2619
  402772:	f2c0 0340 	movt	r3, #64	; 0x40
  402776:	4798      	blx	r3
  402778:	e7ff      	b.n	40277a <chk_mounted+0xb6>
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  40277a:	2803      	cmp	r0, #3
  40277c:	f000 80cf 	beq.w	40291e <chk_mounted+0x25a>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402780:	2800      	cmp	r0, #0
  402782:	f040 80d0 	bne.w	402926 <chk_mounted+0x262>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  402786:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  40278a:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
  40278e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402792:	b21b      	sxth	r3, r3
  402794:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402798:	f040 80c9 	bne.w	40292e <chk_mounted+0x26a>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  40279c:	f894 003b 	ldrb.w	r0, [r4, #59]	; 0x3b
  4027a0:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  4027a4:	ea53 2000 	orrs.w	r0, r3, r0, lsl #8
  4027a8:	d10e      	bne.n	4027c8 <chk_mounted+0x104>
  4027aa:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
  4027ae:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
  4027b2:	ea4f 4303 	mov.w	r3, r3, lsl #16
  4027b6:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  4027ba:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
  4027be:	4313      	orrs	r3, r2
  4027c0:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
  4027c4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
	fs->fsize = fasize;
  4027c8:	6120      	str	r0, [r4, #16]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  4027ca:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
  4027ce:	70e1      	strb	r1, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  4027d0:	f101 33ff 	add.w	r3, r1, #4294967295
  4027d4:	b2db      	uxtb	r3, r3
  4027d6:	2b01      	cmp	r3, #1
  4027d8:	f200 80ad 	bhi.w	402936 <chk_mounted+0x272>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  4027dc:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
  4027e0:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  4027e2:	2b00      	cmp	r3, #0
  4027e4:	f000 80ab 	beq.w	40293e <chk_mounted+0x27a>
  4027e8:	f103 32ff 	add.w	r2, r3, #4294967295
  4027ec:	421a      	tst	r2, r3
  4027ee:	f040 80aa 	bne.w	402946 <chk_mounted+0x282>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  4027f2:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
  4027f6:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
  4027fa:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  4027fe:	b296      	uxth	r6, r2
  402800:	8126      	strh	r6, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  402802:	f012 0f0f 	tst.w	r2, #15
  402806:	f040 80a2 	bne.w	40294e <chk_mounted+0x28a>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  40280a:	f894 7038 	ldrb.w	r7, [r4, #56]	; 0x38
  40280e:	f894 2037 	ldrb.w	r2, [r4, #55]	; 0x37
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  402812:	ea52 2207 	orrs.w	r2, r2, r7, lsl #8
  402816:	d10e      	bne.n	402836 <chk_mounted+0x172>
  402818:	f894 7047 	ldrb.w	r7, [r4, #71]	; 0x47
  40281c:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
  402820:	ea4f 4202 	mov.w	r2, r2, lsl #16
  402824:	ea42 6707 	orr.w	r7, r2, r7, lsl #24
  402828:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
  40282c:	433a      	orrs	r2, r7
  40282e:	f894 7045 	ldrb.w	r7, [r4, #69]	; 0x45
  402832:	ea42 2207 	orr.w	r2, r2, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  402836:	f894 c033 	ldrb.w	ip, [r4, #51]	; 0x33
  40283a:	f894 7032 	ldrb.w	r7, [r4, #50]	; 0x32
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  40283e:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  402842:	f000 8088 	beq.w	402956 <chk_mounted+0x292>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  402846:	fb01 fc00 	mul.w	ip, r1, r0

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  40284a:	eb07 1116 	add.w	r1, r7, r6, lsr #4
  40284e:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  402850:	428a      	cmp	r2, r1
  402852:	f0c0 8084 	bcc.w	40295e <chk_mounted+0x29a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  402856:	1a52      	subs	r2, r2, r1
  402858:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  40285c:	2b00      	cmp	r3, #0
  40285e:	f000 8082 	beq.w	402966 <chk_mounted+0x2a2>
	fmt = FS_FAT12;
  402862:	f640 72f5 	movw	r2, #4085	; 0xff5
  402866:	4293      	cmp	r3, r2
  402868:	bf8c      	ite	hi
  40286a:	2202      	movhi	r2, #2
  40286c:	2201      	movls	r2, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  40286e:	f64f 78f5 	movw	r8, #65525	; 0xfff5
  402872:	4543      	cmp	r3, r8
  402874:	f200 8087 	bhi.w	402986 <chk_mounted+0x2c2>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402878:	f103 0302 	add.w	r3, r3, #2
  40287c:	60e3      	str	r3, [r4, #12]
	fs->database = bsect + sysect;						/* Data start sector */
  40287e:	1949      	adds	r1, r1, r5
  402880:	61e1      	str	r1, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402882:	19ed      	adds	r5, r5, r7
  402884:	6165      	str	r5, [r4, #20]
	if (fmt == FS_FAT32) {
  402886:	2a03      	cmp	r2, #3
  402888:	d114      	bne.n	4028b4 <chk_mounted+0x1f0>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40288a:	2e00      	cmp	r6, #0
  40288c:	d16f      	bne.n	40296e <chk_mounted+0x2aa>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  40288e:	f894 5053 	ldrb.w	r5, [r4, #83]	; 0x53
  402892:	f894 1052 	ldrb.w	r1, [r4, #82]	; 0x52
  402896:	ea4f 4101 	mov.w	r1, r1, lsl #16
  40289a:	ea41 6505 	orr.w	r5, r1, r5, lsl #24
  40289e:	f894 1050 	ldrb.w	r1, [r4, #80]	; 0x50
  4028a2:	4329      	orrs	r1, r5
  4028a4:	f894 5051 	ldrb.w	r5, [r4, #81]	; 0x51
  4028a8:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
  4028ac:	61a1      	str	r1, [r4, #24]
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  4028ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4028b2:	e00d      	b.n	4028d0 <chk_mounted+0x20c>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  4028b4:	2e00      	cmp	r6, #0
  4028b6:	d05e      	beq.n	402976 <chk_mounted+0x2b2>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4028b8:	4465      	add	r5, ip
  4028ba:	61a5      	str	r5, [r4, #24]
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4028bc:	2a02      	cmp	r2, #2
  4028be:	bf0f      	iteee	eq
  4028c0:	005b      	lsleq	r3, r3, #1
  4028c2:	2103      	movne	r1, #3
  4028c4:	4359      	mulne	r1, r3
  4028c6:	f003 0301 	andne.w	r3, r3, #1
  4028ca:	bf18      	it	ne
  4028cc:	eb03 0351 	addne.w	r3, r3, r1, lsr #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  4028d0:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  4028d4:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
  4028d8:	d351      	bcc.n	40297e <chk_mounted+0x2ba>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  4028da:	7022      	strb	r2, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  4028dc:	4a2f      	ldr	r2, [pc, #188]	; (40299c <chk_mounted+0x2d8>)
  4028de:	8813      	ldrh	r3, [r2, #0]
  4028e0:	f103 0301 	add.w	r3, r3, #1
  4028e4:	b29b      	uxth	r3, r3
  4028e6:	8013      	strh	r3, [r2, #0]
  4028e8:	80e3      	strh	r3, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
  4028ea:	f04f 0000 	mov.w	r0, #0
  4028ee:	6220      	str	r0, [r4, #32]
	fs->wflag = 0;
  4028f0:	7120      	strb	r0, [r4, #4]
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  4028f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
  4028f6:	f04f 000b 	mov.w	r0, #11
  4028fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4028fe:	f04f 000c 	mov.w	r0, #12
  402902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  402906:	f04f 0000 	mov.w	r0, #0
  40290a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  40290e:	f04f 0003 	mov.w	r0, #3
  402912:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402916:	f04f 000d 	mov.w	r0, #13
  40291a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  40291e:	f04f 0001 	mov.w	r0, #1
  402922:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402926:	f04f 000d 	mov.w	r0, #13
  40292a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
  40292e:	f04f 000d 	mov.w	r0, #13
  402932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402936:	f04f 000d 	mov.w	r0, #13
  40293a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  40293e:	f04f 000d 	mov.w	r0, #13
  402942:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402946:	f04f 000d 	mov.w	r0, #13
  40294a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  40294e:	f04f 000d 	mov.w	r0, #13
  402952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  402956:	f04f 000d 	mov.w	r0, #13
  40295a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  40295e:	f04f 000d 	mov.w	r0, #13
  402962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  402966:	f04f 000d 	mov.w	r0, #13
  40296a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40296e:	f04f 000d 	mov.w	r0, #13
  402972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  402976:	f04f 000d 	mov.w	r0, #13
  40297a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
  40297e:	f04f 000d 	mov.w	r0, #13
  402982:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402986:	f103 0302 	add.w	r3, r3, #2
  40298a:	60e3      	str	r3, [r4, #12]
	fs->database = bsect + sysect;						/* Data start sector */
  40298c:	1949      	adds	r1, r1, r5
  40298e:	61e1      	str	r1, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402990:	19ed      	adds	r5, r5, r7
  402992:	6165      	str	r5, [r4, #20]
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402994:	f04f 0203 	mov.w	r2, #3
  402998:	e777      	b.n	40288a <chk_mounted+0x1c6>
  40299a:	bf00      	nop
  40299c:	200004fc 	.word	0x200004fc

004029a0 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  4029a0:	b570      	push	{r4, r5, r6, lr}
  4029a2:	4605      	mov	r5, r0
  4029a4:	460c      	mov	r4, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  4029a6:	6a03      	ldr	r3, [r0, #32]
  4029a8:	428b      	cmp	r3, r1
  4029aa:	d00e      	beq.n	4029ca <move_window+0x2a>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  4029ac:	b181      	cbz	r1, 4029d0 <move_window+0x30>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  4029ae:	7840      	ldrb	r0, [r0, #1]
  4029b0:	f105 0124 	add.w	r1, r5, #36	; 0x24
  4029b4:	4622      	mov	r2, r4
  4029b6:	f04f 0301 	mov.w	r3, #1
  4029ba:	f242 5601 	movw	r6, #9473	; 0x2501
  4029be:	f2c0 0640 	movt	r6, #64	; 0x40
  4029c2:	47b0      	blx	r6
  4029c4:	b938      	cbnz	r0, 4029d6 <move_window+0x36>
				return FR_DISK_ERR;
			fs->winsect = sector;
  4029c6:	622c      	str	r4, [r5, #32]
  4029c8:	bd70      	pop	{r4, r5, r6, pc}
		}
	}

	return FR_OK;
  4029ca:	f04f 0000 	mov.w	r0, #0
  4029ce:	bd70      	pop	{r4, r5, r6, pc}
  4029d0:	f04f 0000 	mov.w	r0, #0
  4029d4:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
  4029d6:	f04f 0001 	mov.w	r0, #1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
  4029da:	bd70      	pop	{r4, r5, r6, pc}

004029dc <get_fat>:

static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
  4029dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4029de:	4605      	mov	r5, r0
  4029e0:	460c      	mov	r4, r1
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4029e2:	2901      	cmp	r1, #1
  4029e4:	d96e      	bls.n	402ac4 <get_fat+0xe8>
  4029e6:	68c3      	ldr	r3, [r0, #12]
  4029e8:	4299      	cmp	r1, r3
  4029ea:	d26e      	bcs.n	402aca <get_fat+0xee>
		return 1;

	switch (fs->fs_type) {
  4029ec:	7803      	ldrb	r3, [r0, #0]
  4029ee:	2b02      	cmp	r3, #2
  4029f0:	d033      	beq.n	402a5a <get_fat+0x7e>
  4029f2:	2b03      	cmp	r3, #3
  4029f4:	d046      	beq.n	402a84 <get_fat+0xa8>
  4029f6:	2b01      	cmp	r3, #1
  4029f8:	d16a      	bne.n	402ad0 <get_fat+0xf4>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  4029fa:	eb01 0651 	add.w	r6, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4029fe:	6941      	ldr	r1, [r0, #20]
  402a00:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402a04:	f642 13a1 	movw	r3, #10657	; 0x29a1
  402a08:	f2c0 0340 	movt	r3, #64	; 0x40
  402a0c:	4798      	blx	r3
  402a0e:	2800      	cmp	r0, #0
  402a10:	d161      	bne.n	402ad6 <get_fat+0xfa>
		wc = fs->win[bc % SS(fs)]; bc++;
  402a12:	ea4f 53c6 	mov.w	r3, r6, lsl #23
  402a16:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  402a1a:	18eb      	adds	r3, r5, r3
  402a1c:	f893 7024 	ldrb.w	r7, [r3, #36]	; 0x24
  402a20:	f106 0601 	add.w	r6, r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402a24:	6969      	ldr	r1, [r5, #20]
  402a26:	4628      	mov	r0, r5
  402a28:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402a2c:	f642 13a1 	movw	r3, #10657	; 0x29a1
  402a30:	f2c0 0340 	movt	r3, #64	; 0x40
  402a34:	4798      	blx	r3
  402a36:	2800      	cmp	r0, #0
  402a38:	d150      	bne.n	402adc <get_fat+0x100>
		wc |= fs->win[bc % SS(fs)] << 8;
  402a3a:	ea4f 56c6 	mov.w	r6, r6, lsl #23
  402a3e:	ea4f 56d6 	mov.w	r6, r6, lsr #23
  402a42:	19ad      	adds	r5, r5, r6
  402a44:	f895 0024 	ldrb.w	r0, [r5, #36]	; 0x24
  402a48:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402a4c:	f014 0f01 	tst.w	r4, #1
  402a50:	bf12      	itee	ne
  402a52:	0900      	lsrne	r0, r0, #4
  402a54:	0500      	lsleq	r0, r0, #20
  402a56:	0d00      	lsreq	r0, r0, #20
  402a58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402a5a:	6941      	ldr	r1, [r0, #20]
  402a5c:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  402a60:	f642 13a1 	movw	r3, #10657	; 0x29a1
  402a64:	f2c0 0340 	movt	r3, #64	; 0x40
  402a68:	4798      	blx	r3
  402a6a:	2800      	cmp	r0, #0
  402a6c:	d139      	bne.n	402ae2 <get_fat+0x106>
		p = &fs->win[clst * 2 % SS(fs)];
  402a6e:	ea4f 6404 	mov.w	r4, r4, lsl #24
		return LD_WORD(p);
  402a72:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
  402a76:	f895 0025 	ldrb.w	r0, [r5, #37]	; 0x25
  402a7a:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
  402a7e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402a82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  402a84:	6941      	ldr	r1, [r0, #20]
  402a86:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  402a8a:	f642 13a1 	movw	r3, #10657	; 0x29a1
  402a8e:	f2c0 0340 	movt	r3, #64	; 0x40
  402a92:	4798      	blx	r3
  402a94:	2800      	cmp	r0, #0
  402a96:	d127      	bne.n	402ae8 <get_fat+0x10c>
		p = &fs->win[clst * 4 % SS(fs)];
  402a98:	ea4f 6444 	mov.w	r4, r4, lsl #25
		return LD_DWORD(p) & 0x0FFFFFFF;
  402a9c:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
  402aa0:	f895 0027 	ldrb.w	r0, [r5, #39]	; 0x27
  402aa4:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
  402aa8:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402aac:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
  402ab0:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
  402ab4:	4303      	orrs	r3, r0
  402ab6:	f895 0025 	ldrb.w	r0, [r5, #37]	; 0x25
  402aba:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402abe:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402ac2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;
  402ac4:	f04f 0001 	mov.w	r0, #1
  402ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402aca:	f04f 0001 	mov.w	r0, #1
  402ace:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402ad0:	f04f 30ff 	mov.w	r0, #4294967295
  402ad4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ad6:	f04f 30ff 	mov.w	r0, #4294967295
  402ada:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402adc:	f04f 30ff 	mov.w	r0, #4294967295
  402ae0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ae2:	f04f 30ff 	mov.w	r0, #4294967295
  402ae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ae8:	f04f 30ff 	mov.w	r0, #4294967295
}
  402aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402aee:	bf00      	nop

00402af0 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402af0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402af2:	4604      	mov	r4, r0
  402af4:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  402af6:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
  402af8:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402afa:	2901      	cmp	r1, #1
  402afc:	d042      	beq.n	402b84 <dir_sdi+0x94>
  402afe:	6803      	ldr	r3, [r0, #0]
  402b00:	68da      	ldr	r2, [r3, #12]
  402b02:	4291      	cmp	r1, r2
  402b04:	d241      	bcs.n	402b8a <dir_sdi+0x9a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  402b06:	b979      	cbnz	r1, 402b28 <dir_sdi+0x38>
  402b08:	781a      	ldrb	r2, [r3, #0]
  402b0a:	2a03      	cmp	r2, #3
  402b0c:	d101      	bne.n	402b12 <dir_sdi+0x22>
		clst = dj->fs->dirbase;
  402b0e:	6999      	ldr	r1, [r3, #24]

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  402b10:	b951      	cbnz	r1, 402b28 <dir_sdi+0x38>
		dj->clust = clst;
  402b12:	f04f 0200 	mov.w	r2, #0
  402b16:	60e2      	str	r2, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  402b18:	891a      	ldrh	r2, [r3, #8]
  402b1a:	42aa      	cmp	r2, r5
  402b1c:	d938      	bls.n	402b90 <dir_sdi+0xa0>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402b1e:	699b      	ldr	r3, [r3, #24]
  402b20:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402b24:	6123      	str	r3, [r4, #16]
  402b26:	e022      	b.n	402b6e <dir_sdi+0x7e>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  402b28:	789e      	ldrb	r6, [r3, #2]
  402b2a:	ea4f 1606 	mov.w	r6, r6, lsl #4
		while (idx >= ic) {	/* Follow cluster chain */
  402b2e:	42b5      	cmp	r5, r6
  402b30:	d313      	bcc.n	402b5a <dir_sdi+0x6a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  402b32:	f642 17dd 	movw	r7, #10717	; 0x29dd
  402b36:	f2c0 0740 	movt	r7, #64	; 0x40
  402b3a:	6820      	ldr	r0, [r4, #0]
  402b3c:	47b8      	blx	r7
  402b3e:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402b40:	f1b0 3fff 	cmp.w	r0, #4294967295
  402b44:	d027      	beq.n	402b96 <dir_sdi+0xa6>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  402b46:	2801      	cmp	r0, #1
  402b48:	d928      	bls.n	402b9c <dir_sdi+0xac>
  402b4a:	6823      	ldr	r3, [r4, #0]
  402b4c:	68db      	ldr	r3, [r3, #12]
  402b4e:	4298      	cmp	r0, r3
  402b50:	d227      	bcs.n	402ba2 <dir_sdi+0xb2>
				return FR_INT_ERR;
			idx -= ic;
  402b52:	1bad      	subs	r5, r5, r6
  402b54:	b2ad      	uxth	r5, r5
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  402b56:	42ae      	cmp	r6, r5
  402b58:	d9ef      	bls.n	402b3a <dir_sdi+0x4a>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  402b5a:	60e1      	str	r1, [r4, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402b5c:	6820      	ldr	r0, [r4, #0]
  402b5e:	f242 539d 	movw	r3, #9629	; 0x259d
  402b62:	f2c0 0340 	movt	r3, #64	; 0x40
  402b66:	4798      	blx	r3
  402b68:	eb00 1015 	add.w	r0, r0, r5, lsr #4
  402b6c:	6120      	str	r0, [r4, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  402b6e:	f005 050f 	and.w	r5, r5, #15
  402b72:	6823      	ldr	r3, [r4, #0]
  402b74:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  402b78:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402b7c:	6163      	str	r3, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  402b7e:	f04f 0000 	mov.w	r0, #0
  402b82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
  402b84:	f04f 0002 	mov.w	r0, #2
  402b88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402b8a:	f04f 0002 	mov.w	r0, #2
  402b8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
  402b90:	f04f 0002 	mov.w	r0, #2
  402b94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402b96:	f04f 0001 	mov.w	r0, #1
  402b9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  402b9c:	f04f 0002 	mov.w	r0, #2
  402ba0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ba2:	f04f 0002 	mov.w	r0, #2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
  402ba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00402ba8 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402ba8:	b570      	push	{r4, r5, r6, lr}
  402baa:	4604      	mov	r4, r0
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  402bac:	88c5      	ldrh	r5, [r0, #6]
  402bae:	f105 0501 	add.w	r5, r5, #1
  402bb2:	b2ad      	uxth	r5, r5
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402bb4:	2d00      	cmp	r5, #0
  402bb6:	d036      	beq.n	402c26 <dir_next+0x7e>
  402bb8:	6903      	ldr	r3, [r0, #16]
  402bba:	2b00      	cmp	r3, #0
  402bbc:	d036      	beq.n	402c2c <dir_next+0x84>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402bbe:	f015 060f 	ands.w	r6, r5, #15
  402bc2:	d126      	bne.n	402c12 <dir_next+0x6a>
		dj->sect++;					/* Next sector */
  402bc4:	f103 0301 	add.w	r3, r3, #1
  402bc8:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
  402bca:	68c1      	ldr	r1, [r0, #12]
  402bcc:	b921      	cbnz	r1, 402bd8 <dir_next+0x30>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402bce:	6803      	ldr	r3, [r0, #0]
  402bd0:	891b      	ldrh	r3, [r3, #8]
  402bd2:	42ab      	cmp	r3, r5
  402bd4:	d92d      	bls.n	402c32 <dir_next+0x8a>
  402bd6:	e01c      	b.n	402c12 <dir_next+0x6a>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402bd8:	6800      	ldr	r0, [r0, #0]
  402bda:	7883      	ldrb	r3, [r0, #2]
  402bdc:	f103 33ff 	add.w	r3, r3, #4294967295
  402be0:	ea13 1315 	ands.w	r3, r3, r5, lsr #4
  402be4:	d115      	bne.n	402c12 <dir_next+0x6a>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
  402be6:	f642 13dd 	movw	r3, #10717	; 0x29dd
  402bea:	f2c0 0340 	movt	r3, #64	; 0x40
  402bee:	4798      	blx	r3
  402bf0:	4601      	mov	r1, r0
				if (clst <= 1) return FR_INT_ERR;
  402bf2:	2801      	cmp	r0, #1
  402bf4:	d920      	bls.n	402c38 <dir_next+0x90>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402bf6:	f1b0 3fff 	cmp.w	r0, #4294967295
  402bfa:	d020      	beq.n	402c3e <dir_next+0x96>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402bfc:	6820      	ldr	r0, [r4, #0]
  402bfe:	68c3      	ldr	r3, [r0, #12]
  402c00:	4299      	cmp	r1, r3
  402c02:	d21f      	bcs.n	402c44 <dir_next+0x9c>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402c04:	60e1      	str	r1, [r4, #12]
				dj->sect = clust2sect(dj->fs, clst);
  402c06:	f242 539d 	movw	r3, #9629	; 0x259d
  402c0a:	f2c0 0340 	movt	r3, #64	; 0x40
  402c0e:	4798      	blx	r3
  402c10:	6120      	str	r0, [r4, #16]
			}
		}
	}

	dj->index = i;
  402c12:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402c14:	6823      	ldr	r3, [r4, #0]
  402c16:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  402c1a:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402c1e:	6163      	str	r3, [r4, #20]

	return FR_OK;
  402c20:	f04f 0000 	mov.w	r0, #0
  402c24:	bd70      	pop	{r4, r5, r6, pc}


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
  402c26:	f04f 0004 	mov.w	r0, #4
  402c2a:	bd70      	pop	{r4, r5, r6, pc}
  402c2c:	f04f 0004 	mov.w	r0, #4
  402c30:	bd70      	pop	{r4, r5, r6, pc}
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
  402c32:	f04f 0004 	mov.w	r0, #4
  402c36:	bd70      	pop	{r4, r5, r6, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402c38:	f04f 0002 	mov.w	r0, #2
  402c3c:	bd70      	pop	{r4, r5, r6, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402c3e:	f04f 0001 	mov.w	r0, #1
  402c42:	bd70      	pop	{r4, r5, r6, pc}
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
  402c44:	f04f 0004 	mov.w	r0, #4

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  402c48:	bd70      	pop	{r4, r5, r6, pc}
  402c4a:	bf00      	nop

00402c4c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
  402c4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  402c50:	460d      	mov	r5, r1
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
  402c52:	f101 0409 	add.w	r4, r1, #9
	if (dj->sect) {
  402c56:	6903      	ldr	r3, [r0, #16]
  402c58:	2b00      	cmp	r3, #0
  402c5a:	d060      	beq.n	402d1e <get_fileinfo+0xd2>
		dir = dj->dir;
  402c5c:	6941      	ldr	r1, [r0, #20]
		nt = dir[DIR_NTres];		/* NT flag */
  402c5e:	f891 800c 	ldrb.w	r8, [r1, #12]
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  402c62:	780b      	ldrb	r3, [r1, #0]
			if (c == ' ') break;
  402c64:	2b20      	cmp	r3, #32
  402c66:	d01b      	beq.n	402ca0 <get_fileinfo+0x54>
  402c68:	460e      	mov	r6, r1
  402c6a:	4622      	mov	r2, r4
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
  402c6c:	f104 0c08 	add.w	ip, r4, #8
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  402c70:	f008 0708 	and.w	r7, r8, #8
  402c74:	b2ff      	uxtb	r7, r7
  402c76:	e003      	b.n	402c80 <get_fileinfo+0x34>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  402c78:	f816 3f01 	ldrb.w	r3, [r6, #1]!
			if (c == ' ') break;
  402c7c:	2b20      	cmp	r3, #32
  402c7e:	d00f      	beq.n	402ca0 <get_fileinfo+0x54>
			if (c == NDDE) c = (TCHAR)DDE;
  402c80:	2b05      	cmp	r3, #5
  402c82:	bf08      	it	eq
  402c84:	23e5      	moveq	r3, #229	; 0xe5
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  402c86:	b137      	cbz	r7, 402c96 <get_fileinfo+0x4a>
  402c88:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
  402c8c:	b2e4      	uxtb	r4, r4
  402c8e:	2c19      	cmp	r4, #25
  402c90:	bf9c      	itt	ls
  402c92:	3320      	addls	r3, #32
  402c94:	b2db      	uxtbls	r3, r3
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
  402c96:	f802 3b01 	strb.w	r3, [r2], #1
  402c9a:	4614      	mov	r4, r2

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  402c9c:	4562      	cmp	r2, ip
  402c9e:	d1eb      	bne.n	402c78 <get_fileinfo+0x2c>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
  402ca0:	7a0b      	ldrb	r3, [r1, #8]
  402ca2:	2b20      	cmp	r3, #32
  402ca4:	d023      	beq.n	402cee <get_fileinfo+0xa2>
			*p++ = '.';
  402ca6:	4623      	mov	r3, r4
  402ca8:	f04f 022e 	mov.w	r2, #46	; 0x2e
  402cac:	f803 2b01 	strb.w	r2, [r3], #1
			for (i = 8; i < 11; i++) {
				c = dir[i];
  402cb0:	7a0a      	ldrb	r2, [r1, #8]
				if (c == ' ') break;
  402cb2:	2a20      	cmp	r2, #32
  402cb4:	d01a      	beq.n	402cec <get_fileinfo+0xa0>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
  402cb6:	f101 0608 	add.w	r6, r1, #8
  402cba:	f104 0c04 	add.w	ip, r4, #4
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  402cbe:	f008 0810 	and.w	r8, r8, #16
  402cc2:	fa5f f788 	uxtb.w	r7, r8
  402cc6:	e003      	b.n	402cd0 <get_fileinfo+0x84>
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
  402cc8:	f816 2f01 	ldrb.w	r2, [r6, #1]!
				if (c == ' ') break;
  402ccc:	2a20      	cmp	r2, #32
  402cce:	d00e      	beq.n	402cee <get_fileinfo+0xa2>
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  402cd0:	b137      	cbz	r7, 402ce0 <get_fileinfo+0x94>
  402cd2:	f1a2 0441 	sub.w	r4, r2, #65	; 0x41
  402cd6:	b2e4      	uxtb	r4, r4
  402cd8:	2c19      	cmp	r4, #25
  402cda:	bf9c      	itt	ls
  402cdc:	3220      	addls	r2, #32
  402cde:	b2d2      	uxtbls	r2, r2
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
  402ce0:	f803 2b01 	strb.w	r2, [r3], #1
  402ce4:	461c      	mov	r4, r3
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
  402ce6:	4563      	cmp	r3, ip
  402ce8:	d1ee      	bne.n	402cc8 <get_fileinfo+0x7c>
  402cea:	e000      	b.n	402cee <get_fileinfo+0xa2>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
  402cec:	461c      	mov	r4, r3
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  402cee:	7acb      	ldrb	r3, [r1, #11]
  402cf0:	722b      	strb	r3, [r5, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  402cf2:	7fca      	ldrb	r2, [r1, #31]
  402cf4:	7f8b      	ldrb	r3, [r1, #30]
  402cf6:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402cfa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  402cfe:	7f0a      	ldrb	r2, [r1, #28]
  402d00:	4313      	orrs	r3, r2
  402d02:	7f4a      	ldrb	r2, [r1, #29]
  402d04:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402d08:	602b      	str	r3, [r5, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  402d0a:	7e4a      	ldrb	r2, [r1, #25]
  402d0c:	7e0b      	ldrb	r3, [r1, #24]
  402d0e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402d12:	80ab      	strh	r3, [r5, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  402d14:	7dca      	ldrb	r2, [r1, #23]
  402d16:	7d8b      	ldrb	r3, [r1, #22]
  402d18:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402d1c:	80eb      	strh	r3, [r5, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
  402d1e:	f04f 0300 	mov.w	r3, #0
  402d22:	7023      	strb	r3, [r4, #0]

#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
  402d24:	69ae      	ldr	r6, [r5, #24]
  402d26:	b38e      	cbz	r6, 402d8c <get_fileinfo+0x140>
  402d28:	69eb      	ldr	r3, [r5, #28]
  402d2a:	b37b      	cbz	r3, 402d8c <get_fileinfo+0x140>
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d2c:	6903      	ldr	r3, [r0, #16]
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d2e:	f04f 0400 	mov.w	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d32:	b343      	cbz	r3, 402d86 <get_fileinfo+0x13a>
  402d34:	8c02      	ldrh	r2, [r0, #32]
  402d36:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402d3a:	429a      	cmp	r2, r3
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d3c:	bf08      	it	eq
  402d3e:	2400      	moveq	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d40:	d021      	beq.n	402d86 <get_fileinfo+0x13a>
			lfn = dj->lfn;
  402d42:	69c7      	ldr	r7, [r0, #28]
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  402d44:	8838      	ldrh	r0, [r7, #0]
  402d46:	b1b0      	cbz	r0, 402d76 <get_fileinfo+0x12a>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d48:	f04f 0400 	mov.w	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
  402d4c:	46a1      	mov	r9, r4
  402d4e:	f643 08c5 	movw	r8, #14533	; 0x38c5
  402d52:	f2c0 0840 	movt	r8, #64	; 0x40
  402d56:	4649      	mov	r1, r9
  402d58:	47c0      	blx	r8
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
  402d5a:	b178      	cbz	r0, 402d7c <get_fileinfo+0x130>
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  402d5c:	69ea      	ldr	r2, [r5, #28]
  402d5e:	f102 32ff 	add.w	r2, r2, #4294967295
  402d62:	42a2      	cmp	r2, r4
  402d64:	d90d      	bls.n	402d82 <get_fileinfo+0x136>
				tp[i++] = (TCHAR)w;
  402d66:	5530      	strb	r0, [r6, r4]
  402d68:	f104 0401 	add.w	r4, r4, #1
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  402d6c:	f837 0f02 	ldrh.w	r0, [r7, #2]!
  402d70:	2800      	cmp	r0, #0
  402d72:	d1f0      	bne.n	402d56 <get_fileinfo+0x10a>
  402d74:	e007      	b.n	402d86 <get_fileinfo+0x13a>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d76:	f04f 0400 	mov.w	r4, #0
  402d7a:	e004      	b.n	402d86 <get_fileinfo+0x13a>
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
  402d7c:	f04f 0400 	mov.w	r4, #0
  402d80:	e001      	b.n	402d86 <get_fileinfo+0x13a>
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  402d82:	f04f 0400 	mov.w	r4, #0
				tp[i++] = (TCHAR)w;
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
  402d86:	f04f 0300 	mov.w	r3, #0
  402d8a:	5533      	strb	r3, [r6, r4]
  402d8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00402d90 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  402d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d94:	b08b      	sub	sp, #44	; 0x2c
  402d96:	4682      	mov	sl, r0
  402d98:	468b      	mov	fp, r1
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  402d9a:	780b      	ldrb	r3, [r1, #0]
  402d9c:	2b2f      	cmp	r3, #47	; 0x2f
  402d9e:	bf18      	it	ne
  402da0:	2b5c      	cmpne	r3, #92	; 0x5c
		path++;
  402da2:	bf08      	it	eq
  402da4:	f101 0b01 	addeq.w	fp, r1, #1
	dj->sclust = 0;						/* Start from the root dir */
  402da8:	f04f 0300 	mov.w	r3, #0
  402dac:	6083      	str	r3, [r0, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  402dae:	f89b 3000 	ldrb.w	r3, [fp]
  402db2:	2b1f      	cmp	r3, #31
  402db4:	d80c      	bhi.n	402dd0 <follow_path+0x40>
		res = dir_sdi(dj, 0);
  402db6:	f04f 0100 	mov.w	r1, #0
  402dba:	f642 23f1 	movw	r3, #10993	; 0x2af1
  402dbe:	f2c0 0340 	movt	r3, #64	; 0x40
  402dc2:	4798      	blx	r3
  402dc4:	4607      	mov	r7, r0
		dj->dir = 0;
  402dc6:	f04f 0300 	mov.w	r3, #0
  402dca:	f8ca 3014 	str.w	r3, [sl, #20]
  402dce:	e2cb      	b.n	403368 <follow_path+0x5d8>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402dd0:	f643 03c5 	movw	r3, #14533	; 0x38c5
  402dd4:	461e      	mov	r6, r3
  402dd6:	f2c0 0640 	movt	r6, #64	; 0x40
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402dda:	f244 63b0 	movw	r3, #18096	; 0x46b0
  402dde:	f2c0 0340 	movt	r3, #64	; 0x40
  402de2:	9305      	str	r3, [sp, #20]
  402de4:	f103 010c 	add.w	r1, r3, #12
  402de8:	9107      	str	r1, [sp, #28]
  402dea:	46d9      	mov	r9, fp
  402dec:	4683      	mov	fp, r0
  402dee:	46b2      	mov	sl, r6
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402df0:	f899 3000 	ldrb.w	r3, [r9]
  402df4:	2b2f      	cmp	r3, #47	; 0x2f
  402df6:	bf18      	it	ne
  402df8:	2b5c      	cmpne	r3, #92	; 0x5c
  402dfa:	d108      	bne.n	402e0e <follow_path+0x7e>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402dfc:	f109 0301 	add.w	r3, r9, #1
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402e00:	4699      	mov	r9, r3
  402e02:	f813 2b01 	ldrb.w	r2, [r3], #1
  402e06:	2a2f      	cmp	r2, #47	; 0x2f
  402e08:	bf18      	it	ne
  402e0a:	2a5c      	cmpne	r2, #92	; 0x5c
  402e0c:	d0f8      	beq.n	402e00 <follow_path+0x70>
	lfn = dj->lfn;
  402e0e:	f8db 201c 	ldr.w	r2, [fp, #28]
  402e12:	9201      	str	r2, [sp, #4]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e14:	f899 0000 	ldrb.w	r0, [r9]
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402e18:	282f      	cmp	r0, #47	; 0x2f
  402e1a:	bf18      	it	ne
  402e1c:	281f      	cmpne	r0, #31
  402e1e:	d940      	bls.n	402ea2 <follow_path+0x112>
  402e20:	285c      	cmp	r0, #92	; 0x5c
  402e22:	f000 8241 	beq.w	4032a8 <follow_path+0x518>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402e26:	f1a2 0702 	sub.w	r7, r2, #2
  402e2a:	464e      	mov	r6, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e2c:	f04f 0401 	mov.w	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402e30:	46a0      	mov	r8, r4
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402e32:	f244 639c 	movw	r3, #18076	; 0x469c
  402e36:	f2c0 0340 	movt	r3, #64	; 0x40
  402e3a:	9302      	str	r3, [sp, #8]
  402e3c:	f242 5385 	movw	r3, #9605	; 0x2585
  402e40:	461d      	mov	r5, r3
  402e42:	f2c0 0540 	movt	r5, #64	; 0x40
  402e46:	f8cd b00c 	str.w	fp, [sp, #12]
  402e4a:	f8cd 9010 	str.w	r9, [sp, #16]
  402e4e:	f8dd 9008 	ldr.w	r9, [sp, #8]
  402e52:	46ab      	mov	fp, r5
  402e54:	e007      	b.n	402e66 <follow_path+0xd6>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402e56:	2b5c      	cmp	r3, #92	; 0x5c
  402e58:	f000 822b 	beq.w	4032b2 <follow_path+0x522>
		if (di >= _MAX_LFN)				/* Reject too long name */
  402e5c:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  402e60:	f000 8247 	beq.w	4032f2 <follow_path+0x562>
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e64:	4614      	mov	r4, r2
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402e66:	4641      	mov	r1, r8
  402e68:	47d0      	blx	sl
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  402e6a:	4605      	mov	r5, r0
  402e6c:	2800      	cmp	r0, #0
  402e6e:	f000 8240 	beq.w	4032f2 <follow_path+0x562>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402e72:	287f      	cmp	r0, #127	; 0x7f
  402e74:	d805      	bhi.n	402e82 <follow_path+0xf2>
  402e76:	4648      	mov	r0, r9
  402e78:	4629      	mov	r1, r5
  402e7a:	47d8      	blx	fp
  402e7c:	2800      	cmp	r0, #0
  402e7e:	f040 8238 	bne.w	4032f2 <follow_path+0x562>
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  402e82:	f827 5f02 	strh.w	r5, [r7, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e86:	f816 3f01 	ldrb.w	r3, [r6, #1]!
  402e8a:	4618      	mov	r0, r3
  402e8c:	f104 0201 	add.w	r2, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402e90:	2b2f      	cmp	r3, #47	; 0x2f
  402e92:	bf18      	it	ne
  402e94:	2b1f      	cmpne	r3, #31
  402e96:	d8de      	bhi.n	402e56 <follow_path+0xc6>
  402e98:	f8dd b00c 	ldr.w	fp, [sp, #12]
  402e9c:	f8dd 9010 	ldr.w	r9, [sp, #16]
  402ea0:	e003      	b.n	402eaa <follow_path+0x11a>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  402ea2:	f04f 0400 	mov.w	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  402ea6:	f04f 0201 	mov.w	r2, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  402eaa:	4491      	add	r9, r2
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402eac:	281f      	cmp	r0, #31
  402eae:	bf98      	it	ls
  402eb0:	2704      	movls	r7, #4
  402eb2:	d902      	bls.n	402eba <follow_path+0x12a>
  402eb4:	f04f 0700 	mov.w	r7, #0
  402eb8:	e7ff      	b.n	402eba <follow_path+0x12a>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402eba:	2c00      	cmp	r4, #0
  402ebc:	f000 8219 	beq.w	4032f2 <follow_path+0x562>
		w = lfn[di-1];
  402ec0:	f104 33ff 	add.w	r3, r4, #4294967295
  402ec4:	9901      	ldr	r1, [sp, #4]
  402ec6:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
		if (w != ' ' && w != '.') break;
  402eca:	2b2e      	cmp	r3, #46	; 0x2e
  402ecc:	bf18      	it	ne
  402ece:	2b20      	cmpne	r3, #32
  402ed0:	f040 81f5 	bne.w	4032be <follow_path+0x52e>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402ed4:	eb01 0344 	add.w	r3, r1, r4, lsl #1
  402ed8:	e008      	b.n	402eec <follow_path+0x15c>
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
		w = lfn[di-1];
  402eda:	f833 2c04 	ldrh.w	r2, [r3, #-4]
  402ede:	f1a3 0302 	sub.w	r3, r3, #2
		if (w != ' ' && w != '.') break;
  402ee2:	2a2e      	cmp	r2, #46	; 0x2e
  402ee4:	bf18      	it	ne
  402ee6:	2a20      	cmpne	r2, #32
  402ee8:	f040 81e9 	bne.w	4032be <follow_path+0x52e>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402eec:	3c01      	subs	r4, #1
  402eee:	d1f4      	bne.n	402eda <follow_path+0x14a>
  402ef0:	e1ff      	b.n	4032f2 <follow_path+0x562>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402ef2:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402ef6:	428b      	cmp	r3, r1
  402ef8:	d1fb      	bne.n	402ef2 <follow_path+0x162>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  402efa:	9a01      	ldr	r2, [sp, #4]
  402efc:	8813      	ldrh	r3, [r2, #0]
  402efe:	2b20      	cmp	r3, #32
  402f00:	bf18      	it	ne
  402f02:	2b2e      	cmpne	r3, #46	; 0x2e
  402f04:	f040 81e9 	bne.w	4032da <follow_path+0x54a>
  402f08:	4611      	mov	r1, r2
  402f0a:	f04f 0500 	mov.w	r5, #0
  402f0e:	f105 0501 	add.w	r5, r5, #1
  402f12:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  402f16:	2b20      	cmp	r3, #32
  402f18:	bf18      	it	ne
  402f1a:	2b2e      	cmpne	r3, #46	; 0x2e
  402f1c:	d0f7      	beq.n	402f0e <follow_path+0x17e>
	if (si) cf |= NS_LOSS | NS_LFN;
  402f1e:	2d00      	cmp	r5, #0
  402f20:	f000 81dd 	beq.w	4032de <follow_path+0x54e>
  402f24:	f047 0703 	orr.w	r7, r7, #3
  402f28:	e1d9      	b.n	4032de <follow_path+0x54e>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402f2a:	3c01      	subs	r4, #1
  402f2c:	d111      	bne.n	402f52 <follow_path+0x1c2>
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402f2e:	f04f 0308 	mov.w	r3, #8
  402f32:	9302      	str	r3, [sp, #8]
  402f34:	f04f 0800 	mov.w	r8, #0
  402f38:	f8cd 800c 	str.w	r8, [sp, #12]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402f3c:	f244 63a8 	movw	r3, #18088	; 0x46a8
  402f40:	f2c0 0340 	movt	r3, #64	; 0x40
  402f44:	9304      	str	r3, [sp, #16]
  402f46:	f242 5385 	movw	r3, #9605	; 0x2585
  402f4a:	f2c0 0340 	movt	r3, #64	; 0x40
  402f4e:	9306      	str	r3, [sp, #24]
  402f50:	e006      	b.n	402f60 <follow_path+0x1d0>
  402f52:	f1a3 0302 	sub.w	r3, r3, #2

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402f56:	f833 2c02 	ldrh.w	r2, [r3, #-2]
  402f5a:	2a2e      	cmp	r2, #46	; 0x2e
  402f5c:	d1e5      	bne.n	402f2a <follow_path+0x19a>
  402f5e:	e7e6      	b.n	402f2e <follow_path+0x19e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  402f60:	9a01      	ldr	r2, [sp, #4]
  402f62:	f832 6015 	ldrh.w	r6, [r2, r5, lsl #1]
  402f66:	f105 0501 	add.w	r5, r5, #1
		if (!w) break;					/* Break on end of the LFN */
  402f6a:	2e00      	cmp	r6, #0
  402f6c:	d063      	beq.n	403036 <follow_path+0x2a6>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402f6e:	2e20      	cmp	r6, #32
  402f70:	d008      	beq.n	402f84 <follow_path+0x1f4>
  402f72:	1b63      	subs	r3, r4, r5
  402f74:	bf18      	it	ne
  402f76:	2301      	movne	r3, #1
  402f78:	2e2e      	cmp	r6, #46	; 0x2e
  402f7a:	bf14      	ite	ne
  402f7c:	2200      	movne	r2, #0
  402f7e:	f003 0201 	andeq.w	r2, r3, #1
  402f82:	b112      	cbz	r2, 402f8a <follow_path+0x1fa>
			cf |= NS_LOSS | NS_LFN; continue;
  402f84:	f047 0703 	orr.w	r7, r7, #3
  402f88:	e7ea      	b.n	402f60 <follow_path+0x1d0>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  402f8a:	9902      	ldr	r1, [sp, #8]
  402f8c:	42ac      	cmp	r4, r5
  402f8e:	bf18      	it	ne
  402f90:	4588      	cmpne	r8, r1
  402f92:	d316      	bcc.n	402fc2 <follow_path+0x232>
			if (ni == 11) {				/* Long extension */
  402f94:	290b      	cmp	r1, #11
  402f96:	d103      	bne.n	402fa0 <follow_path+0x210>
				cf |= NS_LOSS | NS_LFN; break;
  402f98:	f047 0703 	orr.w	r7, r7, #3
  402f9c:	9903      	ldr	r1, [sp, #12]
  402f9e:	e04d      	b.n	40303c <follow_path+0x2ac>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  402fa0:	b10b      	cbz	r3, 402fa6 <follow_path+0x216>
  402fa2:	f047 0703 	orr.w	r7, r7, #3
			if (si > di) break;			/* No extension */
  402fa6:	42ac      	cmp	r4, r5
  402fa8:	d347      	bcc.n	40303a <follow_path+0x2aa>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  402faa:	9a03      	ldr	r2, [sp, #12]
  402fac:	ea4f 0382 	mov.w	r3, r2, lsl #2
  402fb0:	b2db      	uxtb	r3, r3
  402fb2:	9303      	str	r3, [sp, #12]
  402fb4:	4625      	mov	r5, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402fb6:	f04f 030b 	mov.w	r3, #11
  402fba:	9302      	str	r3, [sp, #8]
  402fbc:	f04f 0808 	mov.w	r8, #8
  402fc0:	e7ce      	b.n	402f60 <follow_path+0x1d0>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  402fc2:	2e7f      	cmp	r6, #127	; 0x7f
  402fc4:	d910      	bls.n	402fe8 <follow_path+0x258>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  402fc6:	4630      	mov	r0, r6
  402fc8:	f04f 0100 	mov.w	r1, #0
  402fcc:	47d0      	blx	sl
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  402fce:	2800      	cmp	r0, #0
  402fd0:	f000 81c7 	beq.w	403362 <follow_path+0x5d2>
  402fd4:	f244 63c0 	movw	r3, #18112	; 0x46c0
  402fd8:	f2c0 0340 	movt	r3, #64	; 0x40
  402fdc:	181b      	adds	r3, r3, r0
  402fde:	f813 6c80 	ldrb.w	r6, [r3, #-128]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  402fe2:	f047 0702 	orr.w	r7, r7, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402fe6:	b126      	cbz	r6, 402ff2 <follow_path+0x262>
  402fe8:	9804      	ldr	r0, [sp, #16]
  402fea:	4631      	mov	r1, r6
  402fec:	9a06      	ldr	r2, [sp, #24]
  402fee:	4790      	blx	r2
  402ff0:	b120      	cbz	r0, 402ffc <follow_path+0x26c>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  402ff2:	f047 0703 	orr.w	r7, r7, #3
  402ff6:	f04f 065f 	mov.w	r6, #95	; 0x5f
  402ffa:	e015      	b.n	403028 <follow_path+0x298>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  402ffc:	f1a6 0341 	sub.w	r3, r6, #65	; 0x41
  403000:	b29b      	uxth	r3, r3
  403002:	2b19      	cmp	r3, #25
  403004:	d804      	bhi.n	403010 <follow_path+0x280>
					b |= 2;
  403006:	9b03      	ldr	r3, [sp, #12]
  403008:	f043 0302 	orr.w	r3, r3, #2
  40300c:	9303      	str	r3, [sp, #12]
  40300e:	e00b      	b.n	403028 <follow_path+0x298>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  403010:	f1a6 0361 	sub.w	r3, r6, #97	; 0x61
  403014:	b29b      	uxth	r3, r3
  403016:	2b19      	cmp	r3, #25
						b |= 1; w -= 0x20;
  403018:	bf9f      	itttt	ls
  40301a:	9903      	ldrls	r1, [sp, #12]
  40301c:	f041 0101 	orrls.w	r1, r1, #1
  403020:	9103      	strls	r1, [sp, #12]
  403022:	3e20      	subls	r6, #32
  403024:	bf98      	it	ls
  403026:	b2b6      	uxthls	r6, r6
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  403028:	f8db 3018 	ldr.w	r3, [fp, #24]
  40302c:	f803 6008 	strb.w	r6, [r3, r8]
  403030:	f108 0801 	add.w	r8, r8, #1
  403034:	e794      	b.n	402f60 <follow_path+0x1d0>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
  403036:	9903      	ldr	r1, [sp, #12]
  403038:	e000      	b.n	40303c <follow_path+0x2ac>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  40303a:	9903      	ldr	r1, [sp, #12]
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  40303c:	f8db 3018 	ldr.w	r3, [fp, #24]
  403040:	781a      	ldrb	r2, [r3, #0]
  403042:	2ae5      	cmp	r2, #229	; 0xe5
  403044:	bf04      	itt	eq
  403046:	2205      	moveq	r2, #5
  403048:	701a      	strbeq	r2, [r3, #0]

	if (ni == 8) b <<= 2;
  40304a:	9a02      	ldr	r2, [sp, #8]
  40304c:	2a08      	cmp	r2, #8
  40304e:	bf02      	ittt	eq
  403050:	0089      	lsleq	r1, r1, #2
  403052:	b2c9      	uxtbeq	r1, r1
  403054:	9103      	streq	r1, [sp, #12]
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  403056:	9903      	ldr	r1, [sp, #12]
  403058:	f001 030c 	and.w	r3, r1, #12
  40305c:	2b0c      	cmp	r3, #12
  40305e:	d003      	beq.n	403068 <follow_path+0x2d8>
  403060:	f001 0203 	and.w	r2, r1, #3
  403064:	2a03      	cmp	r2, #3
  403066:	d101      	bne.n	40306c <follow_path+0x2dc>
		cf |= NS_LFN;
  403068:	f047 0702 	orr.w	r7, r7, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  40306c:	f007 0202 	and.w	r2, r7, #2
  403070:	b2d2      	uxtb	r2, r2
  403072:	b952      	cbnz	r2, 40308a <follow_path+0x2fa>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  403074:	9903      	ldr	r1, [sp, #12]
  403076:	f001 0203 	and.w	r2, r1, #3
  40307a:	2a01      	cmp	r2, #1
  40307c:	bf08      	it	eq
  40307e:	f047 0710 	orreq.w	r7, r7, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  403082:	2b04      	cmp	r3, #4
  403084:	bf08      	it	eq
  403086:	f047 0708 	orreq.w	r7, r7, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  40308a:	f8db 3018 	ldr.w	r3, [fp, #24]
  40308e:	72df      	strb	r7, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  403090:	4658      	mov	r0, fp
  403092:	f04f 0100 	mov.w	r1, #0
  403096:	f642 23f1 	movw	r3, #10993	; 0x2af1
  40309a:	f2c0 0340 	movt	r3, #64	; 0x40
  40309e:	4798      	blx	r3
	if (res != FR_OK) return res;
  4030a0:	4606      	mov	r6, r0
  4030a2:	2800      	cmp	r0, #0
  4030a4:	f040 813a 	bne.w	40331c <follow_path+0x58c>
  4030a8:	f04f 04ff 	mov.w	r4, #255	; 0xff
  4030ac:	4627      	mov	r7, r4

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  4030ae:	f642 13a1 	movw	r3, #10657	; 0x29a1
  4030b2:	4698      	mov	r8, r3
  4030b4:	f2c0 0840 	movt	r8, #64	; 0x40
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  4030b8:	f643 1319 	movw	r3, #14617	; 0x3919
  4030bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4030c0:	9303      	str	r3, [sp, #12]
  4030c2:	f8cd 9004 	str.w	r9, [sp, #4]
  4030c6:	46a1      	mov	r9, r4
  4030c8:	f8cd a008 	str.w	sl, [sp, #8]

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  4030cc:	f8db 0000 	ldr.w	r0, [fp]
  4030d0:	f8db 1010 	ldr.w	r1, [fp, #16]
  4030d4:	47c0      	blx	r8
		if (res != FR_OK) break;
  4030d6:	4606      	mov	r6, r0
  4030d8:	2800      	cmp	r0, #0
  4030da:	f040 8122 	bne.w	403322 <follow_path+0x592>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  4030de:	f8db 4014 	ldr.w	r4, [fp, #20]
		c = dir[DIR_Name];
  4030e2:	7825      	ldrb	r5, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  4030e4:	2d00      	cmp	r5, #0
  4030e6:	f000 8124 	beq.w	403332 <follow_path+0x5a2>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  4030ea:	7ae3      	ldrb	r3, [r4, #11]
  4030ec:	f003 023f 	and.w	r2, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  4030f0:	2de5      	cmp	r5, #229	; 0xe5
  4030f2:	f000 80a6 	beq.w	403242 <follow_path+0x4b2>
  4030f6:	f003 0308 	and.w	r3, r3, #8
  4030fa:	b2db      	uxtb	r3, r3
  4030fc:	b12b      	cbz	r3, 40310a <follow_path+0x37a>
  4030fe:	2a0f      	cmp	r2, #15
			ord = 0xFF;
  403100:	bf18      	it	ne
  403102:	27ff      	movne	r7, #255	; 0xff
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403104:	f040 80a2 	bne.w	40324c <follow_path+0x4bc>
  403108:	e001      	b.n	40310e <follow_path+0x37e>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  40310a:	2a0f      	cmp	r2, #15
  40310c:	d173      	bne.n	4031f6 <follow_path+0x466>
				if (dj->lfn) {
  40310e:	f8db 601c 	ldr.w	r6, [fp, #28]
  403112:	2e00      	cmp	r6, #0
  403114:	f000 809a 	beq.w	40324c <follow_path+0x4bc>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  403118:	f005 0340 	and.w	r3, r5, #64	; 0x40
  40311c:	b2db      	uxtb	r3, r3
  40311e:	b143      	cbz	r3, 403132 <follow_path+0x3a2>
						sum = dir[LDIR_Chksum];
  403120:	f894 900d 	ldrb.w	r9, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
  403124:	f005 05bf 	and.w	r5, r5, #191	; 0xbf
						dj->lfn_idx = dj->index;
  403128:	f8bb 3006 	ldrh.w	r3, [fp, #6]
  40312c:	f8ab 3020 	strh.w	r3, [fp, #32]
  403130:	e004      	b.n	40313c <follow_path+0x3ac>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403132:	42bd      	cmp	r5, r7
  403134:	bf18      	it	ne
  403136:	27ff      	movne	r7, #255	; 0xff
  403138:	f040 8088 	bne.w	40324c <follow_path+0x4bc>
  40313c:	f894 a00d 	ldrb.w	sl, [r4, #13]
  403140:	45ca      	cmp	sl, r9
  403142:	bf18      	it	ne
  403144:	27ff      	movne	r7, #255	; 0xff
  403146:	f040 8081 	bne.w	40324c <follow_path+0x4bc>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  40314a:	7823      	ldrb	r3, [r4, #0]
  40314c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403150:	f103 33ff 	add.w	r3, r3, #4294967295
  403154:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  403158:	eb03 0282 	add.w	r2, r3, r2, lsl #2
  40315c:	9208      	str	r2, [sp, #32]
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  40315e:	9a05      	ldr	r2, [sp, #20]
  403160:	f102 37ff 	add.w	r7, r2, #4294967295
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  403164:	f04f 0901 	mov.w	r9, #1
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  403168:	9509      	str	r5, [sp, #36]	; 0x24
  40316a:	f8cd a010 	str.w	sl, [sp, #16]
  40316e:	464d      	mov	r5, r9
  403170:	f8dd 9020 	ldr.w	r9, [sp, #32]
  403174:	f8cd b018 	str.w	fp, [sp, #24]
  403178:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40317c:	f8dd a01c 	ldr.w	sl, [sp, #28]


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  403180:	f817 3f01 	ldrb.w	r3, [r7, #1]!
  403184:	18e2      	adds	r2, r4, r3
  403186:	7850      	ldrb	r0, [r2, #1]
  403188:	5ce3      	ldrb	r3, [r4, r3]
  40318a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
		if (wc) {	/* Last char has not been processed */
  40318e:	b18d      	cbz	r5, 4031b4 <follow_path+0x424>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403190:	47d8      	blx	fp
  403192:	4605      	mov	r5, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  403194:	f1b9 0ffe 	cmp.w	r9, #254	; 0xfe
  403198:	f200 80ae 	bhi.w	4032f8 <follow_path+0x568>
  40319c:	f836 0019 	ldrh.w	r0, [r6, r9, lsl #1]
  4031a0:	f109 0901 	add.w	r9, r9, #1
  4031a4:	47d8      	blx	fp
  4031a6:	4285      	cmp	r5, r0
  4031a8:	d009      	beq.n	4031be <follow_path+0x42e>
  4031aa:	f8dd a010 	ldr.w	sl, [sp, #16]
  4031ae:	f8dd b018 	ldr.w	fp, [sp, #24]
  4031b2:	e0aa      	b.n	40330a <follow_path+0x57a>
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4031b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4031b8:	4298      	cmp	r0, r3
  4031ba:	f040 80a2 	bne.w	403302 <follow_path+0x572>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  4031be:	4557      	cmp	r7, sl
  4031c0:	d1de      	bne.n	403180 <follow_path+0x3f0>
  4031c2:	f8dd a010 	ldr.w	sl, [sp, #16]
  4031c6:	f8cd 9020 	str.w	r9, [sp, #32]
  4031ca:	46a9      	mov	r9, r5
  4031cc:	9d09      	ldr	r5, [sp, #36]	; 0x24
  4031ce:	f8dd b018 	ldr.w	fp, [sp, #24]

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  4031d2:	7823      	ldrb	r3, [r4, #0]
  4031d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  4031d8:	b2db      	uxtb	r3, r3
  4031da:	2b00      	cmp	r3, #0
  4031dc:	f000 8099 	beq.w	403312 <follow_path+0x582>
  4031e0:	f1b9 0f00 	cmp.w	r9, #0
  4031e4:	f000 8095 	beq.w	403312 <follow_path+0x582>
  4031e8:	9908      	ldr	r1, [sp, #32]
  4031ea:	f836 3011 	ldrh.w	r3, [r6, r1, lsl #1]
  4031ee:	2b00      	cmp	r3, #0
  4031f0:	f000 808f 	beq.w	403312 <follow_path+0x582>
  4031f4:	e089      	b.n	40330a <follow_path+0x57a>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  4031f6:	b947      	cbnz	r7, 40320a <follow_path+0x47a>
  4031f8:	4620      	mov	r0, r4
  4031fa:	f242 53b9 	movw	r3, #9657	; 0x25b9
  4031fe:	f2c0 0340 	movt	r3, #64	; 0x40
  403202:	4798      	blx	r3
  403204:	4548      	cmp	r0, r9
  403206:	f000 8099 	beq.w	40333c <follow_path+0x5ac>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40320a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40320e:	f8ab 3020 	strh.w	r3, [fp, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  403212:	f8db 3018 	ldr.w	r3, [fp, #24]
  403216:	7ada      	ldrb	r2, [r3, #11]
  403218:	f012 0f01 	tst.w	r2, #1
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  40321c:	bf04      	itt	eq
  40321e:	f104 34ff 	addeq.w	r4, r4, #4294967295
  403222:	f103 000b 	addeq.w	r0, r3, #11
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  403226:	d003      	beq.n	403230 <follow_path+0x4a0>
  403228:	e00e      	b.n	403248 <follow_path+0x4b8>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  40322a:	4283      	cmp	r3, r0
  40322c:	f000 808b 	beq.w	403346 <follow_path+0x5b6>
  403230:	f813 2b01 	ldrb.w	r2, [r3], #1
  403234:	f814 1f01 	ldrb.w	r1, [r4, #1]!
  403238:	4291      	cmp	r1, r2
  40323a:	d0f6      	beq.n	40322a <follow_path+0x49a>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40323c:	f04f 07ff 	mov.w	r7, #255	; 0xff
  403240:	e004      	b.n	40324c <follow_path+0x4bc>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  403242:	f04f 07ff 	mov.w	r7, #255	; 0xff
  403246:	e001      	b.n	40324c <follow_path+0x4bc>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  403248:	f04f 07ff 	mov.w	r7, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  40324c:	4658      	mov	r0, fp
  40324e:	f04f 0100 	mov.w	r1, #0
  403252:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  403256:	f2c0 0340 	movt	r3, #64	; 0x40
  40325a:	4798      	blx	r3
	} while (res == FR_OK);
  40325c:	4606      	mov	r6, r0
  40325e:	2800      	cmp	r0, #0
  403260:	f43f af34 	beq.w	4030cc <follow_path+0x33c>
  403264:	4607      	mov	r7, r0
  403266:	46da      	mov	sl, fp
  403268:	e05d      	b.n	403326 <follow_path+0x596>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  40326a:	f003 0304 	and.w	r3, r3, #4
  40326e:	b2df      	uxtb	r7, r3

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
  403270:	2f00      	cmp	r7, #0
  403272:	bf0c      	ite	eq
  403274:	2705      	moveq	r7, #5
  403276:	2704      	movne	r7, #4
  403278:	e076      	b.n	403368 <follow_path+0x5d8>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  40327a:	f8db 3014 	ldr.w	r3, [fp, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  40327e:	7ada      	ldrb	r2, [r3, #11]
  403280:	f002 0210 	and.w	r2, r2, #16
  403284:	b2d2      	uxtb	r2, r2
  403286:	b162      	cbz	r2, 4032a2 <follow_path+0x512>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  403288:	7d59      	ldrb	r1, [r3, #21]
  40328a:	7d1a      	ldrb	r2, [r3, #20]
  40328c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  403290:	7ed9      	ldrb	r1, [r3, #27]
  403292:	7e9b      	ldrb	r3, [r3, #26]
  403294:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  403298:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40329c:	f8cb 3008 	str.w	r3, [fp, #8]
		}
  4032a0:	e5a6      	b.n	402df0 <follow_path+0x60>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  4032a2:	f04f 0705 	mov.w	r7, #5
  4032a6:	e05f      	b.n	403368 <follow_path+0x5d8>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  4032a8:	f04f 0400 	mov.w	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  4032ac:	f04f 0201 	mov.w	r2, #1
  4032b0:	e003      	b.n	4032ba <follow_path+0x52a>
  4032b2:	f8dd b00c 	ldr.w	fp, [sp, #12]
  4032b6:	f8dd 9010 	ldr.w	r9, [sp, #16]
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  4032ba:	4491      	add	r9, r2
  4032bc:	e5fa      	b.n	402eb4 <follow_path+0x124>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  4032be:	9a01      	ldr	r2, [sp, #4]
  4032c0:	eb02 0044 	add.w	r0, r2, r4, lsl #1
  4032c4:	f04f 0300 	mov.w	r3, #0
  4032c8:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  4032cc:	f8db 3018 	ldr.w	r3, [fp, #24]
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  4032d0:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4032d4:	f04f 0220 	mov.w	r2, #32
  4032d8:	e60b      	b.n	402ef2 <follow_path+0x162>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4032da:	f04f 0500 	mov.w	r5, #0
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  4032de:	f104 33ff 	add.w	r3, r4, #4294967295
  4032e2:	9901      	ldr	r1, [sp, #4]
  4032e4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  4032e8:	2b2e      	cmp	r3, #46	; 0x2e
  4032ea:	f43f ae20 	beq.w	402f2e <follow_path+0x19e>
  4032ee:	4603      	mov	r3, r0
  4032f0:	e61b      	b.n	402f2a <follow_path+0x19a>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  4032f2:	f04f 0706 	mov.w	r7, #6
  4032f6:	e037      	b.n	403368 <follow_path+0x5d8>
  4032f8:	f8dd a010 	ldr.w	sl, [sp, #16]
  4032fc:	f8dd b018 	ldr.w	fp, [sp, #24]
  403300:	e003      	b.n	40330a <follow_path+0x57a>
  403302:	f8dd a010 	ldr.w	sl, [sp, #16]
  403306:	f8dd b018 	ldr.w	fp, [sp, #24]
  40330a:	46d1      	mov	r9, sl
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40330c:	f04f 07ff 	mov.w	r7, #255	; 0xff
  403310:	e79c      	b.n	40324c <follow_path+0x4bc>
  403312:	f105 35ff 	add.w	r5, r5, #4294967295
  403316:	b2ef      	uxtb	r7, r5
  403318:	46d1      	mov	r9, sl
  40331a:	e797      	b.n	40324c <follow_path+0x4bc>
  40331c:	4607      	mov	r7, r0
  40331e:	46da      	mov	sl, fp
  403320:	e001      	b.n	403326 <follow_path+0x596>
  403322:	4607      	mov	r7, r0
  403324:	46da      	mov	sl, fp
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  403326:	f8da 3018 	ldr.w	r3, [sl, #24]
  40332a:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  40332c:	2f04      	cmp	r7, #4
  40332e:	d11b      	bne.n	403368 <follow_path+0x5d8>
  403330:	e79b      	b.n	40326a <follow_path+0x4da>
  403332:	46da      	mov	sl, fp
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  403334:	f8db 3018 	ldr.w	r3, [fp, #24]
  403338:	7adb      	ldrb	r3, [r3, #11]
  40333a:	e796      	b.n	40326a <follow_path+0x4da>
  40333c:	f8dd 9004 	ldr.w	r9, [sp, #4]
  403340:	f8dd a008 	ldr.w	sl, [sp, #8]
  403344:	e003      	b.n	40334e <follow_path+0x5be>
  403346:	f8dd 9004 	ldr.w	r9, [sp, #4]
  40334a:	f8dd a008 	ldr.w	sl, [sp, #8]
  40334e:	f8db 3018 	ldr.w	r3, [fp, #24]
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  403352:	7adb      	ldrb	r3, [r3, #11]
  403354:	f003 0304 	and.w	r3, r3, #4
  403358:	b2db      	uxtb	r3, r3
  40335a:	2b00      	cmp	r3, #0
  40335c:	d08d      	beq.n	40327a <follow_path+0x4ea>
  40335e:	4637      	mov	r7, r6
  403360:	e002      	b.n	403368 <follow_path+0x5d8>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  403362:	f047 0702 	orr.w	r7, r7, #2
  403366:	e644      	b.n	402ff2 <follow_path+0x262>
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403368:	4638      	mov	r0, r7
  40336a:	b00b      	add	sp, #44	; 0x2c
  40336c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00403370 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  403370:	b9a0      	cbnz	r0, 40339c <f_mount+0x2c>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  403372:	f240 5300 	movw	r3, #1280	; 0x500
  403376:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40337a:	681b      	ldr	r3, [r3, #0]

	if (rfs) {
  40337c:	b113      	cbz	r3, 403384 <f_mount+0x14>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  40337e:	f04f 0200 	mov.w	r2, #0
  403382:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  403384:	b111      	cbz	r1, 40338c <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
  403386:	f04f 0300 	mov.w	r3, #0
  40338a:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  40338c:	f240 5300 	movw	r3, #1280	; 0x500
  403390:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403394:	6019      	str	r1, [r3, #0]

	return FR_OK;
  403396:	f04f 0000 	mov.w	r0, #0
  40339a:	4770      	bx	lr
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
  40339c:	f04f 000b 	mov.w	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  4033a0:	4770      	bx	lr
  4033a2:	bf00      	nop

004033a4 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4033a4:	b530      	push	{r4, r5, lr}
  4033a6:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
  4033aa:	4604      	mov	r4, r0
  4033ac:	9101      	str	r1, [sp, #4]
  4033ae:	4615      	mov	r5, r2
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  4033b0:	f04f 0200 	mov.w	r2, #0
  4033b4:	6002      	str	r2, [r0, #0]
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
  4033b6:	a801      	add	r0, sp, #4
  4033b8:	a985      	add	r1, sp, #532	; 0x214
  4033ba:	f242 63c5 	movw	r3, #9925	; 0x26c5
  4033be:	f2c0 0340 	movt	r3, #64	; 0x40
  4033c2:	4798      	blx	r3
#endif
	INIT_BUF(dj);
  4033c4:	ab82      	add	r3, sp, #520	; 0x208
  4033c6:	938b      	str	r3, [sp, #556]	; 0x22c
  4033c8:	ab02      	add	r3, sp, #8
  4033ca:	938c      	str	r3, [sp, #560]	; 0x230
	if (res == FR_OK)
  4033cc:	4603      	mov	r3, r0
  4033ce:	2800      	cmp	r0, #0
  4033d0:	d137      	bne.n	403442 <f_open+0x9e>
		res = follow_path(&dj, path);	/* Follow the file path */
  4033d2:	a885      	add	r0, sp, #532	; 0x214
  4033d4:	9901      	ldr	r1, [sp, #4]
  4033d6:	f642 5391 	movw	r3, #11665	; 0x2d91
  4033da:	f2c0 0340 	movt	r3, #64	; 0x40
  4033de:	4798      	blx	r3
	dir = dj.dir;
  4033e0:	998a      	ldr	r1, [sp, #552]	; 0x228
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
  4033e2:	4603      	mov	r3, r0
  4033e4:	bb68      	cbnz	r0, 403442 <f_open+0x9e>
		if (!dir) {						/* Current dir itself */
  4033e6:	b339      	cbz	r1, 403438 <f_open+0x94>
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
  4033e8:	7aca      	ldrb	r2, [r1, #11]
  4033ea:	f002 0210 	and.w	r2, r2, #16
  4033ee:	b2d2      	uxtb	r2, r2
  4033f0:	bb2a      	cbnz	r2, 40343e <f_open+0x9a>

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
  4033f2:	f005 0501 	and.w	r5, r5, #1
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  4033f6:	71a5      	strb	r5, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  4033f8:	7d48      	ldrb	r0, [r1, #21]
  4033fa:	7d0a      	ldrb	r2, [r1, #20]
  4033fc:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  403400:	7ecd      	ldrb	r5, [r1, #27]
  403402:	7e8a      	ldrb	r2, [r1, #26]
  403404:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  403408:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  40340c:	6122      	str	r2, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  40340e:	7fc8      	ldrb	r0, [r1, #31]
  403410:	7f8a      	ldrb	r2, [r1, #30]
  403412:	ea4f 4202 	mov.w	r2, r2, lsl #16
  403416:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  40341a:	7f08      	ldrb	r0, [r1, #28]
  40341c:	4302      	orrs	r2, r0
  40341e:	7f49      	ldrb	r1, [r1, #29]
  403420:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  403424:	60e2      	str	r2, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  403426:	f04f 0200 	mov.w	r2, #0
  40342a:	60a2      	str	r2, [r4, #8]
		fp->dsect = 0;
  40342c:	61a2      	str	r2, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  40342e:	9a85      	ldr	r2, [sp, #532]	; 0x214
  403430:	6022      	str	r2, [r4, #0]
  403432:	88d2      	ldrh	r2, [r2, #6]
  403434:	80a2      	strh	r2, [r4, #4]
  403436:	e004      	b.n	403442 <f_open+0x9e>
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
			res = FR_INVALID_NAME;
  403438:	f04f 0306 	mov.w	r3, #6
  40343c:	e001      	b.n	403442 <f_open+0x9e>
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
				res = FR_NO_FILE;
  40343e:	f04f 0304 	mov.w	r3, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403442:	4618      	mov	r0, r3
  403444:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403448:	bd30      	pop	{r4, r5, pc}
  40344a:	bf00      	nop

0040344c <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  40344c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403450:	b087      	sub	sp, #28
  403452:	4604      	mov	r4, r0
  403454:	460f      	mov	r7, r1
  403456:	4691      	mov	r9, r2
  403458:	461e      	mov	r6, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  40345a:	f04f 0300 	mov.w	r3, #0
  40345e:	6033      	str	r3, [r6, #0]

	res = validate(fp->fs, fp->id);				/* Check validity */
  403460:	6800      	ldr	r0, [r0, #0]
  403462:	88a1      	ldrh	r1, [r4, #4]
  403464:	f242 53dd 	movw	r3, #9693	; 0x25dd
  403468:	f2c0 0340 	movt	r3, #64	; 0x40
  40346c:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  40346e:	4680      	mov	r8, r0
  403470:	2800      	cmp	r0, #0
  403472:	f040 80c4 	bne.w	4035fe <f_read+0x1b2>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403476:	79a3      	ldrb	r3, [r4, #6]
  403478:	f013 0f80 	tst.w	r3, #128	; 0x80
		LEAVE_FF(fp->fs, FR_INT_ERR);
  40347c:	bf18      	it	ne
  40347e:	f04f 0802 	movne.w	r8, #2

	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403482:	f040 80bc 	bne.w	4035fe <f_read+0x1b2>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403486:	f013 0f01 	tst.w	r3, #1
		LEAVE_FF(fp->fs, FR_DENIED);
  40348a:	bf08      	it	eq
  40348c:	f04f 0807 	moveq.w	r8, #7

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403490:	f000 80b5 	beq.w	4035fe <f_read+0x1b2>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403494:	68e5      	ldr	r5, [r4, #12]
  403496:	68a3      	ldr	r3, [r4, #8]
  403498:	1aed      	subs	r5, r5, r3
  40349a:	45a9      	cmp	r9, r5
  40349c:	bf38      	it	cc
  40349e:	464d      	movcc	r5, r9
  4034a0:	9501      	str	r5, [sp, #4]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4034a2:	2d00      	cmp	r5, #0
  4034a4:	f000 80ab 	beq.w	4035fe <f_read+0x1b2>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  4034a8:	f242 539d 	movw	r3, #9629	; 0x259d
  4034ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4034b0:	9303      	str	r3, [sp, #12]
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  4034b2:	f242 5301 	movw	r3, #9473	; 0x2501
  4034b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4034ba:	9304      	str	r3, [sp, #16]
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  4034bc:	f642 13dd 	movw	r3, #10717	; 0x29dd
  4034c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4034c4:	9305      	str	r3, [sp, #20]
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  4034c6:	68a2      	ldr	r2, [r4, #8]
  4034c8:	ea4f 53c2 	mov.w	r3, r2, lsl #23
  4034cc:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  4034d0:	2b00      	cmp	r3, #0
  4034d2:	d16a      	bne.n	4035aa <f_read+0x15e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  4034d4:	6820      	ldr	r0, [r4, #0]
  4034d6:	7883      	ldrb	r3, [r0, #2]
  4034d8:	f103 33ff 	add.w	r3, r3, #4294967295
  4034dc:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  4034e0:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
  4034e4:	d119      	bne.n	40351a <f_read+0xce>
				if (fp->fptr == 0) {			/* On the top of the file? */
  4034e6:	b90a      	cbnz	r2, 4034ec <f_read+0xa0>
					clst = fp->sclust;			/* Follow from the origin */
  4034e8:	6920      	ldr	r0, [r4, #16]
  4034ea:	e002      	b.n	4034f2 <f_read+0xa6>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  4034ec:	6961      	ldr	r1, [r4, #20]
  4034ee:	9d05      	ldr	r5, [sp, #20]
  4034f0:	47a8      	blx	r5
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  4034f2:	2801      	cmp	r0, #1
  4034f4:	d806      	bhi.n	403504 <f_read+0xb8>
  4034f6:	79a3      	ldrb	r3, [r4, #6]
  4034f8:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4034fc:	71a3      	strb	r3, [r4, #6]
  4034fe:	f04f 0802 	mov.w	r8, #2
  403502:	e07c      	b.n	4035fe <f_read+0x1b2>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  403504:	f1b0 3fff 	cmp.w	r0, #4294967295
  403508:	d106      	bne.n	403518 <f_read+0xcc>
  40350a:	79a3      	ldrb	r3, [r4, #6]
  40350c:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403510:	71a3      	strb	r3, [r4, #6]
  403512:	f04f 0801 	mov.w	r8, #1
  403516:	e072      	b.n	4035fe <f_read+0x1b2>
				fp->clust = clst;				/* Update current cluster */
  403518:	6160      	str	r0, [r4, #20]
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  40351a:	f8d4 9000 	ldr.w	r9, [r4]
  40351e:	4648      	mov	r0, r9
  403520:	6961      	ldr	r1, [r4, #20]
  403522:	9d03      	ldr	r5, [sp, #12]
  403524:	47a8      	blx	r5
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403526:	4682      	mov	sl, r0
  403528:	b930      	cbnz	r0, 403538 <f_read+0xec>
  40352a:	79a3      	ldrb	r3, [r4, #6]
  40352c:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403530:	71a3      	strb	r3, [r4, #6]
  403532:	f04f 0802 	mov.w	r8, #2
  403536:	e062      	b.n	4035fe <f_read+0x1b2>
			sect += csect;
  403538:	eb00 0a0b 	add.w	sl, r0, fp
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  40353c:	9d01      	ldr	r5, [sp, #4]
  40353e:	0a6d      	lsrs	r5, r5, #9
  403540:	9502      	str	r5, [sp, #8]
  403542:	d01c      	beq.n	40357e <f_read+0x132>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  403544:	f899 3002 	ldrb.w	r3, [r9, #2]
  403548:	eb05 020b 	add.w	r2, r5, fp
  40354c:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
  40354e:	bf84      	itt	hi
  403550:	ebcb 0303 	rsbhi	r3, fp, r3
  403554:	9302      	strhi	r3, [sp, #8]
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403556:	f899 0001 	ldrb.w	r0, [r9, #1]
  40355a:	4639      	mov	r1, r7
  40355c:	4652      	mov	r2, sl
  40355e:	9d02      	ldr	r5, [sp, #8]
  403560:	b2eb      	uxtb	r3, r5
  403562:	9d04      	ldr	r5, [sp, #16]
  403564:	47a8      	blx	r5
  403566:	b130      	cbz	r0, 403576 <f_read+0x12a>
					ABORT(fp->fs, FR_DISK_ERR);
  403568:	79a3      	ldrb	r3, [r4, #6]
  40356a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40356e:	71a3      	strb	r3, [r4, #6]
  403570:	f04f 0801 	mov.w	r8, #1
  403574:	e043      	b.n	4035fe <f_read+0x1b2>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403576:	9d02      	ldr	r5, [sp, #8]
  403578:	ea4f 2b45 	mov.w	fp, r5, lsl #9
				continue;
  40357c:	e031      	b.n	4035e2 <f_read+0x196>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  40357e:	69a3      	ldr	r3, [r4, #24]
  403580:	4553      	cmp	r3, sl
  403582:	d010      	beq.n	4035a6 <f_read+0x15a>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403584:	f899 0001 	ldrb.w	r0, [r9, #1]
  403588:	f104 011c 	add.w	r1, r4, #28
  40358c:	4652      	mov	r2, sl
  40358e:	f04f 0301 	mov.w	r3, #1
  403592:	9d04      	ldr	r5, [sp, #16]
  403594:	47a8      	blx	r5
  403596:	b130      	cbz	r0, 4035a6 <f_read+0x15a>
					ABORT(fp->fs, FR_DISK_ERR);
  403598:	79a3      	ldrb	r3, [r4, #6]
  40359a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40359e:	71a3      	strb	r3, [r4, #6]
  4035a0:	f04f 0801 	mov.w	r8, #1
  4035a4:	e02b      	b.n	4035fe <f_read+0x1b2>
			}
#endif
			fp->dsect = sect;
  4035a6:	f8c4 a018 	str.w	sl, [r4, #24]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  4035aa:	68a2      	ldr	r2, [r4, #8]
  4035ac:	ea4f 52c2 	mov.w	r2, r2, lsl #23
  4035b0:	ea4f 52d2 	mov.w	r2, r2, lsr #23
  4035b4:	f5c2 7b00 	rsb	fp, r2, #512	; 0x200
  4035b8:	9d01      	ldr	r5, [sp, #4]
  4035ba:	455d      	cmp	r5, fp
  4035bc:	bf38      	it	cc
  4035be:	46ab      	movcc	fp, r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  4035c0:	18a2      	adds	r2, r4, r2
  4035c2:	f102 021c 	add.w	r2, r2, #28
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4035c6:	f1bb 0f00 	cmp.w	fp, #0
  4035ca:	d00a      	beq.n	4035e2 <f_read+0x196>

/*-----------------------------------------------------------------------*/
/* Read File                                                             */
/*-----------------------------------------------------------------------*/

FRESULT f_read (
  4035cc:	f102 32ff 	add.w	r2, r2, #4294967295
  4035d0:	eb07 000b 	add.w	r0, r7, fp
  4035d4:	463b      	mov	r3, r7
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4035d6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  4035da:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4035de:	4283      	cmp	r3, r0
  4035e0:	d1f9      	bne.n	4035d6 <f_read+0x18a>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4035e2:	445f      	add	r7, fp
  4035e4:	68a3      	ldr	r3, [r4, #8]
  4035e6:	445b      	add	r3, fp
  4035e8:	60a3      	str	r3, [r4, #8]
  4035ea:	6833      	ldr	r3, [r6, #0]
  4035ec:	445b      	add	r3, fp
  4035ee:	6033      	str	r3, [r6, #0]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4035f0:	9d01      	ldr	r5, [sp, #4]
  4035f2:	ebb5 050b 	subs.w	r5, r5, fp
  4035f6:	9501      	str	r5, [sp, #4]
  4035f8:	f47f af65 	bne.w	4034c6 <f_read+0x7a>
  4035fc:	e7ff      	b.n	4035fe <f_read+0x1b2>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  4035fe:	4640      	mov	r0, r8
  403600:	b007      	add	sp, #28
  403602:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  403606:	bf00      	nop

00403608 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403608:	b510      	push	{r4, lr}
  40360a:	4604      	mov	r4, r0
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
  40360c:	6800      	ldr	r0, [r0, #0]
  40360e:	88a1      	ldrh	r1, [r4, #4]
  403610:	f242 53dd 	movw	r3, #9693	; 0x25dd
  403614:	f2c0 0340 	movt	r3, #64	; 0x40
  403618:	4798      	blx	r3
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  40361a:	4603      	mov	r3, r0
  40361c:	b910      	cbnz	r0, 403624 <f_close+0x1c>
  40361e:	f04f 0200 	mov.w	r2, #0
  403622:	6022      	str	r2, [r4, #0]
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
  403624:	4618      	mov	r0, r3
  403626:	bd10      	pop	{r4, pc}

00403628 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
  403628:	b510      	push	{r4, lr}
  40362a:	f5ad 7d06 	sub.w	sp, sp, #536	; 0x218
  40362e:	4604      	mov	r4, r0
  403630:	9101      	str	r1, [sp, #4]
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
  403632:	a801      	add	r0, sp, #4
  403634:	4621      	mov	r1, r4
  403636:	f04f 0200 	mov.w	r2, #0
  40363a:	f242 63c5 	movw	r3, #9925	; 0x26c5
  40363e:	f2c0 0340 	movt	r3, #64	; 0x40
  403642:	4798      	blx	r3
	if (res == FR_OK) {
  403644:	4603      	mov	r3, r0
  403646:	2800      	cmp	r0, #0
  403648:	d133      	bne.n	4036b2 <f_opendir+0x8a>
		INIT_BUF(*dj);
  40364a:	ab83      	add	r3, sp, #524	; 0x20c
  40364c:	61a3      	str	r3, [r4, #24]
  40364e:	ab03      	add	r3, sp, #12
  403650:	61e3      	str	r3, [r4, #28]
		res = follow_path(dj, path);			/* Follow the path to the directory */
  403652:	4620      	mov	r0, r4
  403654:	9901      	ldr	r1, [sp, #4]
  403656:	f642 5391 	movw	r3, #11665	; 0x2d91
  40365a:	f2c0 0340 	movt	r3, #64	; 0x40
  40365e:	4798      	blx	r3
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
  403660:	4603      	mov	r3, r0
  403662:	b990      	cbnz	r0, 40368a <f_opendir+0x62>
			if (dj->dir) {						/* It is not the root dir */
  403664:	6963      	ldr	r3, [r4, #20]
  403666:	b1bb      	cbz	r3, 403698 <f_opendir+0x70>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
  403668:	7ada      	ldrb	r2, [r3, #11]
  40366a:	f002 0210 	and.w	r2, r2, #16
  40366e:	b2d2      	uxtb	r2, r2
  403670:	b17a      	cbz	r2, 403692 <f_opendir+0x6a>
					dj->sclust = LD_CLUST(dj->dir);
  403672:	7d59      	ldrb	r1, [r3, #21]
  403674:	7d1a      	ldrb	r2, [r3, #20]
  403676:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  40367a:	7ed9      	ldrb	r1, [r3, #27]
  40367c:	7e9b      	ldrb	r3, [r3, #26]
  40367e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  403682:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403686:	60a3      	str	r3, [r4, #8]
  403688:	e006      	b.n	403698 <f_opendir+0x70>
			if (res == FR_OK) {
				dj->id = dj->fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
  40368a:	2b04      	cmp	r3, #4
  40368c:	bf08      	it	eq
  40368e:	2305      	moveq	r3, #5
  403690:	e00f      	b.n	4036b2 <f_opendir+0x8a>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = LD_CLUST(dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
  403692:	f04f 0305 	mov.w	r3, #5
  403696:	e00c      	b.n	4036b2 <f_opendir+0x8a>
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
  403698:	6823      	ldr	r3, [r4, #0]
  40369a:	88db      	ldrh	r3, [r3, #6]
  40369c:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
  40369e:	4620      	mov	r0, r4
  4036a0:	f04f 0100 	mov.w	r1, #0
  4036a4:	f642 23f1 	movw	r3, #10993	; 0x2af1
  4036a8:	f2c0 0340 	movt	r3, #64	; 0x40
  4036ac:	4798      	blx	r3
  4036ae:	4603      	mov	r3, r0
  4036b0:	e7eb      	b.n	40368a <f_opendir+0x62>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
  4036b2:	4618      	mov	r0, r3
  4036b4:	f50d 7d06 	add.w	sp, sp, #536	; 0x218
  4036b8:	bd10      	pop	{r4, pc}
  4036ba:	bf00      	nop

004036bc <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  4036bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4036c0:	f5ad 7d0b 	sub.w	sp, sp, #556	; 0x22c
  4036c4:	4604      	mov	r4, r0
  4036c6:	468b      	mov	fp, r1
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  4036c8:	6800      	ldr	r0, [r0, #0]
  4036ca:	88a1      	ldrh	r1, [r4, #4]
  4036cc:	f242 53dd 	movw	r3, #9693	; 0x25dd
  4036d0:	f2c0 0340 	movt	r3, #64	; 0x40
  4036d4:	4798      	blx	r3
	if (res == FR_OK) {
  4036d6:	4606      	mov	r6, r0
  4036d8:	2800      	cmp	r0, #0
  4036da:	f040 80ed 	bne.w	4038b8 <f_readdir+0x1fc>
		if (!fno) {
  4036de:	f1bb 0f00 	cmp.w	fp, #0
  4036e2:	d109      	bne.n	4036f8 <f_readdir+0x3c>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
  4036e4:	4620      	mov	r0, r4
  4036e6:	f04f 0100 	mov.w	r1, #0
  4036ea:	f642 23f1 	movw	r3, #10993	; 0x2af1
  4036ee:	f2c0 0340 	movt	r3, #64	; 0x40
  4036f2:	4798      	blx	r3
  4036f4:	4606      	mov	r6, r0
  4036f6:	e0df      	b.n	4038b8 <f_readdir+0x1fc>
		} else {
			INIT_BUF(*dj);
  4036f8:	ab87      	add	r3, sp, #540	; 0x21c
  4036fa:	61a3      	str	r3, [r4, #24]
  4036fc:	ab07      	add	r3, sp, #28
  4036fe:	61e3      	str	r3, [r4, #28]
)
{
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
  403700:	f04f 0aff 	mov.w	sl, #255	; 0xff
  403704:	4657      	mov	r7, sl
#endif

	res = FR_NO_FILE;
  403706:	f04f 0504 	mov.w	r5, #4
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  40370a:	f642 18a1 	movw	r8, #10657	; 0x29a1
  40370e:	f2c0 0840 	movt	r8, #64	; 0x40
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  403712:	46d1      	mov	r9, sl

/*-----------------------------------------------------------------------*/
/* Read Directory Entry in Sequense                                      */
/*-----------------------------------------------------------------------*/

FRESULT f_readdir (
  403714:	f244 63b0 	movw	r3, #18096	; 0x46b0
  403718:	f2c0 0340 	movt	r3, #64	; 0x40
  40371c:	9301      	str	r3, [sp, #4]
  40371e:	f103 000c 	add.w	r0, r3, #12
  403722:	9002      	str	r0, [sp, #8]
  403724:	46ac      	mov	ip, r5
  403726:	4645      	mov	r5, r8
  403728:	e08a      	b.n	403840 <f_readdir+0x184>
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  40372a:	6820      	ldr	r0, [r4, #0]
  40372c:	47a8      	blx	r5
		if (res != FR_OK) break;
  40372e:	4684      	mov	ip, r0
  403730:	2800      	cmp	r0, #0
  403732:	f040 808c 	bne.w	40384e <f_readdir+0x192>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  403736:	6962      	ldr	r2, [r4, #20]
		c = dir[DIR_Name];
  403738:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  40373a:	2b00      	cmp	r3, #0
  40373c:	f000 80b9 	beq.w	4038b2 <f_readdir+0x1f6>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  403740:	7ad1      	ldrb	r1, [r2, #11]
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403742:	2be5      	cmp	r3, #229	; 0xe5
  403744:	bf18      	it	ne
  403746:	2b2e      	cmpne	r3, #46	; 0x2e
  403748:	d06e      	beq.n	403828 <f_readdir+0x16c>
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  40374a:	f001 003f 	and.w	r0, r1, #63	; 0x3f
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40374e:	f001 0108 	and.w	r1, r1, #8
  403752:	b2c9      	uxtb	r1, r1
  403754:	b121      	cbz	r1, 403760 <f_readdir+0xa4>
  403756:	280f      	cmp	r0, #15
			ord = 0xFF;
  403758:	bf18      	it	ne
  40375a:	464f      	movne	r7, r9
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40375c:	d166      	bne.n	40382c <f_readdir+0x170>
  40375e:	e001      	b.n	403764 <f_readdir+0xa8>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  403760:	280f      	cmp	r0, #15
  403762:	d153      	bne.n	40380c <f_readdir+0x150>
				if (c & LLE) {			/* Is it start of LFN sequence? */
  403764:	f003 0140 	and.w	r1, r3, #64	; 0x40
  403768:	b2c9      	uxtb	r1, r1
  40376a:	b131      	cbz	r1, 40377a <f_readdir+0xbe>
					sum = dir[LDIR_Chksum];
  40376c:	f892 a00d 	ldrb.w	sl, [r2, #13]
					c &= ~LLE; ord = c;
  403770:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
					dj->lfn_idx = dj->index;
  403774:	88e1      	ldrh	r1, [r4, #6]
  403776:	8421      	strh	r1, [r4, #32]
  403778:	e003      	b.n	403782 <f_readdir+0xc6>
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40377a:	42bb      	cmp	r3, r7
  40377c:	bf18      	it	ne
  40377e:	464f      	movne	r7, r9
  403780:	d154      	bne.n	40382c <f_readdir+0x170>
  403782:	f892 c00d 	ldrb.w	ip, [r2, #13]
  403786:	45d4      	cmp	ip, sl
  403788:	bf18      	it	ne
  40378a:	464f      	movne	r7, r9
  40378c:	d14e      	bne.n	40382c <f_readdir+0x170>
  40378e:	69e1      	ldr	r1, [r4, #28]
  403790:	9103      	str	r1, [sp, #12]
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  403792:	7811      	ldrb	r1, [r2, #0]
  403794:	f001 013f 	and.w	r1, r1, #63	; 0x3f
  403798:	f101 31ff 	add.w	r1, r1, #4294967295
  40379c:	eb01 0741 	add.w	r7, r1, r1, lsl #1
  4037a0:	eb01 0787 	add.w	r7, r1, r7, lsl #2

/*-----------------------------------------------------------------------*/
/* Read Directory Entry in Sequense                                      */
/*-----------------------------------------------------------------------*/

FRESULT f_readdir (
  4037a4:	9801      	ldr	r0, [sp, #4]
  4037a6:	f100 31ff 	add.w	r1, r0, #4294967295
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
  4037aa:	f04f 0801 	mov.w	r8, #1
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  4037ae:	f64f 7aff 	movw	sl, #65535	; 0xffff
  4037b2:	9305      	str	r3, [sp, #20]
  4037b4:	4623      	mov	r3, r4
  4037b6:	4644      	mov	r4, r8
  4037b8:	9504      	str	r5, [sp, #16]
  4037ba:	9d03      	ldr	r5, [sp, #12]
  4037bc:	f8dd e008 	ldr.w	lr, [sp, #8]
  4037c0:	4698      	mov	r8, r3

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
  4037c2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  4037c6:	18d0      	adds	r0, r2, r3
  4037c8:	7840      	ldrb	r0, [r0, #1]
  4037ca:	5cd3      	ldrb	r3, [r2, r3]
  4037cc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
		if (wc) {	/* Last char has not been processed */
  4037d0:	b13c      	cbz	r4, 4037e2 <f_readdir+0x126>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
  4037d2:	2ffe      	cmp	r7, #254	; 0xfe
  4037d4:	d860      	bhi.n	403898 <f_readdir+0x1dc>
			lfnbuf[i++] = wc = uc;			/* Store it */
  4037d6:	f825 0017 	strh.w	r0, [r5, r7, lsl #1]
  4037da:	f107 0701 	add.w	r7, r7, #1
  4037de:	4604      	mov	r4, r0
  4037e0:	e001      	b.n	4037e6 <f_readdir+0x12a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  4037e2:	4550      	cmp	r0, sl
  4037e4:	d15b      	bne.n	40389e <f_readdir+0x1e2>
		}
	} while (++s < 13);						/* Read all character in the entry */
  4037e6:	4571      	cmp	r1, lr
  4037e8:	d1eb      	bne.n	4037c2 <f_readdir+0x106>
  4037ea:	9b05      	ldr	r3, [sp, #20]
  4037ec:	4644      	mov	r4, r8
  4037ee:	9d04      	ldr	r5, [sp, #16]

	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
  4037f0:	7812      	ldrb	r2, [r2, #0]
  4037f2:	f002 0240 	and.w	r2, r2, #64	; 0x40
  4037f6:	b2d2      	uxtb	r2, r2
  4037f8:	2a00      	cmp	r2, #0
  4037fa:	d055      	beq.n	4038a8 <f_readdir+0x1ec>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
  4037fc:	2ffe      	cmp	r7, #254	; 0xfe
  4037fe:	d850      	bhi.n	4038a2 <f_readdir+0x1e6>
		lfnbuf[i] = 0;
  403800:	f04f 0200 	mov.w	r2, #0
  403804:	9903      	ldr	r1, [sp, #12]
  403806:	f821 2017 	strh.w	r2, [r1, r7, lsl #1]
  40380a:	e04d      	b.n	4038a8 <f_readdir+0x1ec>
  40380c:	4610      	mov	r0, r2
  40380e:	4665      	mov	r5, ip
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
  403810:	b937      	cbnz	r7, 403820 <f_readdir+0x164>
  403812:	f242 53b9 	movw	r3, #9657	; 0x25b9
  403816:	f2c0 0340 	movt	r3, #64	; 0x40
  40381a:	4798      	blx	r3
  40381c:	4550      	cmp	r0, sl
  40381e:	d021      	beq.n	403864 <f_readdir+0x1a8>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
  403820:	f64f 73ff 	movw	r3, #65535	; 0xffff
  403824:	8423      	strh	r3, [r4, #32]
  403826:	e01d      	b.n	403864 <f_readdir+0x1a8>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  403828:	464f      	mov	r7, r9
  40382a:	e7ff      	b.n	40382c <f_readdir+0x170>
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
  40382c:	4620      	mov	r0, r4
  40382e:	f04f 0100 	mov.w	r1, #0
  403832:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  403836:	f2c0 0340 	movt	r3, #64	; 0x40
  40383a:	4798      	blx	r3
		if (res != FR_OK) break;
  40383c:	4684      	mov	ip, r0
  40383e:	b940      	cbnz	r0, 403852 <f_readdir+0x196>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  403840:	6921      	ldr	r1, [r4, #16]
  403842:	2900      	cmp	r1, #0
  403844:	f47f af71 	bne.w	40372a <f_readdir+0x6e>
  403848:	4665      	mov	r5, ip
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  40384a:	b15d      	cbz	r5, 403864 <f_readdir+0x1a8>
  40384c:	e002      	b.n	403854 <f_readdir+0x198>
  40384e:	4605      	mov	r5, r0
  403850:	e000      	b.n	403854 <f_readdir+0x198>
  403852:	4605      	mov	r5, r0
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
  403854:	2d04      	cmp	r5, #4
				dj->sect = 0;
  403856:	bf04      	itt	eq
  403858:	2300      	moveq	r3, #0
  40385a:	6123      	streq	r3, [r4, #16]
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
  40385c:	d003      	beq.n	403866 <f_readdir+0x1aa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  40385e:	f04f 0300 	mov.w	r3, #0
  403862:	6123      	str	r3, [r4, #16]
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
  403864:	b9a5      	cbnz	r5, 403890 <f_readdir+0x1d4>
				get_fileinfo(dj, fno);		/* Get the object information */
  403866:	4620      	mov	r0, r4
  403868:	4659      	mov	r1, fp
  40386a:	f642 434d 	movw	r3, #11341	; 0x2c4d
  40386e:	f2c0 0340 	movt	r3, #64	; 0x40
  403872:	4798      	blx	r3
				res = dir_next(dj, 0);		/* Increment index for next */
  403874:	4620      	mov	r0, r4
  403876:	f04f 0100 	mov.w	r1, #0
  40387a:	f642 33a9 	movw	r3, #11177	; 0x2ba9
  40387e:	f2c0 0340 	movt	r3, #64	; 0x40
  403882:	4798      	blx	r3
				if (res == FR_NO_FILE) {
  403884:	2804      	cmp	r0, #4
					dj->sect = 0;
  403886:	bf04      	itt	eq
  403888:	2300      	moveq	r3, #0
  40388a:	6123      	streq	r3, [r4, #16]
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
				if (res == FR_NO_FILE) {
  40388c:	d014      	beq.n	4038b8 <f_readdir+0x1fc>
  40388e:	e001      	b.n	403894 <f_readdir+0x1d8>
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
  403890:	462e      	mov	r6, r5
  403892:	e011      	b.n	4038b8 <f_readdir+0x1fc>
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
  403894:	4606      	mov	r6, r0
  403896:	e00f      	b.n	4038b8 <f_readdir+0x1fc>
  403898:	4644      	mov	r4, r8
  40389a:	9d04      	ldr	r5, [sp, #16]
  40389c:	e001      	b.n	4038a2 <f_readdir+0x1e6>
  40389e:	4644      	mov	r4, r8
  4038a0:	9d04      	ldr	r5, [sp, #16]
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  4038a2:	46e2      	mov	sl, ip
  4038a4:	464f      	mov	r7, r9
  4038a6:	e7c1      	b.n	40382c <f_readdir+0x170>
  4038a8:	f103 33ff 	add.w	r3, r3, #4294967295
  4038ac:	b2df      	uxtb	r7, r3
  4038ae:	46e2      	mov	sl, ip
  4038b0:	e7bc      	b.n	40382c <f_readdir+0x170>
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  4038b2:	f04f 0504 	mov.w	r5, #4
  4038b6:	e7cd      	b.n	403854 <f_readdir+0x198>
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
  4038b8:	4630      	mov	r0, r6
  4038ba:	f50d 7d0b 	add.w	sp, sp, #556	; 0x22c
  4038be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4038c2:	bf00      	nop

004038c4 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  4038c4:	287f      	cmp	r0, #127	; 0x7f
  4038c6:	d926      	bls.n	403916 <ff_convert+0x52>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  4038c8:	b941      	cbnz	r1, 4038dc <ff_convert+0x18>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
  4038ca:	28c7      	cmp	r0, #199	; 0xc7
  4038cc:	bf1e      	ittt	ne
  4038ce:	f644 1220 	movwne	r2, #18720	; 0x4920
  4038d2:	f2c0 0240 	movtne	r2, #64	; 0x40
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  4038d6:	2301      	movne	r3, #1
				if (src == Tbl[c]) break;
  4038d8:	d10b      	bne.n	4038f2 <ff_convert+0x2e>
  4038da:	e014      	b.n	403906 <ff_convert+0x42>
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4038dc:	28ff      	cmp	r0, #255	; 0xff
  4038de:	d818      	bhi.n	403912 <ff_convert+0x4e>
  4038e0:	f644 1320 	movw	r3, #18720	; 0x4920
  4038e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4038e8:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
  4038ec:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
  4038f0:	4770      	bx	lr

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
  4038f2:	f832 1f02 	ldrh.w	r1, [r2, #2]!
  4038f6:	4281      	cmp	r1, r0
  4038f8:	d007      	beq.n	40390a <ff_convert+0x46>
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  4038fa:	f103 0301 	add.w	r3, r3, #1
  4038fe:	b29b      	uxth	r3, r3
  403900:	2b80      	cmp	r3, #128	; 0x80
  403902:	d1f6      	bne.n	4038f2 <ff_convert+0x2e>
  403904:	e001      	b.n	40390a <ff_convert+0x46>
				if (src == Tbl[c]) break;
  403906:	f04f 0300 	mov.w	r3, #0
			}
			c = (c + 0x80) & 0xFF;
  40390a:	f103 0080 	add.w	r0, r3, #128	; 0x80
  40390e:	b2c0      	uxtb	r0, r0
  403910:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403912:	f04f 0000 	mov.w	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403916:	4770      	bx	lr

00403918 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403918:	2861      	cmp	r0, #97	; 0x61
  40391a:	d00e      	beq.n	40393a <ff_wtoupper+0x22>
  40391c:	f644 2120 	movw	r1, #18976	; 0x4a20
  403920:	f2c0 0140 	movt	r1, #64	; 0x40
  403924:	f04f 0200 	mov.w	r2, #0
  403928:	f102 0201 	add.w	r2, r2, #1
  40392c:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403930:	b15b      	cbz	r3, 40394a <ff_wtoupper+0x32>
  403932:	4283      	cmp	r3, r0
  403934:	d1f8      	bne.n	403928 <ff_wtoupper+0x10>

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403936:	b913      	cbnz	r3, 40393e <ff_wtoupper+0x26>
  403938:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  40393a:	f04f 0200 	mov.w	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  40393e:	f244 7340 	movw	r3, #18240	; 0x4740
  403942:	f2c0 0340 	movt	r3, #64	; 0x40
  403946:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  40394a:	4770      	bx	lr

0040394c <readFile>:
	}	
	dac_value=((0x2000|ch0_value)<<16)|(0x1000|ch1_value);
	return 1;
	}
	
int readFile(uint8_t channel){
  40394c:	b510      	push	{r4, lr}
	if (channel==0){
  40394e:	bb60      	cbnz	r0, 4039aa <readFile+0x5e>
		r = f_read(&sample0, &buffer, sizeof(buffer), &br0);
  403950:	f240 7030 	movw	r0, #1840	; 0x730
  403954:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403958:	f640 4176 	movw	r1, #3190	; 0xc76
  40395c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403960:	f04f 0202 	mov.w	r2, #2
  403964:	f640 637c 	movw	r3, #3708	; 0xe7c
  403968:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40396c:	f243 444d 	movw	r4, #13389	; 0x344d
  403970:	f2c0 0440 	movt	r4, #64	; 0x40
  403974:	47a0      	blx	r4
  403976:	f640 4374 	movw	r3, #3188	; 0xc74
  40397a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40397e:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK){
  403980:	781b      	ldrb	r3, [r3, #0]
  403982:	2b00      	cmp	r3, #0
  403984:	d141      	bne.n	403a0a <readFile+0xbe>
			return 4;
		}
		if (sample0.fptr>sample0.fsize-2){
  403986:	f240 7330 	movw	r3, #1840	; 0x730
  40398a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40398e:	68da      	ldr	r2, [r3, #12]
  403990:	f1a2 0202 	sub.w	r2, r2, #2
  403994:	689b      	ldr	r3, [r3, #8]
  403996:	4293      	cmp	r3, r2
  403998:	d943      	bls.n	403a22 <readFile+0xd6>
			sample0.fptr=0;
  40399a:	f240 7330 	movw	r3, #1840	; 0x730
  40399e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039a2:	f04f 0200 	mov.w	r2, #0
  4039a6:	609a      	str	r2, [r3, #8]
  4039a8:	e03b      	b.n	403a22 <readFile+0xd6>
		}
	}
	if (channel==1){
  4039aa:	2801      	cmp	r0, #1
  4039ac:	d130      	bne.n	403a10 <readFile+0xc4>
		r = f_read(&sample1, &buffer, sizeof(buffer), &br1);
  4039ae:	f640 104c 	movw	r0, #2380	; 0x94c
  4039b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4039b6:	f640 4176 	movw	r1, #3190	; 0xc76
  4039ba:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4039be:	f04f 0202 	mov.w	r2, #2
  4039c2:	f640 4370 	movw	r3, #3184	; 0xc70
  4039c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039ca:	f243 444d 	movw	r4, #13389	; 0x344d
  4039ce:	f2c0 0440 	movt	r4, #64	; 0x40
  4039d2:	47a0      	blx	r4
  4039d4:	f640 4374 	movw	r3, #3188	; 0xc74
  4039d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039dc:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK){
  4039de:	781b      	ldrb	r3, [r3, #0]
  4039e0:	b9cb      	cbnz	r3, 403a16 <readFile+0xca>
			return 4;
		}
		if (sample1.fptr>sample1.fsize-2){
  4039e2:	f640 134c 	movw	r3, #2380	; 0x94c
  4039e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039ea:	68da      	ldr	r2, [r3, #12]
  4039ec:	f1a2 0202 	sub.w	r2, r2, #2
  4039f0:	689b      	ldr	r3, [r3, #8]
  4039f2:	4293      	cmp	r3, r2
  4039f4:	d912      	bls.n	403a1c <readFile+0xd0>
			sample1.fptr=0;
  4039f6:	f640 134c 	movw	r3, #2380	; 0x94c
  4039fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039fe:	f04f 0200 	mov.w	r2, #0
  403a02:	609a      	str	r2, [r3, #8]
		}
	}
	return 1;
  403a04:	f04f 0001 	mov.w	r0, #1
  403a08:	bd10      	pop	{r4, pc}
	
int readFile(uint8_t channel){
	if (channel==0){
		r = f_read(&sample0, &buffer, sizeof(buffer), &br0);
		if (r!=FR_OK){
			return 4;
  403a0a:	f04f 0004 	mov.w	r0, #4
  403a0e:	bd10      	pop	{r4, pc}
		}
		if (sample1.fptr>sample1.fsize-2){
			sample1.fptr=0;
		}
	}
	return 1;
  403a10:	f04f 0001 	mov.w	r0, #1
  403a14:	bd10      	pop	{r4, pc}
		}
	}
	if (channel==1){
		r = f_read(&sample1, &buffer, sizeof(buffer), &br1);
		if (r!=FR_OK){
			return 4;
  403a16:	f04f 0004 	mov.w	r0, #4
  403a1a:	bd10      	pop	{r4, pc}
		}
		if (sample1.fptr>sample1.fsize-2){
			sample1.fptr=0;
		}
	}
	return 1;
  403a1c:	f04f 0001 	mov.w	r0, #1
  403a20:	bd10      	pop	{r4, pc}
  403a22:	f04f 0001 	mov.w	r0, #1
}
  403a26:	bd10      	pop	{r4, pc}

00403a28 <validate_file>:
    }
    return res;
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
  403a28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403a2c:	b08b      	sub	sp, #44	; 0x2c
  403a2e:	4606      	mov	r6, r0
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
	char * pch;
	
	if (fn[0]=='s'){
  403a30:	7803      	ldrb	r3, [r0, #0]
  403a32:	2b73      	cmp	r3, #115	; 0x73
			if (i==1) sample_num=(uint8_t)atoi(pch);
			if (i==2) sample_freq=(uint16_t)atoi(pch);
		}
	}
	else {
		return false;
  403a34:	bf18      	it	ne
  403a36:	2000      	movne	r0, #0
{
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
	char * pch;
	
	if (fn[0]=='s'){
  403a38:	d15d      	bne.n	403af6 <validate_file+0xce>
		char temp[30];
		strcpy(temp,fn);
  403a3a:	a802      	add	r0, sp, #8
  403a3c:	4631      	mov	r1, r6
  403a3e:	f244 3335 	movw	r3, #17205	; 0x4335
  403a42:	f2c0 0340 	movt	r3, #64	; 0x40
  403a46:	4798      	blx	r3
		pch = strtok (temp,"_");
  403a48:	a802      	add	r0, sp, #8
  403a4a:	f644 4100 	movw	r1, #19456	; 0x4c00
  403a4e:	f2c0 0140 	movt	r1, #64	; 0x40
  403a52:	f244 3345 	movw	r3, #17221	; 0x4345
  403a56:	f2c0 0340 	movt	r3, #64	; 0x40
  403a5a:	4798      	blx	r3
		int i=0;
		while (pch != NULL)
  403a5c:	2800      	cmp	r0, #0
  403a5e:	d048      	beq.n	403af2 <validate_file+0xca>
	
	if (fn[0]=='s'){
		char temp[30];
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
  403a60:	f04f 0400 	mov.w	r4, #0
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
  403a64:	9401      	str	r4, [sp, #4]
    return res;
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
	uint8_t sample_num=0;
  403a66:	46a2      	mov	sl, r4
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
		{
			i++;
			pch = strtok (NULL, "_");
  403a68:	f644 4900 	movw	r9, #19456	; 0x4c00
  403a6c:	f2c0 0940 	movt	r9, #64	; 0x40
  403a70:	46a0      	mov	r8, r4
  403a72:	f244 3745 	movw	r7, #17221	; 0x4345
  403a76:	f2c0 0740 	movt	r7, #64	; 0x40
			if (i==1) sample_num=(uint8_t)atoi(pch);
			if (i==2) sample_freq=(uint16_t)atoi(pch);
  403a7a:	f244 2ba9 	movw	fp, #17065	; 0x42a9
  403a7e:	f2c0 0b40 	movt	fp, #64	; 0x40
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
		{
			i++;
  403a82:	f104 0401 	add.w	r4, r4, #1
			pch = strtok (NULL, "_");
  403a86:	4640      	mov	r0, r8
  403a88:	4649      	mov	r1, r9
  403a8a:	47b8      	blx	r7
  403a8c:	4605      	mov	r5, r0
			if (i==1) sample_num=(uint8_t)atoi(pch);
  403a8e:	2c01      	cmp	r4, #1
  403a90:	d103      	bne.n	403a9a <validate_file+0x72>
  403a92:	47d8      	blx	fp
  403a94:	fa5f fa80 	uxtb.w	sl, r0
  403a98:	e004      	b.n	403aa4 <validate_file+0x7c>
			if (i==2) sample_freq=(uint16_t)atoi(pch);
  403a9a:	2c02      	cmp	r4, #2
  403a9c:	d102      	bne.n	403aa4 <validate_file+0x7c>
  403a9e:	47d8      	blx	fp
  403aa0:	b280      	uxth	r0, r0
  403aa2:	9001      	str	r0, [sp, #4]
	if (fn[0]=='s'){
		char temp[30];
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
  403aa4:	2d00      	cmp	r5, #0
  403aa6:	d1ec      	bne.n	403a82 <validate_file+0x5a>
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403aa8:	9b01      	ldr	r3, [sp, #4]
  403aaa:	2b00      	cmp	r3, #0
  403aac:	bf18      	it	ne
  403aae:	f1ba 0f00 	cmpne.w	sl, #0
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403ab2:	bf08      	it	eq
  403ab4:	2000      	moveq	r0, #0
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403ab6:	d01e      	beq.n	403af6 <validate_file+0xce>
  403ab8:	f1ba 0f0f 	cmp.w	sl, #15
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403abc:	bf88      	it	hi
  403abe:	2000      	movhi	r0, #0
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403ac0:	d819      	bhi.n	403af6 <validate_file+0xce>
		strcpy(samples.filenames[sample_num-1],fn);
  403ac2:	f10a 33ff 	add.w	r3, sl, #4294967295
  403ac6:	ebc3 1003 	rsb	r0, r3, r3, lsl #4
  403aca:	f640 447c 	movw	r4, #3196	; 0xc7c
  403ace:	f2c2 0400 	movt	r4, #8192	; 0x2000
  403ad2:	eb04 0040 	add.w	r0, r4, r0, lsl #1
  403ad6:	4631      	mov	r1, r6
  403ad8:	f244 3335 	movw	r3, #17205	; 0x4335
  403adc:	f2c0 0340 	movt	r3, #64	; 0x40
  403ae0:	4798      	blx	r3
		samples.file_frequencies[sample_num-1]=sample_freq;
  403ae2:	eb04 048a 	add.w	r4, r4, sl, lsl #2
  403ae6:	9b01      	ldr	r3, [sp, #4]
  403ae8:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
	}
	else {
		return false;
	}

	return true;
  403aec:	f04f 0001 	mov.w	r0, #1
  403af0:	e001      	b.n	403af6 <validate_file+0xce>
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403af2:	f04f 0000 	mov.w	r0, #0
	}

	return true;
}
  403af6:	b00b      	add	sp, #44	; 0x2c
  403af8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00403afc <scan_files>:
void stopSysTick(){
	SysTick->CTRL  = 0<<SysTick_CTRL_ENABLE_Pos;
}

FRESULT scan_files (char* path)
{
  403afc:	b530      	push	{r4, r5, lr}
  403afe:	b093      	sub	sp, #76	; 0x4c
  403b00:	4601      	mov	r1, r0
 
    char *fn; 
	
#if _USE_LFN
    static char lfn[_MAX_LFN + 1];
    fno.lfname = lfn;
  403b02:	f640 3368 	movw	r3, #2920	; 0xb68
  403b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b0a:	9310      	str	r3, [sp, #64]	; 0x40
    fno.lfsize = sizeof(lfn);
  403b0c:	f44f 7380 	mov.w	r3, #256	; 0x100
  403b10:	9311      	str	r3, [sp, #68]	; 0x44
#endif
    res = f_opendir(&dir, path); //Open dir
  403b12:	a801      	add	r0, sp, #4
  403b14:	f243 6329 	movw	r3, #13865	; 0x3629
  403b18:	f2c0 0340 	movt	r3, #64	; 0x40
  403b1c:	4798      	blx	r3
    if (res == FR_OK)
  403b1e:	4602      	mov	r2, r0
  403b20:	b9f8      	cbnz	r0, 403b62 <scan_files+0x66>
    {
	
        for (;;)
        {
            res = f_readdir(&dir, &fno);  // Read directory
  403b22:	f243 64bd 	movw	r4, #14013	; 0x36bd
  403b26:	f2c0 0440 	movt	r4, #64	; 0x40
			
#else
            fn = fno.fname;
#endif
            if (!(fno.fattrib & AM_DIR)){
				validate_file(fn);
  403b2a:	f643 2529 	movw	r5, #14889	; 0x3a29
  403b2e:	f2c0 0540 	movt	r5, #64	; 0x40
    if (res == FR_OK)
    {
	
        for (;;)
        {
            res = f_readdir(&dir, &fno);  // Read directory
  403b32:	a801      	add	r0, sp, #4
  403b34:	a90a      	add	r1, sp, #40	; 0x28
  403b36:	47a0      	blx	r4
            if (res != FR_OK || fno.fname[0] == 0) 
  403b38:	4602      	mov	r2, r0
  403b3a:	b990      	cbnz	r0, 403b62 <scan_files+0x66>
  403b3c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  403b40:	b17b      	cbz	r3, 403b62 <scan_files+0x66>
               break; // if file end or error
            if (fno.fname[0] == '.')
  403b42:	2b2e      	cmp	r3, #46	; 0x2e
  403b44:	d0f5      	beq.n	403b32 <scan_files+0x36>
               continue; // dot path
#if _USE_LFN
            fn = *fno.lfname ? fno.lfname : fno.fname;
  403b46:	9810      	ldr	r0, [sp, #64]	; 0x40
  403b48:	7803      	ldrb	r3, [r0, #0]
  403b4a:	b90b      	cbnz	r3, 403b50 <scan_files+0x54>
  403b4c:	f10d 0031 	add.w	r0, sp, #49	; 0x31
			
#else
            fn = fno.fname;
#endif
            if (!(fno.fattrib & AM_DIR)){
  403b50:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
  403b54:	f003 0310 	and.w	r3, r3, #16
  403b58:	b2db      	uxtb	r3, r3
  403b5a:	2b00      	cmp	r3, #0
  403b5c:	d1e9      	bne.n	403b32 <scan_files+0x36>
				validate_file(fn);
  403b5e:	47a8      	blx	r5
  403b60:	e7e7      	b.n	403b32 <scan_files+0x36>
            }
        }
    }
    return res;
}
  403b62:	4610      	mov	r0, r2
  403b64:	b013      	add	sp, #76	; 0x4c
  403b66:	bd30      	pop	{r4, r5, pc}

00403b68 <checkSelectedSample>:

	return true;
}

int checkSelectedSample(uint8_t number){
	if (samples.file_frequencies[number]>0 && samples.filenames[number]!=NULL)
  403b68:	f640 437c 	movw	r3, #3196	; 0xc7c
  403b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b70:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  403b74:	f8d0 01c4 	ldr.w	r0, [r0, #452]	; 0x1c4
		return 1;
	return 0;
}
  403b78:	3000      	adds	r0, #0
  403b7a:	bf18      	it	ne
  403b7c:	2001      	movne	r0, #1
  403b7e:	4770      	bx	lr

00403b80 <getSelectedSample>:

uint8_t getSelectedSample(uint8_t channel){
  403b80:	b570      	push	{r4, r5, r6, lr}
	uint8_t value=0;
	if (channel==0){
  403b82:	bb30      	cbnz	r0, 403bd2 <getSelectedSample+0x52>
		value=(gpio_pin_is_high(SS0_GPIO) <<0) |(gpio_pin_is_high(SS1_GPIO) <<1) 
  403b84:	f04f 0013 	mov.w	r0, #19
  403b88:	f641 5405 	movw	r4, #7429	; 0x1d05
  403b8c:	f2c0 0440 	movt	r4, #64	; 0x40
  403b90:	47a0      	blx	r4
  403b92:	1c06      	adds	r6, r0, #0
  403b94:	bf18      	it	ne
  403b96:	2601      	movne	r6, #1
  403b98:	f04f 0016 	mov.w	r0, #22
  403b9c:	47a0      	blx	r4
  403b9e:	2800      	cmp	r0, #0
  403ba0:	bf14      	ite	ne
  403ba2:	2502      	movne	r5, #2
  403ba4:	2500      	moveq	r5, #0
  403ba6:	4335      	orrs	r5, r6
		|(gpio_pin_is_high(SS2_GPIO) <<2) |(gpio_pin_is_high(SS3_GPIO) <<3);
  403ba8:	f04f 0017 	mov.w	r0, #23
  403bac:	47a0      	blx	r4
}

uint8_t getSelectedSample(uint8_t channel){
	uint8_t value=0;
	if (channel==0){
		value=(gpio_pin_is_high(SS0_GPIO) <<0) |(gpio_pin_is_high(SS1_GPIO) <<1) 
  403bae:	2800      	cmp	r0, #0
  403bb0:	bf14      	ite	ne
  403bb2:	2404      	movne	r4, #4
  403bb4:	2400      	moveq	r4, #0
  403bb6:	432c      	orrs	r4, r5
		|(gpio_pin_is_high(SS2_GPIO) <<2) |(gpio_pin_is_high(SS3_GPIO) <<3);
  403bb8:	f04f 0014 	mov.w	r0, #20
  403bbc:	f641 5305 	movw	r3, #7429	; 0x1d05
  403bc0:	f2c0 0340 	movt	r3, #64	; 0x40
  403bc4:	4798      	blx	r3
}

uint8_t getSelectedSample(uint8_t channel){
	uint8_t value=0;
	if (channel==0){
		value=(gpio_pin_is_high(SS0_GPIO) <<0) |(gpio_pin_is_high(SS1_GPIO) <<1) 
  403bc6:	2800      	cmp	r0, #0
  403bc8:	bf14      	ite	ne
  403bca:	2008      	movne	r0, #8
  403bcc:	2000      	moveq	r0, #0
  403bce:	4320      	orrs	r0, r4
  403bd0:	bd70      	pop	{r4, r5, r6, pc}
		|(gpio_pin_is_high(SS2_GPIO) <<2) |(gpio_pin_is_high(SS3_GPIO) <<3);
	}
	else{
		value=(gpio_pin_is_high(SS4_GPIO) <<0) |(gpio_pin_is_high(SS5_GPIO) <<1)
  403bd2:	f04f 000f 	mov.w	r0, #15
  403bd6:	f641 5405 	movw	r4, #7429	; 0x1d05
  403bda:	f2c0 0440 	movt	r4, #64	; 0x40
  403bde:	47a0      	blx	r4
  403be0:	1c06      	adds	r6, r0, #0
  403be2:	bf18      	it	ne
  403be4:	2601      	movne	r6, #1
  403be6:	f04f 000e 	mov.w	r0, #14
  403bea:	47a0      	blx	r4
  403bec:	2800      	cmp	r0, #0
  403bee:	bf14      	ite	ne
  403bf0:	2502      	movne	r5, #2
  403bf2:	2500      	moveq	r5, #0
  403bf4:	4335      	orrs	r5, r6
		|(gpio_pin_is_high(SS6_GPIO) <<2) |(gpio_pin_is_high(SS7_GPIO) <<3);
  403bf6:	f04f 000d 	mov.w	r0, #13
  403bfa:	47a0      	blx	r4
	if (channel==0){
		value=(gpio_pin_is_high(SS0_GPIO) <<0) |(gpio_pin_is_high(SS1_GPIO) <<1) 
		|(gpio_pin_is_high(SS2_GPIO) <<2) |(gpio_pin_is_high(SS3_GPIO) <<3);
	}
	else{
		value=(gpio_pin_is_high(SS4_GPIO) <<0) |(gpio_pin_is_high(SS5_GPIO) <<1)
  403bfc:	2800      	cmp	r0, #0
  403bfe:	bf14      	ite	ne
  403c00:	2404      	movne	r4, #4
  403c02:	2400      	moveq	r4, #0
  403c04:	432c      	orrs	r4, r5
		|(gpio_pin_is_high(SS6_GPIO) <<2) |(gpio_pin_is_high(SS7_GPIO) <<3);
  403c06:	f04f 0018 	mov.w	r0, #24
  403c0a:	f641 5305 	movw	r3, #7429	; 0x1d05
  403c0e:	f2c0 0340 	movt	r3, #64	; 0x40
  403c12:	4798      	blx	r3
	if (channel==0){
		value=(gpio_pin_is_high(SS0_GPIO) <<0) |(gpio_pin_is_high(SS1_GPIO) <<1) 
		|(gpio_pin_is_high(SS2_GPIO) <<2) |(gpio_pin_is_high(SS3_GPIO) <<3);
	}
	else{
		value=(gpio_pin_is_high(SS4_GPIO) <<0) |(gpio_pin_is_high(SS5_GPIO) <<1)
  403c14:	2800      	cmp	r0, #0
  403c16:	bf14      	ite	ne
  403c18:	2008      	movne	r0, #8
  403c1a:	2000      	moveq	r0, #0
  403c1c:	4320      	orrs	r0, r4
		|(gpio_pin_is_high(SS6_GPIO) <<2) |(gpio_pin_is_high(SS7_GPIO) <<3);
	}
	return value;
	
}
  403c1e:	bd70      	pop	{r4, r5, r6, pc}

00403c20 <configure_dacc>:

void configure_dacc(void){
  403c20:	b538      	push	{r3, r4, r5, lr}
	/* Enable clock for DACC */
	pmc_enable_periph_clk(ID_DACC);
  403c22:	f04f 001e 	mov.w	r0, #30
  403c26:	f242 03b1 	movw	r3, #8369	; 0x20b1
  403c2a:	f2c0 0340 	movt	r3, #64	; 0x40
  403c2e:	4798      	blx	r3
	
	/* Reset DACC registers */
	dacc_reset(DACC);
  403c30:	f44f 4440 	mov.w	r4, #49152	; 0xc000
  403c34:	f2c4 0403 	movt	r4, #16387	; 0x4003
  403c38:	4620      	mov	r0, r4
  403c3a:	f241 53c1 	movw	r3, #5569	; 0x15c1
  403c3e:	f2c0 0340 	movt	r3, #64	; 0x40
  403c42:	4798      	blx	r3

	/* Half word transfer mode */
	dacc_set_transfer_mode(DACC, 1);
  403c44:	4620      	mov	r0, r4
  403c46:	f04f 0101 	mov.w	r1, #1
  403c4a:	f241 53c9 	movw	r3, #5577	; 0x15c9
  403c4e:	f2c0 0340 	movt	r3, #64	; 0x40
  403c52:	4798      	blx	r3
	dacc_set_power_save(DACC, 0, 0);
  403c54:	4620      	mov	r0, r4
  403c56:	f04f 0100 	mov.w	r1, #0
  403c5a:	460a      	mov	r2, r1
  403c5c:	f241 53f9 	movw	r3, #5625	; 0x15f9
  403c60:	f2c0 0340 	movt	r3, #64	; 0x40
  403c64:	4798      	blx	r3
	/* Timing:
	 * refresh        - 0x08 (1024*8 dacc clocks)
	 * max speed mode -    0 (disabled)
	 * startup time   - 0x10 (1024 dacc clocks)
	 */
	dacc_set_timing(DACC, 0x08, 0, 0x10);
  403c66:	4620      	mov	r0, r4
  403c68:	f04f 0108 	mov.w	r1, #8
  403c6c:	f04f 0200 	mov.w	r2, #0
  403c70:	f04f 0310 	mov.w	r3, #16
  403c74:	f241 6529 	movw	r5, #5673	; 0x1629
  403c78:	f2c0 0540 	movt	r5, #64	; 0x40
  403c7c:	47a8      	blx	r5

	/* Disable TAG and select output channel DACC_CHANNEL */
	//dacc_set_channel_selection(DACC, 0);
	dacc_enable_flexible_selection(DACC);
  403c7e:	4620      	mov	r0, r4
  403c80:	f241 53ed 	movw	r3, #5613	; 0x15ed
  403c84:	f2c0 0340 	movt	r3, #64	; 0x40
  403c88:	4798      	blx	r3
	
	/* Enable output channel DACC_CHANNEL */
	dacc_enable_channel(DACC, 0);
  403c8a:	4620      	mov	r0, r4
  403c8c:	f04f 0100 	mov.w	r1, #0
  403c90:	f241 655d 	movw	r5, #5725	; 0x165d
  403c94:	f2c0 0540 	movt	r5, #64	; 0x40
  403c98:	47a8      	blx	r5
	dacc_enable_channel(DACC, 1);
  403c9a:	4620      	mov	r0, r4
  403c9c:	f04f 0101 	mov.w	r1, #1
  403ca0:	47a8      	blx	r5
	/* Set up analog current */
	dacc_set_analog_control(DACC, DACC_ANALOG_CONTROL);
  403ca2:	4620      	mov	r0, r4
  403ca4:	f44f 7185 	mov.w	r1, #266	; 0x10a
  403ca8:	f241 6371 	movw	r3, #5745	; 0x1671
  403cac:	f2c0 0340 	movt	r3, #64	; 0x40
  403cb0:	4798      	blx	r3
  403cb2:	bd38      	pop	{r3, r4, r5, pc}

00403cb4 <setData>:
	
}
void setData(uint16_t *ch_value, uint8_t *ch_digitals,uint8_t ch){
  403cb4:	b430      	push	{r4, r5}
	*ch_value=(((buffer>>8)|(buffer<<8)));
  403cb6:	f640 4376 	movw	r3, #3190	; 0xc76
  403cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cbe:	881d      	ldrh	r5, [r3, #0]
  403cc0:	881c      	ldrh	r4, [r3, #0]
  403cc2:	b2a4      	uxth	r4, r4
  403cc4:	f3c5 2307 	ubfx	r3, r5, #8, #8
  403cc8:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  403ccc:	b29b      	uxth	r3, r3
  403cce:	8003      	strh	r3, [r0, #0]
	*ch_digitals|=(*ch_value & 0xF000)>>12-2*ch;
  403cd0:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
  403cd4:	f1c2 0206 	rsb	r2, r2, #6
  403cd8:	ea4f 0242 	mov.w	r2, r2, lsl #1
  403cdc:	fa43 f302 	asr.w	r3, r3, r2
  403ce0:	780a      	ldrb	r2, [r1, #0]
  403ce2:	4313      	orrs	r3, r2
  403ce4:	700b      	strb	r3, [r1, #0]
	*ch_value=(*ch_value & 0x0FFF);
  403ce6:	8803      	ldrh	r3, [r0, #0]
  403ce8:	ea4f 5303 	mov.w	r3, r3, lsl #20
  403cec:	ea4f 5313 	mov.w	r3, r3, lsr #20
  403cf0:	8003      	strh	r3, [r0, #0]
}
  403cf2:	bc30      	pop	{r4, r5}
  403cf4:	4770      	bx	lr
  403cf6:	bf00      	nop

00403cf8 <updateSamples>:
/*
	stop SysTick timer
*/
void stopSysTick(void);

int updateSamples(){
  403cf8:	b538      	push	{r3, r4, r5, lr}
	digitals=0;
  403cfa:	f240 732a 	movw	r3, #1834	; 0x72a
  403cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d02:	f04f 0200 	mov.w	r2, #0
  403d06:	701a      	strb	r2, [r3, #0]
	if (common_file){
  403d08:	f640 436a 	movw	r3, #3178	; 0xc6a
  403d0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d10:	781b      	ldrb	r3, [r3, #0]
  403d12:	b1f3      	cbz	r3, 403d52 <updateSamples+0x5a>
		readFile(0);
  403d14:	4610      	mov	r0, r2
  403d16:	f643 134d 	movw	r3, #14669	; 0x394d
  403d1a:	f2c0 0340 	movt	r3, #64	; 0x40
  403d1e:	4798      	blx	r3
		setData(&ch0_value,&digitals,0);
  403d20:	f240 752a 	movw	r5, #1834	; 0x72a
  403d24:	f2c2 0500 	movt	r5, #8192	; 0x2000
  403d28:	f240 7028 	movw	r0, #1832	; 0x728
  403d2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403d30:	4629      	mov	r1, r5
  403d32:	f04f 0200 	mov.w	r2, #0
  403d36:	f643 44b5 	movw	r4, #15541	; 0x3cb5
  403d3a:	f2c0 0440 	movt	r4, #64	; 0x40
  403d3e:	47a0      	blx	r4
		setData(&ch1_value,&digitals,1);
  403d40:	f240 702c 	movw	r0, #1836	; 0x72c
  403d44:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403d48:	4629      	mov	r1, r5
  403d4a:	f04f 0201 	mov.w	r2, #1
  403d4e:	47a0      	blx	r4
  403d50:	e037      	b.n	403dc2 <updateSamples+0xca>
	}
	else{
		if(ch0){
  403d52:	f640 4368 	movw	r3, #3176	; 0xc68
  403d56:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d5a:	781b      	ldrb	r3, [r3, #0]
  403d5c:	b1ab      	cbz	r3, 403d8a <updateSamples+0x92>
			readFile(0);
  403d5e:	f04f 0000 	mov.w	r0, #0
  403d62:	f643 134d 	movw	r3, #14669	; 0x394d
  403d66:	f2c0 0340 	movt	r3, #64	; 0x40
  403d6a:	4798      	blx	r3
			setData(&ch0_value,&digitals,0);
  403d6c:	f240 7028 	movw	r0, #1832	; 0x728
  403d70:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403d74:	f240 712a 	movw	r1, #1834	; 0x72a
  403d78:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403d7c:	f04f 0200 	mov.w	r2, #0
  403d80:	f643 43b5 	movw	r3, #15541	; 0x3cb5
  403d84:	f2c0 0340 	movt	r3, #64	; 0x40
  403d88:	4798      	blx	r3
		}
		if(ch1){
  403d8a:	f640 4369 	movw	r3, #3177	; 0xc69
  403d8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d92:	781b      	ldrb	r3, [r3, #0]
  403d94:	b1ab      	cbz	r3, 403dc2 <updateSamples+0xca>
			readFile(1);
  403d96:	f04f 0001 	mov.w	r0, #1
  403d9a:	f643 134d 	movw	r3, #14669	; 0x394d
  403d9e:	f2c0 0340 	movt	r3, #64	; 0x40
  403da2:	4798      	blx	r3
			setData(&ch1_value,&digitals,1);
  403da4:	f240 702c 	movw	r0, #1836	; 0x72c
  403da8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403dac:	f240 712a 	movw	r1, #1834	; 0x72a
  403db0:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403db4:	f04f 0201 	mov.w	r2, #1
  403db8:	f643 43b5 	movw	r3, #15541	; 0x3cb5
  403dbc:	f2c0 0340 	movt	r3, #64	; 0x40
  403dc0:	4798      	blx	r3
		}		
	}	
	dac_value=((0x2000|ch0_value)<<16)|(0x1000|ch1_value);
  403dc2:	f640 6380 	movw	r3, #3712	; 0xe80
  403dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dca:	f240 7228 	movw	r2, #1832	; 0x728
  403dce:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403dd2:	8811      	ldrh	r1, [r2, #0]
  403dd4:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  403dd8:	f240 722c 	movw	r2, #1836	; 0x72c
  403ddc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403de0:	8812      	ldrh	r2, [r2, #0]
  403de2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
  403de6:	b292      	uxth	r2, r2
  403de8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  403dec:	601a      	str	r2, [r3, #0]
	return 1;
	}
  403dee:	f04f 0001 	mov.w	r0, #1
  403df2:	bd38      	pop	{r3, r4, r5, pc}

00403df4 <startGenerating>:
		p_pio->PIO_CODR |= (~(digitals)<<D3_GPIO);
		p_pio->PIO_SODR |= (digitals<<D3_GPIO);
		updateSamples();
	}
}
int startGenerating(){
  403df4:	b538      	push	{r3, r4, r5, lr}
	if (ch0_ss>0 && checkSelectedSample(ch0_ss-1)) ch0=true;
  403df6:	f640 436b 	movw	r3, #3179	; 0xc6b
  403dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dfe:	781c      	ldrb	r4, [r3, #0]
  403e00:	b17c      	cbz	r4, 403e22 <startGenerating+0x2e>
  403e02:	f104 30ff 	add.w	r0, r4, #4294967295
  403e06:	b2c0      	uxtb	r0, r0
  403e08:	f643 3369 	movw	r3, #15209	; 0x3b69
  403e0c:	f2c0 0340 	movt	r3, #64	; 0x40
  403e10:	4798      	blx	r3
  403e12:	b130      	cbz	r0, 403e22 <startGenerating+0x2e>
  403e14:	f640 4368 	movw	r3, #3176	; 0xc68
  403e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e1c:	f04f 0201 	mov.w	r2, #1
  403e20:	701a      	strb	r2, [r3, #0]
	if (ch1_ss>0 && checkSelectedSample(ch1_ss-1)) ch1=true;
  403e22:	f640 436c 	movw	r3, #3180	; 0xc6c
  403e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e2a:	781d      	ldrb	r5, [r3, #0]
  403e2c:	b17d      	cbz	r5, 403e4e <startGenerating+0x5a>
  403e2e:	f105 30ff 	add.w	r0, r5, #4294967295
  403e32:	b2c0      	uxtb	r0, r0
  403e34:	f643 3369 	movw	r3, #15209	; 0x3b69
  403e38:	f2c0 0340 	movt	r3, #64	; 0x40
  403e3c:	4798      	blx	r3
  403e3e:	b130      	cbz	r0, 403e4e <startGenerating+0x5a>
  403e40:	f640 4369 	movw	r3, #3177	; 0xc69
  403e44:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e48:	f04f 0201 	mov.w	r2, #1
  403e4c:	701a      	strb	r2, [r3, #0]
	
	if (!(ch0 || ch1)) return 0;
  403e4e:	f640 4368 	movw	r3, #3176	; 0xc68
  403e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e56:	781b      	ldrb	r3, [r3, #0]
  403e58:	b953      	cbnz	r3, 403e70 <startGenerating+0x7c>
  403e5a:	f640 4369 	movw	r3, #3177	; 0xc69
  403e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e62:	781b      	ldrb	r3, [r3, #0]
  403e64:	2b00      	cmp	r3, #0
  403e66:	f040 8087 	bne.w	403f78 <startGenerating+0x184>
  403e6a:	f04f 0000 	mov.w	r0, #0
  403e6e:	bd38      	pop	{r3, r4, r5, pc}
	if (ch0 && ch1){
  403e70:	f640 4369 	movw	r3, #3177	; 0xc69
  403e74:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e78:	781b      	ldrb	r3, [r3, #0]
  403e7a:	2b00      	cmp	r3, #0
  403e7c:	d047      	beq.n	403f0e <startGenerating+0x11a>
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
  403e7e:	f640 437c 	movw	r3, #3196	; 0xc7c
  403e82:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e86:	eb03 0284 	add.w	r2, r3, r4, lsl #2
  403e8a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  403e8e:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403e92:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
  403e96:	429a      	cmp	r2, r3
  403e98:	f040 80ab 	bne.w	403ff2 <startGenerating+0x1fe>
  403e9c:	e0b5      	b.n	40400a <startGenerating+0x216>
			return 2;
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
		r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
  403e9e:	f104 34ff 	add.w	r4, r4, #4294967295
  403ea2:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
  403ea6:	f640 417c 	movw	r1, #3196	; 0xc7c
  403eaa:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403eae:	f240 7030 	movw	r0, #1840	; 0x730
  403eb2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403eb6:	eb01 0144 	add.w	r1, r1, r4, lsl #1
  403eba:	f04f 0201 	mov.w	r2, #1
  403ebe:	f243 33a5 	movw	r3, #13221	; 0x33a5
  403ec2:	f2c0 0340 	movt	r3, #64	; 0x40
  403ec6:	4798      	blx	r3
  403ec8:	f640 4374 	movw	r3, #3188	; 0xc74
  403ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ed0:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK) return 3;
  403ed2:	781b      	ldrb	r3, [r3, #0]
  403ed4:	2b00      	cmp	r3, #0
  403ed6:	f040 808f 	bne.w	403ff8 <startGenerating+0x204>
		current_freq=samples.file_frequencies[ch0_ss-1];
  403eda:	f640 4378 	movw	r3, #3192	; 0xc78
  403ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ee2:	f640 427c 	movw	r2, #3196	; 0xc7c
  403ee6:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403eea:	f640 416b 	movw	r1, #3179	; 0xc6b
  403eee:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403ef2:	7809      	ldrb	r1, [r1, #0]
  403ef4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403ef8:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403efc:	601a      	str	r2, [r3, #0]
		common_file=true;
  403efe:	f640 436a 	movw	r3, #3178	; 0xc6a
  403f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f06:	f04f 0201 	mov.w	r2, #1
  403f0a:	701a      	strb	r2, [r3, #0]
  403f0c:	e067      	b.n	403fde <startGenerating+0x1ea>
	}
	else{
		if (ch0){
			r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
  403f0e:	f104 34ff 	add.w	r4, r4, #4294967295
  403f12:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
  403f16:	f640 417c 	movw	r1, #3196	; 0xc7c
  403f1a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403f1e:	f240 7030 	movw	r0, #1840	; 0x730
  403f22:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403f26:	eb01 0144 	add.w	r1, r1, r4, lsl #1
  403f2a:	f04f 0201 	mov.w	r2, #1
  403f2e:	f243 33a5 	movw	r3, #13221	; 0x33a5
  403f32:	f2c0 0340 	movt	r3, #64	; 0x40
  403f36:	4798      	blx	r3
  403f38:	f640 4374 	movw	r3, #3188	; 0xc74
  403f3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f40:	7018      	strb	r0, [r3, #0]
			if (r!=FR_OK) return 3;
  403f42:	781b      	ldrb	r3, [r3, #0]
  403f44:	2b00      	cmp	r3, #0
  403f46:	d15a      	bne.n	403ffe <startGenerating+0x20a>
			current_freq=samples.file_frequencies[ch0_ss-1];
  403f48:	f640 4378 	movw	r3, #3192	; 0xc78
  403f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f50:	f640 427c 	movw	r2, #3196	; 0xc7c
  403f54:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403f58:	f640 416b 	movw	r1, #3179	; 0xc6b
  403f5c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403f60:	7809      	ldrb	r1, [r1, #0]
  403f62:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403f66:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403f6a:	601a      	str	r2, [r3, #0]
		}
		
		if (ch1){
  403f6c:	f640 4369 	movw	r3, #3177	; 0xc69
  403f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f74:	781b      	ldrb	r3, [r3, #0]
  403f76:	b393      	cbz	r3, 403fde <startGenerating+0x1ea>
			r=f_open(&sample1,samples.filenames[ch1_ss-1],FA_OPEN_EXISTING | FA_READ);
  403f78:	f640 436c 	movw	r3, #3180	; 0xc6c
  403f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f80:	7819      	ldrb	r1, [r3, #0]
  403f82:	f101 31ff 	add.w	r1, r1, #4294967295
  403f86:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
  403f8a:	f640 437c 	movw	r3, #3196	; 0xc7c
  403f8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f92:	f640 104c 	movw	r0, #2380	; 0x94c
  403f96:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403f9a:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  403f9e:	f04f 0201 	mov.w	r2, #1
  403fa2:	f243 33a5 	movw	r3, #13221	; 0x33a5
  403fa6:	f2c0 0340 	movt	r3, #64	; 0x40
  403faa:	4798      	blx	r3
  403fac:	f640 4374 	movw	r3, #3188	; 0xc74
  403fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403fb4:	7018      	strb	r0, [r3, #0]
			if (r!=FR_OK) return 3;
  403fb6:	781b      	ldrb	r3, [r3, #0]
  403fb8:	bb23      	cbnz	r3, 404004 <startGenerating+0x210>
			current_freq=samples.file_frequencies[ch1_ss-1];
  403fba:	f640 4378 	movw	r3, #3192	; 0xc78
  403fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403fc2:	f640 427c 	movw	r2, #3196	; 0xc7c
  403fc6:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403fca:	f640 416c 	movw	r1, #3180	; 0xc6c
  403fce:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403fd2:	7809      	ldrb	r1, [r1, #0]
  403fd4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403fd8:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403fdc:	601a      	str	r2, [r3, #0]
		}		
	}		
	if (!updateSamples()) return 4;
  403fde:	f643 43f9 	movw	r3, #15609	; 0x3cf9
  403fe2:	f2c0 0340 	movt	r3, #64	; 0x40
  403fe6:	4798      	blx	r3
  403fe8:	2800      	cmp	r0, #0
  403fea:	bf14      	ite	ne
  403fec:	2001      	movne	r0, #1
  403fee:	2004      	moveq	r0, #4
  403ff0:	bd38      	pop	{r3, r4, r5, pc}
	if (ch1_ss>0 && checkSelectedSample(ch1_ss-1)) ch1=true;
	
	if (!(ch0 || ch1)) return 0;
	if (ch0 && ch1){
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
			return 2;
  403ff2:	f04f 0002 	mov.w	r0, #2
  403ff6:	bd38      	pop	{r3, r4, r5, pc}
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
		r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
		if (r!=FR_OK) return 3;
  403ff8:	f04f 0003 	mov.w	r0, #3
  403ffc:	bd38      	pop	{r3, r4, r5, pc}
		common_file=true;
	}
	else{
		if (ch0){
			r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
			if (r!=FR_OK) return 3;
  403ffe:	f04f 0003 	mov.w	r0, #3
  404002:	bd38      	pop	{r3, r4, r5, pc}
			current_freq=samples.file_frequencies[ch0_ss-1];
		}
		
		if (ch1){
			r=f_open(&sample1,samples.filenames[ch1_ss-1],FA_OPEN_EXISTING | FA_READ);
			if (r!=FR_OK) return 3;
  404004:	f04f 0003 	mov.w	r0, #3
  404008:	bd38      	pop	{r3, r4, r5, pc}
	if (ch0 && ch1){
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
			return 2;
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
  40400a:	42ac      	cmp	r4, r5
  40400c:	f47f af7f 	bne.w	403f0e <startGenerating+0x11a>
  404010:	e745      	b.n	403e9e <startGenerating+0xaa>
  404012:	bf00      	nop

00404014 <main>:
	}		
	if (!updateSamples()) return 4;
	return 1;
}

int main(void){
  404014:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	Ctrl_status status;
	board_init();
  404018:	f240 1381 	movw	r3, #385	; 0x181
  40401c:	f2c0 0340 	movt	r3, #64	; 0x40
  404020:	4798      	blx	r3
	
	sysclk_init();
  404022:	f241 43ad 	movw	r3, #5293	; 0x14ad
  404026:	f2c0 0340 	movt	r3, #64	; 0x40
  40402a:	4798      	blx	r3
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40402c:	f04f 000b 	mov.w	r0, #11
  404030:	f242 03b1 	movw	r3, #8369	; 0x20b1
  404034:	f2c0 0340 	movt	r3, #64	; 0x40
  404038:	4798      	blx	r3
	
    sysclk_enable_peripheral_clock(ID_PIOA);
	configure_dacc();
  40403a:	f643 4321 	movw	r3, #15393	; 0x3c21
  40403e:	f2c0 0340 	movt	r3, #64	; 0x40
  404042:	4798      	blx	r3
	sd_mmc_init();
  404044:	f240 6325 	movw	r3, #1573	; 0x625
  404048:	f2c0 0340 	movt	r3, #64	; 0x40
  40404c:	4798      	blx	r3
	card_init:
	gpio_set_pin_low(LED2_GPIO);
  40404e:	f641 5845 	movw	r8, #7493	; 0x1d45
  404052:	f2c0 0840 	movt	r8, #64	; 0x40
	while (CTRL_GOOD != sd_mmc_test_unit_ready(0));
  404056:	f240 256d 	movw	r5, #621	; 0x26d
  40405a:	f2c0 0540 	movt	r5, #64	; 0x40
	r=sd_mmc_check(0);
  40405e:	f240 6751 	movw	r7, #1617	; 0x651
  404062:	f2c0 0740 	movt	r7, #64	; 0x40
  404066:	f640 4674 	movw	r6, #3188	; 0xc74
  40406a:	f2c2 0600 	movt	r6, #8192	; 0x2000
		else{
			if (current_freq>MAX_FREQ_1FILES)
				current_freq=MAX_FREQ_1FILES;
		}						
			
		SysTick_Config(sysclk_get_cpu_hz()/current_freq);
  40406e:	f44f 6960 	mov.w	r9, #3584	; 0xe00
  404072:	f2c0 7927 	movt	r9, #1831	; 0x727
	
    sysclk_enable_peripheral_clock(ID_PIOA);
	configure_dacc();
	sd_mmc_init();
	card_init:
	gpio_set_pin_low(LED2_GPIO);
  404076:	f04f 0005 	mov.w	r0, #5
  40407a:	47c0      	blx	r8
	while (CTRL_GOOD != sd_mmc_test_unit_ready(0));
  40407c:	f04f 0400 	mov.w	r4, #0
  404080:	4620      	mov	r0, r4
  404082:	47a8      	blx	r5
  404084:	2800      	cmp	r0, #0
  404086:	d1fb      	bne.n	404080 <main+0x6c>
	r=sd_mmc_check(0);
  404088:	47b8      	blx	r7
  40408a:	7030      	strb	r0, [r6, #0]
	r = f_mount(0, &fs);
  40408c:	f04f 0000 	mov.w	r0, #0
  404090:	f240 5104 	movw	r1, #1284	; 0x504
  404094:	f2c2 0100 	movt	r1, #8192	; 0x2000
  404098:	f243 3371 	movw	r3, #13169	; 0x3371
  40409c:	f2c0 0340 	movt	r3, #64	; 0x40
  4040a0:	4798      	blx	r3
  4040a2:	7030      	strb	r0, [r6, #0]
	if (FR_OK != r) {
  4040a4:	7833      	ldrb	r3, [r6, #0]
  4040a6:	2b00      	cmp	r3, #0
  4040a8:	d1e5      	bne.n	404076 <main+0x62>
			
			goto card_init;
		}
		
	r=scan_files("/");	
  4040aa:	f644 4004 	movw	r0, #19460	; 0x4c04
  4040ae:	f2c0 0040 	movt	r0, #64	; 0x40
  4040b2:	f643 23fd 	movw	r3, #15101	; 0x3afd
  4040b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4040ba:	4798      	blx	r3
  4040bc:	7030      	strb	r0, [r6, #0]
	gpio_set_pin_high(LED1_GPIO);
  4040be:	f04f 0006 	mov.w	r0, #6
  4040c2:	f641 5325 	movw	r3, #7461	; 0x1d25
  4040c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4040ca:	4798      	blx	r3
		
	while (gpio_pin_is_low(BUT0_GPIO));
  4040cc:	f04f 0a10 	mov.w	sl, #16
  4040d0:	f641 5405 	movw	r4, #7429	; 0x1d05
  4040d4:	f2c0 0440 	movt	r4, #64	; 0x40
  4040d8:	4650      	mov	r0, sl
  4040da:	47a0      	blx	r4
  4040dc:	2800      	cmp	r0, #0
  4040de:	d0fb      	beq.n	4040d8 <main+0xc4>
	
	ch0_ss = getSelectedSample(0);
  4040e0:	f04f 0000 	mov.w	r0, #0
  4040e4:	f643 3481 	movw	r4, #15233	; 0x3b81
  4040e8:	f2c0 0440 	movt	r4, #64	; 0x40
  4040ec:	47a0      	blx	r4
  4040ee:	f640 436b 	movw	r3, #3179	; 0xc6b
  4040f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4040f6:	7018      	strb	r0, [r3, #0]
	ch1_ss = getSelectedSample(1);
  4040f8:	f04f 0001 	mov.w	r0, #1
  4040fc:	47a0      	blx	r4
  4040fe:	f640 436c 	movw	r3, #3180	; 0xc6c
  404102:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404106:	7018      	strb	r0, [r3, #0]
	int state;
	
	start:
	state=startGenerating();
  404108:	f643 53f5 	movw	r3, #15861	; 0x3df5
  40410c:	f2c0 0340 	movt	r3, #64	; 0x40
  404110:	4798      	blx	r3
	if (state==1){
  404112:	2801      	cmp	r0, #1
  404114:	d160      	bne.n	4041d8 <main+0x1c4>
		
		gpio_set_pin_high(LED2_GPIO);
  404116:	f04f 0005 	mov.w	r0, #5
  40411a:	f641 5325 	movw	r3, #7461	; 0x1d25
  40411e:	f2c0 0340 	movt	r3, #64	; 0x40
  404122:	4798      	blx	r3
	
		if (ch0 && ch1 && !common_file){
  404124:	f640 4368 	movw	r3, #3176	; 0xc68
  404128:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40412c:	781b      	ldrb	r3, [r3, #0]
  40412e:	b1e3      	cbz	r3, 40416a <main+0x156>
  404130:	f640 4369 	movw	r3, #3177	; 0xc69
  404134:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404138:	781b      	ldrb	r3, [r3, #0]
  40413a:	b1b3      	cbz	r3, 40416a <main+0x156>
  40413c:	f640 436a 	movw	r3, #3178	; 0xc6a
  404140:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404144:	781b      	ldrb	r3, [r3, #0]
  404146:	b983      	cbnz	r3, 40416a <main+0x156>
			if (current_freq>MAX_FREQ_2FILES)
  404148:	f640 4378 	movw	r3, #3192	; 0xc78
  40414c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404150:	681a      	ldr	r2, [r3, #0]
  404152:	f24c 3350 	movw	r3, #50000	; 0xc350
  404156:	429a      	cmp	r2, r3
  404158:	d91c      	bls.n	404194 <main+0x180>
				current_freq=MAX_FREQ_2FILES;
  40415a:	f640 4378 	movw	r3, #3192	; 0xc78
  40415e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404162:	f24c 3250 	movw	r2, #50000	; 0xc350
  404166:	601a      	str	r2, [r3, #0]
  404168:	e05a      	b.n	404220 <main+0x20c>
		}
		else{
			if (current_freq>MAX_FREQ_1FILES)
  40416a:	f640 4378 	movw	r3, #3192	; 0xc78
  40416e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404172:	f645 7290 	movw	r2, #24464	; 0x5f90
  404176:	f2c0 0201 	movt	r2, #1
  40417a:	681b      	ldr	r3, [r3, #0]
  40417c:	4293      	cmp	r3, r2
  40417e:	d909      	bls.n	404194 <main+0x180>
				current_freq=MAX_FREQ_1FILES;
  404180:	f640 4378 	movw	r3, #3192	; 0xc78
  404184:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404188:	f645 7290 	movw	r2, #24464	; 0x5f90
  40418c:	f2c0 0201 	movt	r2, #1
  404190:	601a      	str	r2, [r3, #0]
  404192:	e045      	b.n	404220 <main+0x20c>
		}						
			
		SysTick_Config(sysclk_get_cpu_hz()/current_freq);
  404194:	f640 4378 	movw	r3, #3192	; 0xc78
  404198:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40419c:	681b      	ldr	r3, [r3, #0]
  40419e:	fbb9 f3f3 	udiv	r3, r9, r3
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
  4041a2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  4041a6:	d21a      	bcs.n	4041de <main+0x1ca>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  4041a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  4041ac:	f103 32ff 	add.w	r2, r3, #4294967295
  4041b0:	f24e 0310 	movw	r3, #57360	; 0xe010
  4041b4:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4041b8:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4041ba:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4041be:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4041c2:	f04f 01f0 	mov.w	r1, #240	; 0xf0
  4041c6:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  4041ca:	f04f 0200 	mov.w	r2, #0
  4041ce:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  4041d0:	f04f 0207 	mov.w	r2, #7
  4041d4:	601a      	str	r2, [r3, #0]
  4041d6:	e002      	b.n	4041de <main+0x1ca>
	}		
	else if(state>=3){
  4041d8:	2802      	cmp	r0, #2
  4041da:	dc0a      	bgt.n	4041f2 <main+0x1de>
  4041dc:	e74b      	b.n	404076 <main+0x62>
	}
	else {
		goto card_init;
	}
	
	while (gpio_pin_is_high(BUT0_GPIO));
  4041de:	f04f 0a10 	mov.w	sl, #16
  4041e2:	f641 5405 	movw	r4, #7429	; 0x1d05
  4041e6:	f2c0 0440 	movt	r4, #64	; 0x40
  4041ea:	4650      	mov	r0, sl
  4041ec:	47a0      	blx	r4
  4041ee:	2800      	cmp	r0, #0
  4041f0:	d1fb      	bne.n	4041ea <main+0x1d6>
	
	close_files:
	f_close(&sample0);
  4041f2:	f240 7030 	movw	r0, #1840	; 0x730
  4041f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4041fa:	f243 6409 	movw	r4, #13833	; 0x3609
  4041fe:	f2c0 0440 	movt	r4, #64	; 0x40
  404202:	47a0      	blx	r4
	f_close(&sample1);
  404204:	f640 104c 	movw	r0, #2380	; 0x94c
  404208:	f2c2 0000 	movt	r0, #8192	; 0x2000
  40420c:	47a0      	blx	r4
	
	f_mount(0, NULL);
  40420e:	f04f 0000 	mov.w	r0, #0
  404212:	4601      	mov	r1, r0
  404214:	f243 3371 	movw	r3, #13169	; 0x3371
  404218:	f2c0 0340 	movt	r3, #64	; 0x40
  40421c:	4798      	blx	r3
	goto card_init;
  40421e:	e72a      	b.n	404076 <main+0x62>
		else{
			if (current_freq>MAX_FREQ_1FILES)
				current_freq=MAX_FREQ_1FILES;
		}						
			
		SysTick_Config(sysclk_get_cpu_hz()/current_freq);
  404220:	f640 4378 	movw	r3, #3192	; 0xc78
  404224:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404228:	681b      	ldr	r3, [r3, #0]
  40422a:	fbb9 f3f3 	udiv	r3, r9, r3
  40422e:	e7bb      	b.n	4041a8 <main+0x194>

00404230 <SysTick_Handler>:
	}
	return 1;
}

void SysTick_Handler(void)
{
  404230:	b508      	push	{r3, lr}
	/* If ready for new data */
	if ((dacc_get_interrupt_status(DACC) & DACC_ISR_TXRDY) == DACC_ISR_TXRDY) {
  404232:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  404236:	f2c4 0003 	movt	r0, #16387	; 0x4003
  40423a:	f241 53e5 	movw	r3, #5605	; 0x15e5
  40423e:	f2c0 0340 	movt	r3, #64	; 0x40
  404242:	4798      	blx	r3
  404244:	f010 0f01 	tst.w	r0, #1
  404248:	d026      	beq.n	404298 <SysTick_Handler+0x68>
		dacc_write_conversion_data(DACC, dac_value);
  40424a:	f640 6380 	movw	r3, #3712	; 0xe80
  40424e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404252:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  404256:	f2c4 0003 	movt	r0, #16387	; 0x4003
  40425a:	6819      	ldr	r1, [r3, #0]
  40425c:	f241 53e9 	movw	r3, #5609	; 0x15e9
  404260:	f2c0 0340 	movt	r3, #64	; 0x40
  404264:	4798      	blx	r3
		p_pio->PIO_CODR |= (~(digitals)<<D3_GPIO);
  404266:	f240 0304 	movw	r3, #4
  40426a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40426e:	681b      	ldr	r3, [r3, #0]
  404270:	6b59      	ldr	r1, [r3, #52]	; 0x34
  404272:	f240 722a 	movw	r2, #1834	; 0x72a
  404276:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40427a:	7812      	ldrb	r2, [r2, #0]
  40427c:	ea6f 0002 	mvn.w	r0, r2
  404280:	ea41 2140 	orr.w	r1, r1, r0, lsl #9
  404284:	6359      	str	r1, [r3, #52]	; 0x34
		p_pio->PIO_SODR |= (digitals<<D3_GPIO);
  404286:	6b19      	ldr	r1, [r3, #48]	; 0x30
  404288:	ea41 2242 	orr.w	r2, r1, r2, lsl #9
  40428c:	631a      	str	r2, [r3, #48]	; 0x30
		updateSamples();
  40428e:	f643 43f9 	movw	r3, #15609	; 0x3cf9
  404292:	f2c0 0340 	movt	r3, #64	; 0x40
  404296:	4798      	blx	r3
  404298:	bd08      	pop	{r3, pc}
  40429a:	bf00      	nop

0040429c <atexit>:
  40429c:	4601      	mov	r1, r0
  40429e:	2000      	movs	r0, #0
  4042a0:	4602      	mov	r2, r0
  4042a2:	4603      	mov	r3, r0
  4042a4:	f000 b920 	b.w	4044e8 <__register_exitproc>

004042a8 <atoi>:
  4042a8:	2100      	movs	r1, #0
  4042aa:	220a      	movs	r2, #10
  4042ac:	f000 b90e 	b.w	4044cc <strtol>

004042b0 <_atoi_r>:
  4042b0:	2200      	movs	r2, #0
  4042b2:	230a      	movs	r3, #10
  4042b4:	f000 b882 	b.w	4043bc <_strtol_r>

004042b8 <__libc_fini_array>:
  4042b8:	b570      	push	{r4, r5, r6, lr}
  4042ba:	4b09      	ldr	r3, [pc, #36]	; (4042e0 <__libc_fini_array+0x28>)
  4042bc:	4c09      	ldr	r4, [pc, #36]	; (4042e4 <__libc_fini_array+0x2c>)
  4042be:	2500      	movs	r5, #0
  4042c0:	1ae4      	subs	r4, r4, r3
  4042c2:	10a4      	asrs	r4, r4, #2
  4042c4:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  4042c8:	e002      	b.n	4042d0 <__libc_fini_array+0x18>
  4042ca:	5972      	ldr	r2, [r6, r5]
  4042cc:	4790      	blx	r2
  4042ce:	3c01      	subs	r4, #1
  4042d0:	3d04      	subs	r5, #4
  4042d2:	2c00      	cmp	r4, #0
  4042d4:	d1f9      	bne.n	4042ca <__libc_fini_array+0x12>
  4042d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  4042da:	f000 bd23 	b.w	404d24 <_fini>
  4042de:	bf00      	nop
  4042e0:	00404d30 	.word	0x00404d30
  4042e4:	00404d34 	.word	0x00404d34

004042e8 <__libc_init_array>:
  4042e8:	b570      	push	{r4, r5, r6, lr}
  4042ea:	4b0e      	ldr	r3, [pc, #56]	; (404324 <__libc_init_array+0x3c>)
  4042ec:	4d0e      	ldr	r5, [pc, #56]	; (404328 <__libc_init_array+0x40>)
  4042ee:	2400      	movs	r4, #0
  4042f0:	1aed      	subs	r5, r5, r3
  4042f2:	10ad      	asrs	r5, r5, #2
  4042f4:	461e      	mov	r6, r3
  4042f6:	e003      	b.n	404300 <__libc_init_array+0x18>
  4042f8:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  4042fc:	4790      	blx	r2
  4042fe:	3401      	adds	r4, #1
  404300:	42ac      	cmp	r4, r5
  404302:	d1f9      	bne.n	4042f8 <__libc_init_array+0x10>
  404304:	f000 fd04 	bl	404d10 <_init>
  404308:	4d08      	ldr	r5, [pc, #32]	; (40432c <__libc_init_array+0x44>)
  40430a:	4b09      	ldr	r3, [pc, #36]	; (404330 <__libc_init_array+0x48>)
  40430c:	2400      	movs	r4, #0
  40430e:	1aed      	subs	r5, r5, r3
  404310:	10ad      	asrs	r5, r5, #2
  404312:	461e      	mov	r6, r3
  404314:	e003      	b.n	40431e <__libc_init_array+0x36>
  404316:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  40431a:	4790      	blx	r2
  40431c:	3401      	adds	r4, #1
  40431e:	42ac      	cmp	r4, r5
  404320:	d1f9      	bne.n	404316 <__libc_init_array+0x2e>
  404322:	bd70      	pop	{r4, r5, r6, pc}
  404324:	00404d1c 	.word	0x00404d1c
  404328:	00404d1c 	.word	0x00404d1c
  40432c:	00404d24 	.word	0x00404d24
  404330:	00404d1c 	.word	0x00404d1c

00404334 <strcpy>:
  404334:	4603      	mov	r3, r0
  404336:	f811 2b01 	ldrb.w	r2, [r1], #1
  40433a:	f803 2b01 	strb.w	r2, [r3], #1
  40433e:	2a00      	cmp	r2, #0
  404340:	d1f9      	bne.n	404336 <strcpy+0x2>
  404342:	4770      	bx	lr

00404344 <strtok>:
  404344:	4b02      	ldr	r3, [pc, #8]	; (404350 <strtok+0xc>)
  404346:	681a      	ldr	r2, [r3, #0]
  404348:	2301      	movs	r3, #1
  40434a:	325c      	adds	r2, #92	; 0x5c
  40434c:	f000 b802 	b.w	404354 <__strtok_r>
  404350:	20000008 	.word	0x20000008

00404354 <__strtok_r>:
  404354:	b5f0      	push	{r4, r5, r6, r7, lr}
  404356:	b910      	cbnz	r0, 40435e <__strtok_r+0xa>
  404358:	6810      	ldr	r0, [r2, #0]
  40435a:	2800      	cmp	r0, #0
  40435c:	d02a      	beq.n	4043b4 <__strtok_r+0x60>
  40435e:	4604      	mov	r4, r0
  404360:	4627      	mov	r7, r4
  404362:	7838      	ldrb	r0, [r7, #0]
  404364:	3401      	adds	r4, #1
  404366:	460e      	mov	r6, r1
  404368:	e008      	b.n	40437c <__strtok_r+0x28>
  40436a:	42a8      	cmp	r0, r5
  40436c:	d106      	bne.n	40437c <__strtok_r+0x28>
  40436e:	2b00      	cmp	r3, #0
  404370:	d1f6      	bne.n	404360 <__strtok_r+0xc>
  404372:	6014      	str	r4, [r2, #0]
  404374:	4638      	mov	r0, r7
  404376:	f804 3c01 	strb.w	r3, [r4, #-1]
  40437a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40437c:	f816 5b01 	ldrb.w	r5, [r6], #1
  404380:	2d00      	cmp	r5, #0
  404382:	d1f2      	bne.n	40436a <__strtok_r+0x16>
  404384:	4623      	mov	r3, r4
  404386:	b908      	cbnz	r0, 40438c <__strtok_r+0x38>
  404388:	6010      	str	r0, [r2, #0]
  40438a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40438c:	f813 0b01 	ldrb.w	r0, [r3], #1
  404390:	460f      	mov	r7, r1
  404392:	461e      	mov	r6, r3
  404394:	f817 5b01 	ldrb.w	r5, [r7], #1
  404398:	4285      	cmp	r5, r0
  40439a:	d108      	bne.n	4043ae <__strtok_r+0x5a>
  40439c:	b118      	cbz	r0, 4043a6 <__strtok_r+0x52>
  40439e:	2100      	movs	r1, #0
  4043a0:	f803 1c01 	strb.w	r1, [r3, #-1]
  4043a4:	e000      	b.n	4043a8 <__strtok_r+0x54>
  4043a6:	4606      	mov	r6, r0
  4043a8:	6016      	str	r6, [r2, #0]
  4043aa:	1e60      	subs	r0, r4, #1
  4043ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4043ae:	2d00      	cmp	r5, #0
  4043b0:	d1f0      	bne.n	404394 <__strtok_r+0x40>
  4043b2:	e7eb      	b.n	40438c <__strtok_r+0x38>
  4043b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

004043b6 <strtok_r>:
  4043b6:	2301      	movs	r3, #1
  4043b8:	f7ff bfcc 	b.w	404354 <__strtok_r>

004043bc <_strtol_r>:
  4043bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4043c0:	9001      	str	r0, [sp, #4]
  4043c2:	4841      	ldr	r0, [pc, #260]	; (4044c8 <_strtol_r+0x10c>)
  4043c4:	f8d0 9000 	ldr.w	r9, [r0]
  4043c8:	4608      	mov	r0, r1
  4043ca:	4604      	mov	r4, r0
  4043cc:	f814 5b01 	ldrb.w	r5, [r4], #1
  4043d0:	eb09 0605 	add.w	r6, r9, r5
  4043d4:	7877      	ldrb	r7, [r6, #1]
  4043d6:	4620      	mov	r0, r4
  4043d8:	f007 0708 	and.w	r7, r7, #8
  4043dc:	b2ff      	uxtb	r7, r7
  4043de:	2f00      	cmp	r7, #0
  4043e0:	d1f3      	bne.n	4043ca <_strtol_r+0xe>
  4043e2:	2d2d      	cmp	r5, #45	; 0x2d
  4043e4:	d103      	bne.n	4043ee <_strtol_r+0x32>
  4043e6:	f814 5b01 	ldrb.w	r5, [r4], #1
  4043ea:	2701      	movs	r7, #1
  4043ec:	e004      	b.n	4043f8 <_strtol_r+0x3c>
  4043ee:	2d2b      	cmp	r5, #43	; 0x2b
  4043f0:	bf04      	itt	eq
  4043f2:	4624      	moveq	r4, r4
  4043f4:	f814 5b01 	ldrbeq.w	r5, [r4], #1
  4043f8:	2b00      	cmp	r3, #0
  4043fa:	d05e      	beq.n	4044ba <_strtol_r+0xfe>
  4043fc:	2b10      	cmp	r3, #16
  4043fe:	d108      	bne.n	404412 <_strtol_r+0x56>
  404400:	e058      	b.n	4044b4 <_strtol_r+0xf8>
  404402:	7820      	ldrb	r0, [r4, #0]
  404404:	2878      	cmp	r0, #120	; 0x78
  404406:	d001      	beq.n	40440c <_strtol_r+0x50>
  404408:	2858      	cmp	r0, #88	; 0x58
  40440a:	d14e      	bne.n	4044aa <_strtol_r+0xee>
  40440c:	7865      	ldrb	r5, [r4, #1]
  40440e:	2310      	movs	r3, #16
  404410:	3402      	adds	r4, #2
  404412:	2f00      	cmp	r7, #0
  404414:	bf0c      	ite	eq
  404416:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40441a:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  40441e:	fbb0 faf3 	udiv	sl, r0, r3
  404422:	2600      	movs	r6, #0
  404424:	fb03 081a 	mls	r8, r3, sl, r0
  404428:	4630      	mov	r0, r6
  40442a:	eb09 0c05 	add.w	ip, r9, r5
  40442e:	f89c c001 	ldrb.w	ip, [ip, #1]
  404432:	f00c 0b04 	and.w	fp, ip, #4
  404436:	fa5f fb8b 	uxtb.w	fp, fp
  40443a:	f1bb 0f00 	cmp.w	fp, #0
  40443e:	d001      	beq.n	404444 <_strtol_r+0x88>
  404440:	3d30      	subs	r5, #48	; 0x30
  404442:	e00b      	b.n	40445c <_strtol_r+0xa0>
  404444:	f01c 0c03 	ands.w	ip, ip, #3
  404448:	d01b      	beq.n	404482 <_strtol_r+0xc6>
  40444a:	f1bc 0f01 	cmp.w	ip, #1
  40444e:	bf14      	ite	ne
  404450:	f04f 0c57 	movne.w	ip, #87	; 0x57
  404454:	f04f 0c37 	moveq.w	ip, #55	; 0x37
  404458:	ebcc 0505 	rsb	r5, ip, r5
  40445c:	429d      	cmp	r5, r3
  40445e:	da10      	bge.n	404482 <_strtol_r+0xc6>
  404460:	f1b6 3fff 	cmp.w	r6, #4294967295
  404464:	d00a      	beq.n	40447c <_strtol_r+0xc0>
  404466:	4550      	cmp	r0, sl
  404468:	d806      	bhi.n	404478 <_strtol_r+0xbc>
  40446a:	d101      	bne.n	404470 <_strtol_r+0xb4>
  40446c:	4545      	cmp	r5, r8
  40446e:	dc03      	bgt.n	404478 <_strtol_r+0xbc>
  404470:	fb03 5000 	mla	r0, r3, r0, r5
  404474:	2601      	movs	r6, #1
  404476:	e001      	b.n	40447c <_strtol_r+0xc0>
  404478:	f04f 36ff 	mov.w	r6, #4294967295
  40447c:	f814 5b01 	ldrb.w	r5, [r4], #1
  404480:	e7d3      	b.n	40442a <_strtol_r+0x6e>
  404482:	1c73      	adds	r3, r6, #1
  404484:	d10a      	bne.n	40449c <_strtol_r+0xe0>
  404486:	2f00      	cmp	r7, #0
  404488:	9901      	ldr	r1, [sp, #4]
  40448a:	bf0c      	ite	eq
  40448c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  404490:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  404494:	2322      	movs	r3, #34	; 0x22
  404496:	600b      	str	r3, [r1, #0]
  404498:	b922      	cbnz	r2, 4044a4 <_strtol_r+0xe8>
  40449a:	e012      	b.n	4044c2 <_strtol_r+0x106>
  40449c:	b107      	cbz	r7, 4044a0 <_strtol_r+0xe4>
  40449e:	4240      	negs	r0, r0
  4044a0:	b17a      	cbz	r2, 4044c2 <_strtol_r+0x106>
  4044a2:	b106      	cbz	r6, 4044a6 <_strtol_r+0xea>
  4044a4:	1e61      	subs	r1, r4, #1
  4044a6:	6011      	str	r1, [r2, #0]
  4044a8:	e00b      	b.n	4044c2 <_strtol_r+0x106>
  4044aa:	2530      	movs	r5, #48	; 0x30
  4044ac:	2b00      	cmp	r3, #0
  4044ae:	d1b0      	bne.n	404412 <_strtol_r+0x56>
  4044b0:	2308      	movs	r3, #8
  4044b2:	e7ae      	b.n	404412 <_strtol_r+0x56>
  4044b4:	2d30      	cmp	r5, #48	; 0x30
  4044b6:	d1ac      	bne.n	404412 <_strtol_r+0x56>
  4044b8:	e7a3      	b.n	404402 <_strtol_r+0x46>
  4044ba:	2d30      	cmp	r5, #48	; 0x30
  4044bc:	d0a1      	beq.n	404402 <_strtol_r+0x46>
  4044be:	230a      	movs	r3, #10
  4044c0:	e7a7      	b.n	404412 <_strtol_r+0x56>
  4044c2:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4044c6:	bf00      	nop
  4044c8:	20000438 	.word	0x20000438

004044cc <strtol>:
  4044cc:	b530      	push	{r4, r5, lr}
  4044ce:	4613      	mov	r3, r2
  4044d0:	4a04      	ldr	r2, [pc, #16]	; (4044e4 <strtol+0x18>)
  4044d2:	4605      	mov	r5, r0
  4044d4:	460c      	mov	r4, r1
  4044d6:	6810      	ldr	r0, [r2, #0]
  4044d8:	4629      	mov	r1, r5
  4044da:	4622      	mov	r2, r4
  4044dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  4044e0:	f7ff bf6c 	b.w	4043bc <_strtol_r>
  4044e4:	20000008 	.word	0x20000008

004044e8 <__register_exitproc>:
  4044e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4044ec:	4698      	mov	r8, r3
  4044ee:	4b23      	ldr	r3, [pc, #140]	; (40457c <__register_exitproc+0x94>)
  4044f0:	4606      	mov	r6, r0
  4044f2:	681c      	ldr	r4, [r3, #0]
  4044f4:	460f      	mov	r7, r1
  4044f6:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  4044fa:	4691      	mov	r9, r2
  4044fc:	b918      	cbnz	r0, 404506 <__register_exitproc+0x1e>
  4044fe:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  404502:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404506:	6841      	ldr	r1, [r0, #4]
  404508:	291f      	cmp	r1, #31
  40450a:	dd16      	ble.n	40453a <__register_exitproc+0x52>
  40450c:	4b1c      	ldr	r3, [pc, #112]	; (404580 <__register_exitproc+0x98>)
  40450e:	b91b      	cbnz	r3, 404518 <__register_exitproc+0x30>
  404510:	f04f 30ff 	mov.w	r0, #4294967295
  404514:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404518:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40451c:	f3af 8000 	nop.w
  404520:	2800      	cmp	r0, #0
  404522:	d0f5      	beq.n	404510 <__register_exitproc+0x28>
  404524:	f8d4 1148 	ldr.w	r1, [r4, #328]	; 0x148
  404528:	2500      	movs	r5, #0
  40452a:	6045      	str	r5, [r0, #4]
  40452c:	6001      	str	r1, [r0, #0]
  40452e:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404532:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  404536:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  40453a:	b1b6      	cbz	r6, 40456a <__register_exitproc+0x82>
  40453c:	6844      	ldr	r4, [r0, #4]
  40453e:	2201      	movs	r2, #1
  404540:	fa02 f204 	lsl.w	r2, r2, r4
  404544:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  404548:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  40454c:	4311      	orrs	r1, r2
  40454e:	2e02      	cmp	r6, #2
  404550:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  404554:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  404558:	461c      	mov	r4, r3
  40455a:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  40455e:	d104      	bne.n	40456a <__register_exitproc+0x82>
  404560:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  404564:	431a      	orrs	r2, r3
  404566:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  40456a:	6843      	ldr	r3, [r0, #4]
  40456c:	1c9a      	adds	r2, r3, #2
  40456e:	3301      	adds	r3, #1
  404570:	f840 7022 	str.w	r7, [r0, r2, lsl #2]
  404574:	6043      	str	r3, [r0, #4]
  404576:	2000      	movs	r0, #0
  404578:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40457c:	00404c08 	.word	0x00404c08
  404580:	00000000 	.word	0x00000000

00404584 <register_fini>:
  404584:	4b02      	ldr	r3, [pc, #8]	; (404590 <register_fini+0xc>)
  404586:	b113      	cbz	r3, 40458e <register_fini+0xa>
  404588:	4802      	ldr	r0, [pc, #8]	; (404594 <register_fini+0x10>)
  40458a:	f7ff be87 	b.w	40429c <atexit>
  40458e:	4770      	bx	lr
  404590:	00000000 	.word	0x00000000
  404594:	004042b9 	.word	0x004042b9

00404598 <sd_trans_multipliers>:
  404598:	00000000 0000000a 0000000c 0000000d     ................
  4045a8:	0000000f 00000014 00000019 0000001e     ................
  4045b8:	00000023 00000028 0000002d 00000032     #...(...-...2...
  4045c8:	00000037 0000003c 00000046 00000050     7...<...F...P...

004045d8 <sd_mmc_trans_units>:
  4045d8:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

004045f4 <mmc_trans_multipliers>:
  4045f4:	00000000 0000000a 0000000c 0000000d     ................
  404604:	0000000f 00000014 0000001a 0000001e     ................
  404614:	00000023 00000028 0000002d 00000034     #...(...-...4...
  404624:	00000037 0000003c 00000046 00000050     7...<...F...P...

00404634 <lun_desc>:
  404634:	004002ad 004002fd 00400335 00400365     ..@...@.5.@.e.@.
  404644:	004003d5 0040044d 0040466c 004002c1     ..@.M.@.lF@...@.
  404654:	00400311 00400349 00400379 004003ed     ..@.I.@.y.@...@.
  404664:	00400465 00404684 2f445322 20434d4d     e.@..F@."SD/MMC 
  404674:	64726143 6f6c5320 22302074 00000000     Card Slot 0"....
  404684:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  404694:	22312074 00000000 3c3a2a22 7f7c3f3e     t 1"...."*:<>?|.
  4046a4:	00000000 3d3b2c2b 00005d5b              ....+,;=[]..

004046b0 <LfnOfs>:
  4046b0:	07050301 12100e09 1c181614 0000001e     ................

004046c0 <excvt.4405>:
  4046c0:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  4046d0:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  4046e0:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  4046f0:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  404700:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  404710:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  404720:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  404730:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................

00404740 <tbl_upper.4241>:
  404740:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  404750:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  404760:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  404770:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  404780:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  404790:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  4047a0:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  4047b0:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  4047c0:	01040102 01080106 010c010a 0110010e     ................
  4047d0:	01140112 01180116 011c011a 0120011e     .............. .
  4047e0:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  4047f0:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  404800:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  404810:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  404820:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  404830:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  404840:	03940393 03960395 03980397 039a0399     ................
  404850:	039c039b 039e039d 03a0039f 03a303a1     ................
  404860:	03a503a4 03a703a6 03a903a8 041003aa     ................
  404870:	04120411 04140413 04160415 04180417     ................
  404880:	041a0419 041c041b 041e041d 0420041f     .............. .
  404890:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  4048a0:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  4048b0:	04030402 04050404 04070406 04090408     ................
  4048c0:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  4048d0:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  4048e0:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  4048f0:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  404900:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  404910:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...

00404920 <Tbl>:
  404920:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  404930:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  404940:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  404950:	00d600ff 00f800dc 00d800a3 019200d7     ................
  404960:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  404970:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  404980:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  404990:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  4049a0:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  4049b0:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  4049c0:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  4049d0:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  4049e0:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  4049f0:	00da00de 00d900db 00dd00fd 00b400af     ................
  404a00:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  404a10:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00404a20 <tbl_lower.4240>:
  404a20:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  404a30:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  404a40:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  404a50:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  404a60:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  404a70:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  404a80:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  404a90:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  404aa0:	01050103 01090107 010d010b 0111010f     ................
  404ab0:	01150113 01190117 011d011b 0121011f     ..............!.
  404ac0:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  404ad0:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  404ae0:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  404af0:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  404b00:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  404b10:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  404b20:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  404b30:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  404b40:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  404b50:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  404b60:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  404b70:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  404b80:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  404b90:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  404ba0:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  404bb0:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  404bc0:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  404bd0:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  404be0:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  404bf0:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...
  404c00:	0000005f 0000002f                       _.../...

00404c08 <_global_impure_ptr>:
  404c08:	20000010 20000043                                ... C.

00404c0e <_ctype_>:
  404c0e:	20202000 20202020 28282020 20282828     .         ((((( 
  404c1e:	20202020 20202020 20202020 20202020                     
  404c2e:	10108820 10101010 10101010 10101010      ...............
  404c3e:	04040410 04040404 10040404 10101010     ................
  404c4e:	41411010 41414141 01010101 01010101     ..AAAAAA........
  404c5e:	01010101 01010101 01010101 10101010     ................
  404c6e:	42421010 42424242 02020202 02020202     ..BBBBBB........
  404c7e:	02020202 02020202 02020202 10101010     ................
  404c8e:	00000020 00000000 00000000 00000000      ...............
	...

00404d10 <_init>:
  404d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404d12:	bf00      	nop
  404d14:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404d16:	bc08      	pop	{r3}
  404d18:	469e      	mov	lr, r3
  404d1a:	4770      	bx	lr

00404d1c <__init_array_start>:
  404d1c:	00404585 	.word	0x00404585

00404d20 <__frame_dummy_init_array_entry>:
  404d20:	00400149                                I.@.

00404d24 <_fini>:
  404d24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404d26:	bf00      	nop
  404d28:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404d2a:	bc08      	pop	{r3}
  404d2c:	469e      	mov	lr, r3
  404d2e:	4770      	bx	lr

00404d30 <__fini_array_start>:
  404d30:	00400121 	.word	0x00400121
