
baka_restored.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004c50  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00404c50  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000a48  2000043c  0040508c  0001043c  2**2
                  ALLOC
  3 .stack        00003004  20000e84  00405ad4  0001043c  2**0
                  ALLOC
  4 .ARM.attributes 0000002f  00000000  00000000  0001043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000033  00000000  00000000  0001046b  2**0
                  CONTENTS, READONLY
  6 .debug_info   00010707  00000000  00000000  0001049e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000313e  00000000  00000000  00020ba5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00008c77  00000000  00000000  00023ce3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000ba0  00000000  00000000  0002c95a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000de0  00000000  00000000  0002d4fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001c29e  00000000  00000000  0002e2da  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed16  00000000  00000000  0004a578  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004f33e  00000000  00000000  0005928e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001954  00000000  00000000  000a85cc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20003e88 	.word	0x20003e88
  400004:	00402131 	.word	0x00402131
  400008:	0040212d 	.word	0x0040212d
  40000c:	0040212d 	.word	0x0040212d
  400010:	0040212d 	.word	0x0040212d
  400014:	0040212d 	.word	0x0040212d
  400018:	0040212d 	.word	0x0040212d
	...
  40002c:	0040212d 	.word	0x0040212d
  400030:	0040212d 	.word	0x0040212d
  400034:	00000000 	.word	0x00000000
  400038:	0040212d 	.word	0x0040212d
  40003c:	0040414d 	.word	0x0040414d
  400040:	0040212d 	.word	0x0040212d
  400044:	0040212d 	.word	0x0040212d
  400048:	0040212d 	.word	0x0040212d
  40004c:	0040212d 	.word	0x0040212d
  400050:	0040212d 	.word	0x0040212d
  400054:	0040212d 	.word	0x0040212d
  400058:	0040212d 	.word	0x0040212d
  40005c:	0040212d 	.word	0x0040212d
  400060:	0040212d 	.word	0x0040212d
  400064:	0040212d 	.word	0x0040212d
  400068:	0040212d 	.word	0x0040212d
  40006c:	00401f15 	.word	0x00401f15
  400070:	00401f31 	.word	0x00401f31
  400074:	00401f4d 	.word	0x00401f4d
  400078:	0040212d 	.word	0x0040212d
  40007c:	0040212d 	.word	0x0040212d
  400080:	0040212d 	.word	0x0040212d
  400084:	0040212d 	.word	0x0040212d
  400088:	0040212d 	.word	0x0040212d
  40008c:	0040212d 	.word	0x0040212d
  400090:	0040212d 	.word	0x0040212d
  400094:	0040212d 	.word	0x0040212d
  400098:	0040212d 	.word	0x0040212d
  40009c:	0040212d 	.word	0x0040212d
  4000a0:	0040212d 	.word	0x0040212d
  4000a4:	0040212d 	.word	0x0040212d
  4000a8:	0040212d 	.word	0x0040212d
  4000ac:	0040212d 	.word	0x0040212d
  4000b0:	0040212d 	.word	0x0040212d
  4000b4:	0040212d 	.word	0x0040212d
  4000b8:	0040212d 	.word	0x0040212d
  4000bc:	0040212d 	.word	0x0040212d
  4000c0:	0040212d 	.word	0x0040212d
  4000c4:	0040212d 	.word	0x0040212d
  4000c8:	0040212d 	.word	0x0040212d
  4000cc:	0040212d 	.word	0x0040212d

004000d0 <deregister_tm_clones>:
  4000d0:	b508      	push	{r3, lr}
  4000d2:	4805      	ldr	r0, [pc, #20]	; (4000e8 <deregister_tm_clones+0x18>)
  4000d4:	4b05      	ldr	r3, [pc, #20]	; (4000ec <deregister_tm_clones+0x1c>)
  4000d6:	1a1b      	subs	r3, r3, r0
  4000d8:	2b06      	cmp	r3, #6
  4000da:	d800      	bhi.n	4000de <deregister_tm_clones+0xe>
  4000dc:	bd08      	pop	{r3, pc}
  4000de:	4b04      	ldr	r3, [pc, #16]	; (4000f0 <deregister_tm_clones+0x20>)
  4000e0:	2b00      	cmp	r3, #0
  4000e2:	d0fb      	beq.n	4000dc <deregister_tm_clones+0xc>
  4000e4:	4798      	blx	r3
  4000e6:	e7f9      	b.n	4000dc <deregister_tm_clones+0xc>
  4000e8:	00404c50 	.word	0x00404c50
  4000ec:	00404c53 	.word	0x00404c53
  4000f0:	00000000 	.word	0x00000000

004000f4 <register_tm_clones>:
  4000f4:	b508      	push	{r3, lr}
  4000f6:	4807      	ldr	r0, [pc, #28]	; (400114 <register_tm_clones+0x20>)
  4000f8:	4b07      	ldr	r3, [pc, #28]	; (400118 <register_tm_clones+0x24>)
  4000fa:	1a1b      	subs	r3, r3, r0
  4000fc:	109b      	asrs	r3, r3, #2
  4000fe:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
  400102:	1059      	asrs	r1, r3, #1
  400104:	d100      	bne.n	400108 <register_tm_clones+0x14>
  400106:	bd08      	pop	{r3, pc}
  400108:	4a04      	ldr	r2, [pc, #16]	; (40011c <register_tm_clones+0x28>)
  40010a:	2a00      	cmp	r2, #0
  40010c:	d0fb      	beq.n	400106 <register_tm_clones+0x12>
  40010e:	4790      	blx	r2
  400110:	e7f9      	b.n	400106 <register_tm_clones+0x12>
  400112:	bf00      	nop
  400114:	00404c50 	.word	0x00404c50
  400118:	00404c50 	.word	0x00404c50
  40011c:	00000000 	.word	0x00000000

00400120 <__do_global_dtors_aux>:
  400120:	b510      	push	{r4, lr}
  400122:	4c06      	ldr	r4, [pc, #24]	; (40013c <__do_global_dtors_aux+0x1c>)
  400124:	7823      	ldrb	r3, [r4, #0]
  400126:	b943      	cbnz	r3, 40013a <__do_global_dtors_aux+0x1a>
  400128:	f7ff ffd2 	bl	4000d0 <deregister_tm_clones>
  40012c:	4b04      	ldr	r3, [pc, #16]	; (400140 <__do_global_dtors_aux+0x20>)
  40012e:	b113      	cbz	r3, 400136 <__do_global_dtors_aux+0x16>
  400130:	4804      	ldr	r0, [pc, #16]	; (400144 <__do_global_dtors_aux+0x24>)
  400132:	f3af 8000 	nop.w
  400136:	2301      	movs	r3, #1
  400138:	7023      	strb	r3, [r4, #0]
  40013a:	bd10      	pop	{r4, pc}
  40013c:	2000043c 	.word	0x2000043c
  400140:	00000000 	.word	0x00000000
  400144:	00404c50 	.word	0x00404c50

00400148 <frame_dummy>:
  400148:	b508      	push	{r3, lr}
  40014a:	4b08      	ldr	r3, [pc, #32]	; (40016c <frame_dummy+0x24>)
  40014c:	b11b      	cbz	r3, 400156 <frame_dummy+0xe>
  40014e:	4808      	ldr	r0, [pc, #32]	; (400170 <frame_dummy+0x28>)
  400150:	4908      	ldr	r1, [pc, #32]	; (400174 <frame_dummy+0x2c>)
  400152:	f3af 8000 	nop.w
  400156:	4808      	ldr	r0, [pc, #32]	; (400178 <frame_dummy+0x30>)
  400158:	6803      	ldr	r3, [r0, #0]
  40015a:	b113      	cbz	r3, 400162 <frame_dummy+0x1a>
  40015c:	4b07      	ldr	r3, [pc, #28]	; (40017c <frame_dummy+0x34>)
  40015e:	b103      	cbz	r3, 400162 <frame_dummy+0x1a>
  400160:	4798      	blx	r3
  400162:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400166:	f7ff bfc5 	b.w	4000f4 <register_tm_clones>
  40016a:	bf00      	nop
  40016c:	00000000 	.word	0x00000000
  400170:	00404c50 	.word	0x00404c50
  400174:	20000440 	.word	0x20000440
  400178:	00404c50 	.word	0x00404c50
  40017c:	00000000 	.word	0x00000000

00400180 <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{
  400180:	b538      	push	{r3, r4, r5, lr}
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
	
	WDT->WDT_MR = WDT_MR_WDDIS;
  400182:	f241 4350 	movw	r3, #5200	; 0x1450
  400186:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40018a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40018e:	605a      	str	r2, [r3, #4]
	

	/* Configure pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  400190:	f04f 0000 	mov.w	r0, #0
  400194:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400198:	f641 5445 	movw	r4, #7493	; 0x1d45
  40019c:	f2c0 0440 	movt	r4, #64	; 0x40
  4001a0:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  4001a2:	f04f 0006 	mov.w	r0, #6
  4001a6:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4001aa:	47a0      	blx	r4
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
  4001ac:	f04f 0005 	mov.w	r0, #5
  4001b0:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4001b4:	47a0      	blx	r4
	gpio_configure_pin(SS0_GPIO, SS0_FLAGS);
  4001b6:	f04f 050a 	mov.w	r5, #10
  4001ba:	f6c2 0500 	movt	r5, #10240	; 0x2800
  4001be:	f04f 0013 	mov.w	r0, #19
  4001c2:	4629      	mov	r1, r5
  4001c4:	47a0      	blx	r4
	gpio_configure_pin(SS1_GPIO, SS1_FLAGS);
  4001c6:	f04f 0016 	mov.w	r0, #22
  4001ca:	4629      	mov	r1, r5
  4001cc:	47a0      	blx	r4
	gpio_configure_pin(SS2_GPIO, SS2_FLAGS);
  4001ce:	f04f 0017 	mov.w	r0, #23
  4001d2:	4629      	mov	r1, r5
  4001d4:	47a0      	blx	r4
	gpio_configure_pin(SS3_GPIO, SS3_FLAGS);
  4001d6:	f04f 0014 	mov.w	r0, #20
  4001da:	4629      	mov	r1, r5
  4001dc:	47a0      	blx	r4
	gpio_configure_pin(SS4_GPIO, SS4_FLAGS);
  4001de:	f04f 000f 	mov.w	r0, #15
  4001e2:	4629      	mov	r1, r5
  4001e4:	47a0      	blx	r4
	gpio_configure_pin(SS5_GPIO, SS5_FLAGS);
  4001e6:	f04f 000e 	mov.w	r0, #14
  4001ea:	4629      	mov	r1, r5
  4001ec:	47a0      	blx	r4
	gpio_configure_pin(SS6_GPIO, SS6_FLAGS);
  4001ee:	f04f 000d 	mov.w	r0, #13
  4001f2:	4629      	mov	r1, r5
  4001f4:	47a0      	blx	r4
	gpio_configure_pin(SS7_GPIO, SS7_FLAGS);
  4001f6:	f04f 0018 	mov.w	r0, #24
  4001fa:	4629      	mov	r1, r5
  4001fc:	47a0      	blx	r4
	gpio_configure_pin(BUT0_GPIO, BUT0_FLAGS);
  4001fe:	f04f 0010 	mov.w	r0, #16
  400202:	4629      	mov	r1, r5
  400204:	47a0      	blx	r4
	gpio_configure_pin(D0_GPIO, D0_FLAGS);
  400206:	f04f 000c 	mov.w	r0, #12
  40020a:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  40020e:	47a0      	blx	r4
	gpio_configure_pin(D1_GPIO, D1_FLAGS);
  400210:	f04f 000b 	mov.w	r0, #11
  400214:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400218:	47a0      	blx	r4
	gpio_configure_pin(D2_GPIO, D2_FLAGS);
  40021a:	f04f 000a 	mov.w	r0, #10
  40021e:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400222:	47a0      	blx	r4
	gpio_configure_pin(D3_GPIO, D3_FLAGS);
  400224:	f04f 0009 	mov.w	r0, #9
  400228:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  40022c:	47a0      	blx	r4
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  40022e:	f04f 001c 	mov.w	r0, #28
  400232:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400236:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  400238:	f04f 001d 	mov.w	r0, #29
  40023c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400240:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  400242:	f04f 001e 	mov.w	r0, #30
  400246:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40024a:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  40024c:	f04f 001f 	mov.w	r0, #31
  400250:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400254:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  400256:	f04f 001a 	mov.w	r0, #26
  40025a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40025e:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  400260:	f04f 001b 	mov.w	r0, #27
  400264:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400268:	47a0      	blx	r4
  40026a:	bd38      	pop	{r3, r4, r5, pc}

0040026c <sd_mmc_test_unit_ready>:
 * \name Control Interface
 * @{
 */

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  40026c:	b510      	push	{r4, lr}
  40026e:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  400270:	f240 6351 	movw	r3, #1617	; 0x651
  400274:	f2c0 0340 	movt	r3, #64	; 0x40
  400278:	4798      	blx	r3
  40027a:	2801      	cmp	r0, #1
  40027c:	d005      	beq.n	40028a <sd_mmc_test_unit_ready+0x1e>
  40027e:	b138      	cbz	r0, 400290 <sd_mmc_test_unit_ready+0x24>

	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
  400280:	2802      	cmp	r0, #2
  400282:	bf0c      	ite	eq
  400284:	2002      	moveq	r0, #2
  400286:	2001      	movne	r0, #1
  400288:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  40028a:	f04f 0003 	mov.w	r0, #3
  40028e:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  400290:	4620      	mov	r0, r4
  400292:	f241 03fd 	movw	r3, #4349	; 0x10fd
  400296:	f2c0 0340 	movt	r3, #64	; 0x40
  40029a:	4798      	blx	r3
  40029c:	f000 0003 	and.w	r0, r0, #3
			return CTRL_GOOD;
  4002a0:	2800      	cmp	r0, #0
  4002a2:	bf0c      	ite	eq
  4002a4:	2002      	moveq	r0, #2
  4002a6:	2000      	movne	r0, #0
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  4002a8:	bd10      	pop	{r4, pc}
  4002aa:	bf00      	nop

004002ac <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  4002ac:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  4002ae:	f04f 0000 	mov.w	r0, #0
  4002b2:	f240 236d 	movw	r3, #621	; 0x26d
  4002b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4002ba:	4798      	blx	r3
}
  4002bc:	bd08      	pop	{r3, pc}
  4002be:	bf00      	nop

004002c0 <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  4002c0:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  4002c2:	f04f 0001 	mov.w	r0, #1
  4002c6:	f240 236d 	movw	r3, #621	; 0x26d
  4002ca:	f2c0 0340 	movt	r3, #64	; 0x40
  4002ce:	4798      	blx	r3
}
  4002d0:	bd08      	pop	{r3, pc}
  4002d2:	bf00      	nop

004002d4 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  4002d4:	b538      	push	{r3, r4, r5, lr}
  4002d6:	4604      	mov	r4, r0
  4002d8:	460d      	mov	r5, r1
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  4002da:	f241 1329 	movw	r3, #4393	; 0x1129
  4002de:	f2c0 0340 	movt	r3, #64	; 0x40
  4002e2:	4798      	blx	r3
  4002e4:	ea4f 0040 	mov.w	r0, r0, lsl #1
  4002e8:	f100 30ff 	add.w	r0, r0, #4294967295
  4002ec:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  4002ee:	4620      	mov	r0, r4
  4002f0:	f240 236d 	movw	r3, #621	; 0x26d
  4002f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4002f8:	4798      	blx	r3
}
  4002fa:	bd38      	pop	{r3, r4, r5, pc}

004002fc <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  4002fc:	b508      	push	{r3, lr}
  4002fe:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  400300:	f04f 0000 	mov.w	r0, #0
  400304:	f240 23d5 	movw	r3, #725	; 0x2d5
  400308:	f2c0 0340 	movt	r3, #64	; 0x40
  40030c:	4798      	blx	r3
}
  40030e:	bd08      	pop	{r3, pc}

00400310 <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  400310:	b508      	push	{r3, lr}
  400312:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  400314:	f04f 0001 	mov.w	r0, #1
  400318:	f240 23d5 	movw	r3, #725	; 0x2d5
  40031c:	f2c0 0340 	movt	r3, #64	; 0x40
  400320:	4798      	blx	r3
}
  400322:	bd08      	pop	{r3, pc}

00400324 <sd_mmc_wr_protect>:

bool sd_mmc_wr_protect(uint8_t slot)
{
  400324:	b508      	push	{r3, lr}
	return sd_mmc_is_write_protected(slot);
  400326:	f241 1355 	movw	r3, #4437	; 0x1155
  40032a:	f2c0 0340 	movt	r3, #64	; 0x40
  40032e:	4798      	blx	r3
}
  400330:	bd08      	pop	{r3, pc}
  400332:	bf00      	nop

00400334 <sd_mmc_wr_protect_0>:

bool sd_mmc_wr_protect_0(void)
{
  400334:	b508      	push	{r3, lr}
	return sd_mmc_wr_protect(0);
  400336:	f04f 0000 	mov.w	r0, #0
  40033a:	f240 3325 	movw	r3, #805	; 0x325
  40033e:	f2c0 0340 	movt	r3, #64	; 0x40
  400342:	4798      	blx	r3
}
  400344:	bd08      	pop	{r3, pc}
  400346:	bf00      	nop

00400348 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  400348:	b508      	push	{r3, lr}
	return sd_mmc_wr_protect(1);
  40034a:	f04f 0001 	mov.w	r0, #1
  40034e:	f240 3325 	movw	r3, #805	; 0x325
  400352:	f2c0 0340 	movt	r3, #64	; 0x40
  400356:	4798      	blx	r3
}
  400358:	bd08      	pop	{r3, pc}
  40035a:	bf00      	nop

0040035c <sd_mmc_removal>:

bool sd_mmc_removal(uint8_t slot)
{
	UNUSED(slot);
	return false;
}
  40035c:	f04f 0000 	mov.w	r0, #0
  400360:	4770      	bx	lr
  400362:	bf00      	nop

00400364 <sd_mmc_removal_0>:

bool sd_mmc_removal_0(void)
{
  400364:	b508      	push	{r3, lr}
	return sd_mmc_removal(0);
  400366:	f04f 0000 	mov.w	r0, #0
  40036a:	f240 335d 	movw	r3, #861	; 0x35d
  40036e:	f2c0 0340 	movt	r3, #64	; 0x40
  400372:	4798      	blx	r3
}
  400374:	bd08      	pop	{r3, pc}
  400376:	bf00      	nop

00400378 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
  400378:	b508      	push	{r3, lr}
	return sd_mmc_removal(1);
  40037a:	f04f 0001 	mov.w	r0, #1
  40037e:	f240 335d 	movw	r3, #861	; 0x35d
  400382:	f2c0 0340 	movt	r3, #64	; 0x40
  400386:	4798      	blx	r3
}
  400388:	bd08      	pop	{r3, pc}
  40038a:	bf00      	nop

0040038c <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  40038c:	b510      	push	{r4, lr}
  40038e:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  400390:	f04f 0201 	mov.w	r2, #1
  400394:	f241 135d 	movw	r3, #4445	; 0x115d
  400398:	f2c0 0340 	movt	r3, #64	; 0x40
  40039c:	4798      	blx	r3
  40039e:	b120      	cbz	r0, 4003aa <sd_mmc_mem_2_ram+0x1e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  4003a0:	2802      	cmp	r0, #2
  4003a2:	bf0c      	ite	eq
  4003a4:	2002      	moveq	r0, #2
  4003a6:	2001      	movne	r0, #1
  4003a8:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  4003aa:	4620      	mov	r0, r4
  4003ac:	f04f 0101 	mov.w	r1, #1
  4003b0:	f241 2371 	movw	r3, #4721	; 0x1271
  4003b4:	f2c0 0340 	movt	r3, #64	; 0x40
  4003b8:	4798      	blx	r3
  4003ba:	b940      	cbnz	r0, 4003ce <sd_mmc_mem_2_ram+0x42>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks()) {
  4003bc:	f241 23a9 	movw	r3, #4777	; 0x12a9
  4003c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4003c4:	4798      	blx	r3
{
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
  4003c6:	3000      	adds	r0, #0
  4003c8:	bf18      	it	ne
  4003ca:	2001      	movne	r0, #1
  4003cc:	bd10      	pop	{r4, pc}
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
  4003ce:	f04f 0001 	mov.w	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks()) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  4003d2:	bd10      	pop	{r4, pc}

004003d4 <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  4003d4:	b508      	push	{r3, lr}
  4003d6:	4603      	mov	r3, r0
  4003d8:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  4003da:	f04f 0000 	mov.w	r0, #0
  4003de:	4619      	mov	r1, r3
  4003e0:	f240 338d 	movw	r3, #909	; 0x38d
  4003e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4003e8:	4798      	blx	r3
}
  4003ea:	bd08      	pop	{r3, pc}

004003ec <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  4003ec:	b508      	push	{r3, lr}
  4003ee:	4603      	mov	r3, r0
  4003f0:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  4003f2:	f04f 0001 	mov.w	r0, #1
  4003f6:	4619      	mov	r1, r3
  4003f8:	f240 338d 	movw	r3, #909	; 0x38d
  4003fc:	f2c0 0340 	movt	r3, #64	; 0x40
  400400:	4798      	blx	r3
}
  400402:	bd08      	pop	{r3, pc}

00400404 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  400404:	b510      	push	{r4, lr}
  400406:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  400408:	f04f 0201 	mov.w	r2, #1
  40040c:	f241 3329 	movw	r3, #4905	; 0x1329
  400410:	f2c0 0340 	movt	r3, #64	; 0x40
  400414:	4798      	blx	r3
  400416:	b120      	cbz	r0, 400422 <sd_mmc_ram_2_mem+0x1e>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  400418:	2802      	cmp	r0, #2
  40041a:	bf0c      	ite	eq
  40041c:	2002      	moveq	r0, #2
  40041e:	2001      	movne	r0, #1
  400420:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  400422:	4620      	mov	r0, r4
  400424:	f04f 0101 	mov.w	r1, #1
  400428:	f241 33f9 	movw	r3, #5113	; 0x13f9
  40042c:	f2c0 0340 	movt	r3, #64	; 0x40
  400430:	4798      	blx	r3
  400432:	b940      	cbnz	r0, 400446 <sd_mmc_ram_2_mem+0x42>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks()) {
  400434:	f241 4331 	movw	r3, #5169	; 0x1431
  400438:	f2c0 0340 	movt	r3, #64	; 0x40
  40043c:	4798      	blx	r3
{
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
  40043e:	3000      	adds	r0, #0
  400440:	bf18      	it	ne
  400442:	2001      	movne	r0, #1
  400444:	bd10      	pop	{r4, pc}
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
  400446:	f04f 0001 	mov.w	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks()) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  40044a:	bd10      	pop	{r4, pc}

0040044c <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  40044c:	b508      	push	{r3, lr}
  40044e:	4603      	mov	r3, r0
  400450:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  400452:	f04f 0000 	mov.w	r0, #0
  400456:	4619      	mov	r1, r3
  400458:	f240 4305 	movw	r3, #1029	; 0x405
  40045c:	f2c0 0340 	movt	r3, #64	; 0x40
  400460:	4798      	blx	r3
}
  400462:	bd08      	pop	{r3, pc}

00400464 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  400464:	b508      	push	{r3, lr}
  400466:	4603      	mov	r3, r0
  400468:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  40046a:	f04f 0001 	mov.w	r0, #1
  40046e:	4619      	mov	r1, r3
  400470:	f240 4305 	movw	r3, #1029	; 0x405
  400474:	f2c0 0340 	movt	r3, #64	; 0x40
  400478:	4798      	blx	r3
}
  40047a:	bd08      	pop	{r3, pc}

0040047c <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  40047c:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  40047e:	f240 435c 	movw	r3, #1116	; 0x45c
  400482:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400486:	681a      	ldr	r2, [r3, #0]
  400488:	f240 4162 	movw	r1, #1122	; 0x462
  40048c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  400490:	7f93      	ldrb	r3, [r2, #30]
  400492:	7808      	ldrb	r0, [r1, #0]
  400494:	6811      	ldr	r1, [r2, #0]
  400496:	7b52      	ldrb	r2, [r2, #13]
  400498:	3300      	adds	r3, #0
  40049a:	bf18      	it	ne
  40049c:	2301      	movne	r3, #1
  40049e:	f241 74a9 	movw	r4, #6057	; 0x17a9
  4004a2:	f2c0 0440 	movt	r4, #64	; 0x40
  4004a6:	47a0      	blx	r4
  4004a8:	bd10      	pop	{r4, pc}
  4004aa:	bf00      	nop

004004ac <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
  4004ac:	b510      	push	{r4, lr}
	if (slot >= SD_MMC_MEM_CNT) {
  4004ae:	2800      	cmp	r0, #0
  4004b0:	d136      	bne.n	400520 <sd_mmc_select_slot+0x74>
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4004b2:	f240 4364 	movw	r3, #1124	; 0x464
  4004b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
  4004ba:	7a9b      	ldrb	r3, [r3, #10]
  4004bc:	f1a3 0303 	sub.w	r3, r3, #3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4004c0:	b2db      	uxtb	r3, r3
  4004c2:	2b01      	cmp	r3, #1
  4004c4:	d811      	bhi.n	4004ea <sd_mmc_select_slot+0x3e>
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  4004c6:	f240 4364 	movw	r3, #1124	; 0x464
  4004ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004ce:	f04f 0202 	mov.w	r2, #2
  4004d2:	729a      	strb	r2, [r3, #10]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  4004d4:	f44f 52d4 	mov.w	r2, #6784	; 0x1a80
  4004d8:	f2c0 0206 	movt	r2, #6
  4004dc:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
  4004de:	f04f 0201 	mov.w	r2, #1
  4004e2:	735a      	strb	r2, [r3, #13]
		sd_mmc_cards[slot].high_speed = 0;
  4004e4:	f04f 0200 	mov.w	r2, #0
  4004e8:	779a      	strb	r2, [r3, #30]
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  4004ea:	f240 4362 	movw	r3, #1122	; 0x462
  4004ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004f2:	f04f 0200 	mov.w	r2, #0
  4004f6:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  4004f8:	f240 435c 	movw	r3, #1116	; 0x45c
  4004fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400500:	f240 4464 	movw	r4, #1124	; 0x464
  400504:	f2c2 0400 	movt	r4, #8192	; 0x2000
  400508:	601c      	str	r4, [r3, #0]
	sd_mmc_configure_slot();
  40050a:	f240 437d 	movw	r3, #1149	; 0x47d
  40050e:	f2c0 0340 	movt	r3, #64	; 0x40
  400512:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  400514:	7aa0      	ldrb	r0, [r4, #10]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  400516:	2802      	cmp	r0, #2
  400518:	bf14      	ite	ne
  40051a:	2000      	movne	r0, #0
  40051c:	2001      	moveq	r0, #1
  40051e:	bd10      	pop	{r4, pc}
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
		return SD_MMC_ERR_SLOT;
  400520:	f04f 0004 	mov.w	r0, #4
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
}
  400524:	bd10      	pop	{r4, pc}
  400526:	bf00      	nop

00400528 <sdio_cmd53>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd53(uint8_t rw_flag, uint8_t func_nb, uint32_t reg_addr,
		uint8_t inc_addr, uint32_t size, bool access_block)
{
  400528:	b570      	push	{r4, r5, r6, lr}
  40052a:	b082      	sub	sp, #8
  40052c:	9c06      	ldr	r4, [sp, #24]
	Assert(size != 0);
	Assert(size <= 512);

	if (size == 512) {
		size = 0; // 0 = 512B on SDIO command
  40052e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  400532:	bf08      	it	eq
  400534:	2400      	moveq	r4, #0
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
  400536:	f249 3635 	movw	r6, #37685	; 0x9335
  40053a:	f2c0 0601 	movt	r6, #1
  40053e:	f241 3535 	movw	r5, #4917	; 0x1335
  400542:	f2c0 0501 	movt	r5, #1
			SDIO_CMD53_IO_W_BYTE_EXTENDED,
			(size << SDIO_CMD53_COUNT)
			| ((uint32_t)reg_addr << SDIO_CMD53_REG_ADDR)
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
  400546:	ea4f 7101 	mov.w	r1, r1, lsl #28
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
			SDIO_CMD53_IO_R_BYTE_EXTENDED :
			SDIO_CMD53_IO_W_BYTE_EXTENDED,
			(size << SDIO_CMD53_COUNT)
			| ((uint32_t)reg_addr << SDIO_CMD53_REG_ADDR)
  40054a:	ea41 2242 	orr.w	r2, r1, r2, lsl #9
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
  40054e:	ea42 71c0 	orr.w	r1, r2, r0, lsl #31
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
  400552:	ea41 6183 	orr.w	r1, r1, r3, lsl #26
	Assert(size <= 512);

	if (size == 512) {
		size = 0; // 0 = 512B on SDIO command
	}
	return driver_adtc_start((rw_flag == SDIO_CMD53_READ_FLAG)?
  400556:	f89d 301c 	ldrb.w	r3, [sp, #28]
  40055a:	9300      	str	r3, [sp, #0]
  40055c:	2800      	cmp	r0, #0
  40055e:	bf14      	ite	ne
  400560:	4630      	movne	r0, r6
  400562:	4628      	moveq	r0, r5
  400564:	4321      	orrs	r1, r4
  400566:	b2a2      	uxth	r2, r4
  400568:	f04f 0301 	mov.w	r3, #1
  40056c:	f641 04a9 	movw	r4, #6313	; 0x18a9
  400570:	f2c0 0440 	movt	r4, #64	; 0x40
  400574:	47a0      	blx	r4
			| ((uint32_t)inc_addr << SDIO_CMD53_OP_CODE)
			| ((uint32_t)0 << SDIO_CMD53_BLOCK_MODE)
			| ((uint32_t)func_nb << SDIO_CMD53_FUNCTION_NUM)
			| ((uint32_t)rw_flag << SDIO_CMD53_RW_FLAG),
			size, 1, access_block);
}
  400576:	b002      	add	sp, #8
  400578:	bd70      	pop	{r4, r5, r6, pc}
  40057a:	bf00      	nop

0040057c <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
  40057c:	b508      	push	{r3, lr}
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40057e:	f240 4362 	movw	r3, #1122	; 0x462
  400582:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400586:	781b      	ldrb	r3, [r3, #0]
  400588:	b933      	cbnz	r3, 400598 <sd_mmc_deselect_slot+0x1c>
		driver_deselect_device(sd_mmc_slot_sel);
  40058a:	f04f 0000 	mov.w	r0, #0
  40058e:	f641 031d 	movw	r3, #6173	; 0x181d
  400592:	f2c0 0340 	movt	r3, #64	; 0x40
  400596:	4798      	blx	r3
  400598:	bd08      	pop	{r3, pc}
  40059a:	bf00      	nop

0040059c <sdio_cmd52>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
  40059c:	b510      	push	{r4, lr}
  40059e:	9c02      	ldr	r4, [sp, #8]
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
  4005a0:	ea4f 2242 	mov.w	r2, r2, lsl #9
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
  4005a4:	ea42 7101 	orr.w	r1, r2, r1, lsl #28
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
  4005a8:	ea41 70c0 	orr.w	r0, r1, r0, lsl #31
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
  4005ac:	ea40 63c3 	orr.w	r3, r0, r3, lsl #27
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
  4005b0:	7821      	ldrb	r1, [r4, #0]
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  4005b2:	f241 3034 	movw	r0, #4916	; 0x1334
  4005b6:	4319      	orrs	r1, r3
  4005b8:	f641 0345 	movw	r3, #6213	; 0x1845
  4005bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4005c0:	4798      	blx	r3
  4005c2:	b140      	cbz	r0, 4005d6 <sdio_cmd52+0x3a>
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
		return false;
	}
	*io_data = driver_get_response() & 0xFF;
  4005c4:	f641 0375 	movw	r3, #6261	; 0x1875
  4005c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4005cc:	4798      	blx	r3
  4005ce:	7020      	strb	r0, [r4, #0]
	return true;
  4005d0:	f04f 0001 	mov.w	r0, #1
  4005d4:	bd10      	pop	{r4, pc}
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
		return false;
  4005d6:	f04f 0000 	mov.w	r0, #0
	}
	*io_data = driver_get_response() & 0xFF;
	return true;
}
  4005da:	bd10      	pop	{r4, pc}

004005dc <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  4005dc:	b508      	push	{r3, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  4005de:	f240 435c 	movw	r3, #1116	; 0x45c
  4005e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4005e6:	681b      	ldr	r3, [r3, #0]
  4005e8:	8919      	ldrh	r1, [r3, #8]
  4005ea:	f641 3009 	movw	r0, #6921	; 0x1b09
  4005ee:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4005f2:	f641 0345 	movw	r3, #6213	; 0x1845
  4005f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4005fa:	4798      	blx	r3
  4005fc:	b170      	cbz	r0, 40061c <sd_mmc_cmd9_mci+0x40>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  4005fe:	f240 435c 	movw	r3, #1116	; 0x45c
  400602:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400606:	6818      	ldr	r0, [r3, #0]
  400608:	f100 000e 	add.w	r0, r0, #14
  40060c:	f641 037d 	movw	r3, #6269	; 0x187d
  400610:	f2c0 0340 	movt	r3, #64	; 0x40
  400614:	4798      	blx	r3
	return true;
  400616:	f04f 0001 	mov.w	r0, #1
  40061a:	bd08      	pop	{r3, pc}
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  40061c:	f04f 0000 	mov.w	r0, #0
	}
	driver_get_response_128(sd_mmc_card->csd);
	return true;
}
  400620:	bd08      	pop	{r3, pc}
  400622:	bf00      	nop

00400624 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  400624:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400626:	f240 4364 	movw	r3, #1124	; 0x464
  40062a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40062e:	f04f 0204 	mov.w	r2, #4
  400632:	729a      	strb	r2, [r3, #10]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400634:	f240 4362 	movw	r3, #1122	; 0x462
  400638:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40063c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  400640:	701a      	strb	r2, [r3, #0]
	driver_init();
  400642:	f241 7365 	movw	r3, #5989	; 0x1765
  400646:	f2c0 0340 	movt	r3, #64	; 0x40
  40064a:	4798      	blx	r3
  40064c:	bd08      	pop	{r3, pc}
  40064e:	bf00      	nop

00400650 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  400650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400654:	b095      	sub	sp, #84	; 0x54
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
  400656:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40065a:	f2c0 0340 	movt	r3, #64	; 0x40
  40065e:	4798      	blx	r3
  400660:	4604      	mov	r4, r0
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  400662:	2801      	cmp	r0, #1
  400664:	d006      	beq.n	400674 <sd_mmc_check+0x24>
		sd_mmc_deselect_slot();
  400666:	f240 537d 	movw	r3, #1405	; 0x57d
  40066a:	f2c0 0340 	movt	r3, #64	; 0x40
  40066e:	4798      	blx	r3
		return sd_mmc_err;
  400670:	f000 bd39 	b.w	4010e6 <sd_mmc_check+0xa96>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  400674:	f240 435c 	movw	r3, #1116	; 0x45c
  400678:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40067c:	681b      	ldr	r3, [r3, #0]
  40067e:	f04f 0201 	mov.w	r2, #1
  400682:	72da      	strb	r2, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  400684:	f04f 0500 	mov.w	r5, #0
  400688:	731d      	strb	r5, [r3, #12]
	sd_mmc_card->rca = 0;
  40068a:	811d      	strh	r5, [r3, #8]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  40068c:	f641 0321 	movw	r3, #6177	; 0x1821
  400690:	f2c0 0340 	movt	r3, #64	; 0x40
  400694:	4798      	blx	r3

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400696:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  40069a:	4629      	mov	r1, r5
  40069c:	f641 0345 	movw	r3, #6213	; 0x1845
  4006a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4006a4:	4798      	blx	r3
  4006a6:	2800      	cmp	r0, #0
  4006a8:	f000 849e 	beq.w	400fe8 <sd_mmc_check+0x998>
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  4006ac:	f245 5008 	movw	r0, #21768	; 0x5508
  4006b0:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  4006b4:	f641 0345 	movw	r3, #6213	; 0x1845
  4006b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4006bc:	4798      	blx	r3
  4006be:	2800      	cmp	r0, #0
  4006c0:	f000 84a0 	beq.w	401004 <sd_mmc_check+0x9b4>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  4006c4:	f641 0375 	movw	r3, #6261	; 0x1875
  4006c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4006cc:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  4006ce:	f1b0 3fff 	cmp.w	r0, #4294967295
  4006d2:	f000 849a 	beq.w	40100a <sd_mmc_check+0x9ba>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  4006d6:	ea4f 5000 	mov.w	r0, r0, lsl #20
  4006da:	ea4f 5010 	mov.w	r0, r0, lsr #20
  4006de:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  4006e2:	bf08      	it	eq
  4006e4:	2701      	moveq	r7, #1
	resp = driver_get_response();
	if (resp == 0xFFFFFFFF) {
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  4006e6:	f000 8492 	beq.w	40100e <sd_mmc_check+0x9be>
  4006ea:	f000 bc7d 	b.w	400fe8 <sd_mmc_check+0x998>
	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
		sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
		return true; // No error but card type not updated
	}
	resp = driver_get_response();
  4006ee:	f641 0375 	movw	r3, #6261	; 0x1875
  4006f2:	f2c0 0340 	movt	r3, #64	; 0x40
  4006f6:	4798      	blx	r3
  4006f8:	4601      	mov	r1, r0
	if ((resp & OCR_SDIO_NF) == 0) {
  4006fa:	f010 4fe0 	tst.w	r0, #1879048192	; 0x70000000
  4006fe:	f000 8492 	beq.w	401026 <sd_mmc_check+0x9d6>
  400702:	f241 3589 	movw	r5, #5001	; 0x1389
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  400706:	f244 5805 	movw	r8, #17669	; 0x4505
  40070a:	f641 0645 	movw	r6, #6213	; 0x1845
  40070e:	f2c0 0640 	movt	r6, #64	; 0x40
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400712:	f641 0975 	movw	r9, #6261	; 0x1875
  400716:	f2c0 0940 	movt	r9, #64	; 0x40
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  40071a:	4640      	mov	r0, r8
  40071c:	f401 11fc 	and.w	r1, r1, #2064384	; 0x1f8000
  400720:	47b0      	blx	r6
  400722:	2800      	cmp	r0, #0
  400724:	f000 8460 	beq.w	400fe8 <sd_mmc_check+0x998>
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400728:	47c8      	blx	r9
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
  40072a:	1e01      	subs	r1, r0, #0
  40072c:	db03      	blt.n	400736 <sd_mmc_check+0xe6>
			break;
		}
		if (cmd5_retry-- == 0) {
  40072e:	3d01      	subs	r5, #1
  400730:	d1f3      	bne.n	40071a <sd_mmc_check+0xca>
  400732:	f000 bc59 	b.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD5 Timeout on busy\n\r", __func__);
			return false;
		}
	}
	// Update card type at the end of busy
	if ((resp & OCR_SDIO_MP) > 0) {
  400736:	f011 6f00 	tst.w	r1, #134217728	; 0x8000000
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
  40073a:	f240 435c 	movw	r3, #1116	; 0x45c
  40073e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400742:	681b      	ldr	r3, [r3, #0]
  400744:	bf14      	ite	ne
  400746:	2205      	movne	r2, #5
	} else {
		sd_mmc_card->type = CARD_TYPE_SDIO;
  400748:	2204      	moveq	r2, #4
  40074a:	72da      	strb	r2, [r3, #11]
  40074c:	f000 bc6b 	b.w	401026 <sd_mmc_check+0x9d6>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400750:	f640 0535 	movw	r5, #2101	; 0x835
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400754:	f241 1937 	movw	r9, #4407	; 0x1137
  400758:	f04f 0800 	mov.w	r8, #0
  40075c:	f641 0645 	movw	r6, #6213	; 0x1845
  400760:	f2c0 0640 	movt	r6, #64	; 0x40
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400764:	f44f 4a00 	mov.w	sl, #32768	; 0x8000
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400768:	f641 0b75 	movw	fp, #6261	; 0x1875
  40076c:	f2c0 0b40 	movt	fp, #64	; 0x40
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400770:	4648      	mov	r0, r9
  400772:	4641      	mov	r1, r8
  400774:	47b0      	blx	r6
  400776:	2800      	cmp	r0, #0
  400778:	f000 8461 	beq.w	40103e <sd_mmc_check+0x9ee>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  40077c:	4651      	mov	r1, sl
  40077e:	f2c4 011f 	movt	r1, #16415	; 0x401f
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400782:	f244 5029 	movw	r0, #17705	; 0x4529
  400786:	2f00      	cmp	r7, #0
  400788:	bf08      	it	eq
  40078a:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  40078e:	47b0      	blx	r6
  400790:	2800      	cmp	r0, #0
  400792:	f000 8454 	beq.w	40103e <sd_mmc_check+0x9ee>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400796:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  400798:	2800      	cmp	r0, #0
  40079a:	da0e      	bge.n	4007ba <sd_mmc_check+0x16a>
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  40079c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
  4007a0:	f000 8478 	beq.w	401094 <sd_mmc_check+0xa44>
				sd_mmc_card->type |= CARD_TYPE_HC;
  4007a4:	f240 435c 	movw	r3, #1116	; 0x45c
  4007a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4007ac:	681b      	ldr	r3, [r3, #0]
  4007ae:	7ada      	ldrb	r2, [r3, #11]
  4007b0:	f042 0208 	orr.w	r2, r2, #8
  4007b4:	72da      	strb	r2, [r3, #11]
  4007b6:	f000 bc6d 	b.w	401094 <sd_mmc_check+0xa44>
			}
			break;
		}
		if (retry-- == 0) {
  4007ba:	3d01      	subs	r5, #1
  4007bc:	d1d8      	bne.n	400770 <sd_mmc_check+0x120>
  4007be:	f000 bc3e 	b.w	40103e <sd_mmc_check+0x9ee>
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4007c2:	f241 0569 	movw	r5, #4201	; 0x1069
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4007c6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
  4007ca:	f2c4 061f 	movt	r6, #16415	; 0x401f
  4007ce:	f244 5801 	movw	r8, #17665	; 0x4501
  4007d2:	f641 0745 	movw	r7, #6213	; 0x1845
  4007d6:	f2c0 0740 	movt	r7, #64	; 0x40
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4007da:	f641 0975 	movw	r9, #6261	; 0x1875
  4007de:	f2c0 0940 	movt	r9, #64	; 0x40
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4007e2:	4640      	mov	r0, r8
  4007e4:	4631      	mov	r1, r6
  4007e6:	47b8      	blx	r7
  4007e8:	2800      	cmp	r0, #0
  4007ea:	f000 8468 	beq.w	4010be <sd_mmc_check+0xa6e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4007ee:	47c8      	blx	r9
		if (resp & OCR_POWER_UP_BUSY) {
  4007f0:	2800      	cmp	r0, #0
  4007f2:	da0d      	bge.n	400810 <sd_mmc_check+0x1c0>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  4007f4:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  4007f8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  4007fc:	f040 8455 	bne.w	4010aa <sd_mmc_check+0xa5a>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  400800:	4ba2      	ldr	r3, [pc, #648]	; (400a8c <sd_mmc_check+0x43c>)
  400802:	681b      	ldr	r3, [r3, #0]
  400804:	7ada      	ldrb	r2, [r3, #11]
  400806:	f042 0208 	orr.w	r2, r2, #8
  40080a:	72da      	strb	r2, [r3, #11]
  40080c:	f000 bc4d 	b.w	4010aa <sd_mmc_check+0xa5a>
			}
			break;
		}
		if (retry-- == 0) {
  400810:	3d01      	subs	r5, #1
  400812:	d1e6      	bne.n	4007e2 <sd_mmc_check+0x192>
  400814:	f000 bc53 	b.w	4010be <sd_mmc_check+0xa6e>
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  400818:	4b9c      	ldr	r3, [pc, #624]	; (400a8c <sd_mmc_check+0x43c>)
  40081a:	681b      	ldr	r3, [r3, #0]
  40081c:	f04f 0201 	mov.w	r2, #1
  400820:	811a      	strh	r2, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  400822:	f241 1003 	movw	r0, #4355	; 0x1103
  400826:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  40082a:	4b99      	ldr	r3, [pc, #612]	; (400a90 <sd_mmc_check+0x440>)
  40082c:	4798      	blx	r3
  40082e:	2800      	cmp	r0, #0
  400830:	f000 8120 	beq.w	400a74 <sd_mmc_check+0x424>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  400834:	4b97      	ldr	r3, [pc, #604]	; (400a94 <sd_mmc_check+0x444>)
  400836:	4798      	blx	r3
  400838:	2800      	cmp	r0, #0
  40083a:	f000 811e 	beq.w	400a7a <sd_mmc_check+0x42a>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  40083e:	4b93      	ldr	r3, [pc, #588]	; (400a8c <sd_mmc_check+0x43c>)
  400840:	681b      	ldr	r3, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400842:	7b9a      	ldrb	r2, [r3, #14]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400844:	f3c2 0283 	ubfx	r2, r2, #2, #4
  400848:	f102 32ff 	add.w	r2, r2, #4294967295
  40084c:	2a03      	cmp	r2, #3
  40084e:	d803      	bhi.n	400858 <sd_mmc_check+0x208>
  400850:	e8df f002 	tbb	[pc, r2]
  400854:	120e0a06 	.word	0x120e0a06
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  400858:	f04f 0212 	mov.w	r2, #18
  40085c:	731a      	strb	r2, [r3, #12]
  40085e:	e00e      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  400860:	f04f 0214 	mov.w	r2, #20
  400864:	731a      	strb	r2, [r3, #12]
  400866:	e00a      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  400868:	f04f 0222 	mov.w	r2, #34	; 0x22
  40086c:	731a      	strb	r2, [r3, #12]
  40086e:	e006      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  400870:	f04f 0230 	mov.w	r2, #48	; 0x30
  400874:	731a      	strb	r2, [r3, #12]
  400876:	e002      	b.n	40087e <sd_mmc_check+0x22e>
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  400878:	f04f 0240 	mov.w	r2, #64	; 0x40
  40087c:	731a      	strb	r2, [r3, #12]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40087e:	7c5a      	ldrb	r2, [r3, #17]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400880:	f002 0007 	and.w	r0, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400884:	4984      	ldr	r1, [pc, #528]	; (400a98 <sd_mmc_check+0x448>)
  400886:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  40088a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  40088e:	fb00 f101 	mul.w	r1, r0, r1
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  400892:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400896:	4881      	ldr	r0, [pc, #516]	; (400a9c <sd_mmc_check+0x44c>)
  400898:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
  40089c:	fb02 f201 	mul.w	r2, r2, r1
  4008a0:	601a      	str	r2, [r3, #0]
  4008a2:	7d99      	ldrb	r1, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008a4:	7d18      	ldrb	r0, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4008a6:	7d5a      	ldrb	r2, [r3, #21]
  4008a8:	ea4f 0282 	mov.w	r2, r2, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008ac:	ea42 2280 	orr.w	r2, r2, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4008b0:	ea42 12a1 	orr.w	r2, r2, r1, asr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  4008b4:	ea4f 5202 	mov.w	r2, r2, lsl #20
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  4008b8:	ea4f 5112 	mov.w	r1, r2, lsr #20
  4008bc:	f512 1f80 	cmn.w	r2, #1048576	; 0x100000
  4008c0:	d015      	beq.n	4008ee <sd_mmc_check+0x29e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4008c2:	7e18      	ldrb	r0, [r3, #24]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4008c4:	7dda      	ldrb	r2, [r3, #23]
  4008c6:	ea4f 0242 	mov.w	r2, r2, lsl #1
  4008ca:	ea42 12e0 	orr.w	r2, r2, r0, asr #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4008ce:	f101 0101 	add.w	r1, r1, #1
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4008d2:	f002 0207 	and.w	r2, r2, #7
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4008d6:	f102 0202 	add.w	r2, r2, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4008da:	fa01 f102 	lsl.w	r1, r1, r2
  4008de:	7cda      	ldrb	r2, [r3, #19]
  4008e0:	f002 020f 	and.w	r2, r2, #15
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4008e4:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4008e8:	ea4f 2292 	mov.w	r2, r2, lsr #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4008ec:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4008ee:	8919      	ldrh	r1, [r3, #8]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4008f0:	f243 1007 	movw	r0, #12551	; 0x3107
  4008f4:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4008f8:	4b65      	ldr	r3, [pc, #404]	; (400a90 <sd_mmc_check+0x440>)
  4008fa:	4798      	blx	r3
  4008fc:	2800      	cmp	r0, #0
  4008fe:	f000 80bf 	beq.w	400a80 <sd_mmc_check+0x430>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  400902:	4b62      	ldr	r3, [pc, #392]	; (400a8c <sd_mmc_check+0x43c>)
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	7b1b      	ldrb	r3, [r3, #12]
  400908:	2b3f      	cmp	r3, #63	; 0x3f
  40090a:	f240 809b 	bls.w	400a44 <sd_mmc_check+0x3f4>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  40090e:	f04f 0100 	mov.w	r1, #0
  400912:	9100      	str	r1, [sp, #0]
  400914:	f241 1008 	movw	r0, #4360	; 0x1108
  400918:	f2c0 0008 	movt	r0, #8
  40091c:	f44f 7200 	mov.w	r2, #512	; 0x200
  400920:	f04f 0301 	mov.w	r3, #1
  400924:	4d5e      	ldr	r5, [pc, #376]	; (400aa0 <sd_mmc_check+0x450>)
  400926:	47a8      	blx	r5
  400928:	2800      	cmp	r0, #0
  40092a:	f000 83cb 	beq.w	4010c4 <sd_mmc_check+0xa74>
  40092e:	f04f 0500 	mov.w	r5, #0
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  400932:	4e5c      	ldr	r6, [pc, #368]	; (400aa4 <sd_mmc_check+0x454>)
  400934:	a802      	add	r0, sp, #8
  400936:	47b0      	blx	r6
  400938:	2800      	cmp	r0, #0
  40093a:	f000 83c3 	beq.w	4010c4 <sd_mmc_check+0xa74>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  40093e:	f105 0501 	add.w	r5, r5, #1
  400942:	b2ad      	uxth	r5, r5
  400944:	2d32      	cmp	r5, #50	; 0x32
  400946:	d1f5      	bne.n	400934 <sd_mmc_check+0x2e4>
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400948:	9b02      	ldr	r3, [sp, #8]
  40094a:	f003 0302 	and.w	r3, r3, #2
  40094e:	b2de      	uxtb	r6, r3
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400950:	4b4e      	ldr	r3, [pc, #312]	; (400a8c <sd_mmc_check+0x43c>)
  400952:	681b      	ldr	r3, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400954:	7d9a      	ldrb	r2, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400956:	7d19      	ldrb	r1, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400958:	7d5b      	ldrb	r3, [r3, #21]
  40095a:	ea4f 0383 	mov.w	r3, r3, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40095e:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400962:	ea43 13a2 	orr.w	r3, r3, r2, asr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  400966:	ea4f 5303 	mov.w	r3, r3, lsl #20
  40096a:	f513 1f80 	cmn.w	r3, #1048576	; 0x100000
  40096e:	d11a      	bne.n	4009a6 <sd_mmc_check+0x356>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  400970:	4f4c      	ldr	r7, [pc, #304]	; (400aa4 <sd_mmc_check+0x454>)
  400972:	a803      	add	r0, sp, #12
  400974:	47b8      	blx	r7
  400976:	2800      	cmp	r0, #0
  400978:	f000 83a4 	beq.w	4010c4 <sd_mmc_check+0xa74>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  40097c:	f105 0501 	add.w	r5, r5, #1
  400980:	b2ad      	uxth	r5, r5
  400982:	2d35      	cmp	r5, #53	; 0x35
  400984:	d9f5      	bls.n	400972 <sd_mmc_check+0x322>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  400986:	4b41      	ldr	r3, [pc, #260]	; (400a8c <sd_mmc_check+0x43c>)
  400988:	681a      	ldr	r2, [r3, #0]
  40098a:	9b03      	ldr	r3, [sp, #12]
  40098c:	ea4f 0353 	mov.w	r3, r3, lsr #1
  400990:	6053      	str	r3, [r2, #4]
  400992:	e008      	b.n	4009a6 <sd_mmc_check+0x356>
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  400994:	a803      	add	r0, sp, #12
  400996:	47b8      	blx	r7
  400998:	2800      	cmp	r0, #0
  40099a:	f000 8393 	beq.w	4010c4 <sd_mmc_check+0xa74>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  40099e:	f105 0501 	add.w	r5, r5, #1
  4009a2:	b2ad      	uxth	r5, r5
  4009a4:	e000      	b.n	4009a8 <sd_mmc_check+0x358>
		if (!driver_read_word(&sec_count)) {
  4009a6:	4f3f      	ldr	r7, [pc, #252]	; (400aa4 <sd_mmc_check+0x454>)
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  4009a8:	2d7f      	cmp	r5, #127	; 0x7f
  4009aa:	d9f3      	bls.n	400994 <sd_mmc_check+0x344>
  4009ac:	e38d      	b.n	4010ca <sd_mmc_check+0xa7a>
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  4009ae:	4b3e      	ldr	r3, [pc, #248]	; (400aa8 <sd_mmc_check+0x458>)
  4009b0:	7818      	ldrb	r0, [r3, #0]
  4009b2:	4b3e      	ldr	r3, [pc, #248]	; (400aac <sd_mmc_check+0x45c>)
  4009b4:	4798      	blx	r3
  4009b6:	4605      	mov	r5, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  4009b8:	2804      	cmp	r0, #4
  4009ba:	d00b      	beq.n	4009d4 <sd_mmc_check+0x384>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4009bc:	f44f 7100 	mov.w	r1, #512	; 0x200
  4009c0:	f2c0 11b7 	movt	r1, #439	; 0x1b7
  4009c4:	f04f 0300 	mov.w	r3, #0
  4009c8:	f2c0 13b7 	movt	r3, #439	; 0x1b7
  4009cc:	2808      	cmp	r0, #8
  4009ce:	bf18      	it	ne
  4009d0:	4619      	movne	r1, r3
  4009d2:	e003      	b.n	4009dc <sd_mmc_check+0x38c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4009d4:	f44f 7180 	mov.w	r1, #256	; 0x100
  4009d8:	f2c0 11b7 	movt	r1, #439	; 0x1b7
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  4009dc:	f243 1006 	movw	r0, #12550	; 0x3106
  4009e0:	4b2b      	ldr	r3, [pc, #172]	; (400a90 <sd_mmc_check+0x440>)
  4009e2:	4798      	blx	r3
  4009e4:	2800      	cmp	r0, #0
  4009e6:	f000 8378 	beq.w	4010da <sd_mmc_check+0xa8a>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  4009ea:	4b31      	ldr	r3, [pc, #196]	; (400ab0 <sd_mmc_check+0x460>)
  4009ec:	4798      	blx	r3
  4009ee:	f010 0f80 	tst.w	r0, #128	; 0x80
  4009f2:	f040 8372 	bne.w	4010da <sd_mmc_check+0xa8a>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  4009f6:	4b25      	ldr	r3, [pc, #148]	; (400a8c <sd_mmc_check+0x43c>)
  4009f8:	681b      	ldr	r3, [r3, #0]
  4009fa:	735d      	strb	r5, [r3, #13]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  4009fc:	4b2d      	ldr	r3, [pc, #180]	; (400ab4 <sd_mmc_check+0x464>)
  4009fe:	4798      	blx	r3
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  400a00:	4b2d      	ldr	r3, [pc, #180]	; (400ab8 <sd_mmc_check+0x468>)
  400a02:	4798      	blx	r3
  400a04:	b330      	cbz	r0, 400a54 <sd_mmc_check+0x404>
  400a06:	b32e      	cbz	r6, 400a54 <sd_mmc_check+0x404>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  400a08:	f243 1006 	movw	r0, #12550	; 0x3106
  400a0c:	f44f 7180 	mov.w	r1, #256	; 0x100
  400a10:	f2c0 31b9 	movt	r1, #953	; 0x3b9
  400a14:	4b1e      	ldr	r3, [pc, #120]	; (400a90 <sd_mmc_check+0x440>)
  400a16:	4798      	blx	r3
  400a18:	2800      	cmp	r0, #0
  400a1a:	f000 8361 	beq.w	4010e0 <sd_mmc_check+0xa90>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400a1e:	4b24      	ldr	r3, [pc, #144]	; (400ab0 <sd_mmc_check+0x460>)
  400a20:	4798      	blx	r3
  400a22:	f010 0f80 	tst.w	r0, #128	; 0x80
  400a26:	f040 835b 	bne.w	4010e0 <sd_mmc_check+0xa90>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400a2a:	4b18      	ldr	r3, [pc, #96]	; (400a8c <sd_mmc_check+0x43c>)
  400a2c:	681b      	ldr	r3, [r3, #0]
  400a2e:	f04f 0201 	mov.w	r2, #1
  400a32:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock = 52000000lu;
  400a34:	f44f 42ea 	mov.w	r2, #29952	; 0x7500
  400a38:	f2c0 3219 	movt	r2, #793	; 0x319
  400a3c:	601a      	str	r2, [r3, #0]
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  400a3e:	4b1d      	ldr	r3, [pc, #116]	; (400ab4 <sd_mmc_check+0x464>)
  400a40:	4798      	blx	r3
  400a42:	e007      	b.n	400a54 <sd_mmc_check+0x404>
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  400a44:	4b1b      	ldr	r3, [pc, #108]	; (400ab4 <sd_mmc_check+0x464>)
  400a46:	4798      	blx	r3
  400a48:	e004      	b.n	400a54 <sd_mmc_check+0x404>
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400a4a:	4640      	mov	r0, r8
  400a4c:	4639      	mov	r1, r7
  400a4e:	47b0      	blx	r6
  400a50:	b140      	cbz	r0, 400a64 <sd_mmc_check+0x414>
  400a52:	e018      	b.n	400a86 <sd_mmc_check+0x436>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400a54:	f04f 050a 	mov.w	r5, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400a58:	f241 1810 	movw	r8, #4368	; 0x1110
  400a5c:	f44f 7700 	mov.w	r7, #512	; 0x200
  400a60:	4e0b      	ldr	r6, [pc, #44]	; (400a90 <sd_mmc_check+0x440>)
  400a62:	e7f2      	b.n	400a4a <sd_mmc_check+0x3fa>
  400a64:	f105 35ff 	add.w	r5, r5, #4294967295
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  400a68:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
  400a6c:	d1ed      	bne.n	400a4a <sd_mmc_check+0x3fa>
		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
			return true;
		}
	}
	return false;
  400a6e:	f04f 0000 	mov.w	r0, #0
  400a72:	e2aa      	b.n	400fca <sd_mmc_check+0x97a>
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  400a74:	f04f 0000 	mov.w	r0, #0
  400a78:	e2a7      	b.n	400fca <sd_mmc_check+0x97a>
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
		return false;
  400a7a:	f04f 0000 	mov.w	r0, #0
  400a7e:	e2a4      	b.n	400fca <sd_mmc_check+0x97a>
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
  400a80:	f04f 0000 	mov.w	r0, #0
  400a84:	e2a1      	b.n	400fca <sd_mmc_check+0x97a>
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
			return true;
  400a86:	f04f 0001 	mov.w	r0, #1
  400a8a:	e29e      	b.n	400fca <sd_mmc_check+0x97a>
  400a8c:	2000045c 	.word	0x2000045c
  400a90:	00401845 	.word	0x00401845
  400a94:	004005dd 	.word	0x004005dd
  400a98:	004044f4 	.word	0x004044f4
  400a9c:	00404510 	.word	0x00404510
  400aa0:	004018a9 	.word	0x004018a9
  400aa4:	0040197d 	.word	0x0040197d
  400aa8:	20000462 	.word	0x20000462
  400aac:	00401795 	.word	0x00401795
  400ab0:	00401875 	.word	0x00401875
  400ab4:	0040047d 	.word	0x0040047d
  400ab8:	004017a1 	.word	0x004017a1
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  400abc:	f645 3002 	movw	r0, #23298	; 0x5b02
  400ac0:	f04f 0100 	mov.w	r1, #0
  400ac4:	f641 0345 	movw	r3, #6213	; 0x1845
  400ac8:	f2c0 0340 	movt	r3, #64	; 0x40
  400acc:	4798      	blx	r3
  400ace:	2800      	cmp	r0, #0
  400ad0:	f000 828a 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  400ad4:	f245 1003 	movw	r0, #20739	; 0x5103
  400ad8:	f04f 0100 	mov.w	r1, #0
  400adc:	f641 0345 	movw	r3, #6213	; 0x1845
  400ae0:	f2c0 0340 	movt	r3, #64	; 0x40
  400ae4:	4798      	blx	r3
  400ae6:	2800      	cmp	r0, #0
  400ae8:	f000 827e 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  400aec:	f240 455c 	movw	r5, #1116	; 0x45c
  400af0:	f2c2 0500 	movt	r5, #8192	; 0x2000
  400af4:	682e      	ldr	r6, [r5, #0]
  400af6:	f641 0375 	movw	r3, #6261	; 0x1875
  400afa:	f2c0 0340 	movt	r3, #64	; 0x40
  400afe:	4798      	blx	r3
  400b00:	ea4f 4010 	mov.w	r0, r0, lsr #16
  400b04:	8130      	strh	r0, [r6, #8]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400b06:	682b      	ldr	r3, [r5, #0]
  400b08:	7adb      	ldrb	r3, [r3, #11]
  400b0a:	f013 0f01 	tst.w	r3, #1
  400b0e:	d056      	beq.n	400bbe <sd_mmc_check+0x56e>
		if (!sd_mmc_cmd9_mci()) {
  400b10:	f240 53dd 	movw	r3, #1501	; 0x5dd
  400b14:	f2c0 0340 	movt	r3, #64	; 0x40
  400b18:	4798      	blx	r3
  400b1a:	2800      	cmp	r0, #0
  400b1c:	f000 8264 	beq.w	400fe8 <sd_mmc_check+0x998>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  400b20:	682b      	ldr	r3, [r5, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b22:	7c59      	ldrb	r1, [r3, #17]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400b24:	f244 42f4 	movw	r2, #17652	; 0x44f4
  400b28:	f2c0 0240 	movt	r2, #64	; 0x40
  400b2c:	f001 0007 	and.w	r0, r1, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400b30:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
  400b34:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  400b38:	fb00 f002 	mul.w	r0, r0, r2
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  400b3c:	f244 42b4 	movw	r2, #17588	; 0x44b4
  400b40:	f2c0 0240 	movt	r2, #64	; 0x40
  400b44:	f3c1 01c3 	ubfx	r1, r1, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400b48:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  400b4c:	fb02 f200 	mul.w	r2, r2, r0
  400b50:	601a      	str	r2, [r3, #0]
  400b52:	7b9a      	ldrb	r2, [r3, #14]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400b54:	0992      	lsrs	r2, r2, #6
  400b56:	d00f      	beq.n	400b78 <sd_mmc_check+0x528>
  400b58:	7dda      	ldrb	r2, [r3, #23]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b5a:	7d98      	ldrb	r0, [r3, #22]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b5c:	7d59      	ldrb	r1, [r3, #21]
  400b5e:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400b62:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400b66:	430a      	orrs	r2, r1
  400b68:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  400b6c:	f102 0201 	add.w	r2, r2, #1
  400b70:	ea4f 2242 	mov.w	r2, r2, lsl #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  400b74:	605a      	str	r2, [r3, #4]
  400b76:	e022      	b.n	400bbe <sd_mmc_check+0x56e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b78:	7d99      	ldrb	r1, [r3, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b7a:	7d18      	ldrb	r0, [r3, #20]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b7c:	7d5a      	ldrb	r2, [r3, #21]
  400b7e:	ea4f 0282 	mov.w	r2, r2, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b82:	ea42 2280 	orr.w	r2, r2, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b86:	ea42 12a1 	orr.w	r2, r2, r1, asr #6
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400b8a:	7e18      	ldrb	r0, [r3, #24]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400b8c:	7dd9      	ldrb	r1, [r3, #23]
  400b8e:	ea4f 0141 	mov.w	r1, r1, lsl #1
  400b92:	ea41 11e0 	orr.w	r1, r1, r0, asr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400b96:	ea4f 5202 	mov.w	r2, r2, lsl #20
  400b9a:	ea4f 5212 	mov.w	r2, r2, lsr #20
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400b9e:	f102 0201 	add.w	r2, r2, #1
  400ba2:	f001 0107 	and.w	r1, r1, #7
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400ba6:	f101 0102 	add.w	r1, r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400baa:	fa02 f101 	lsl.w	r1, r2, r1
  400bae:	7cda      	ldrb	r2, [r3, #19]
  400bb0:	f002 020f 	and.w	r2, r2, #15
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400bb4:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  400bb8:	ea4f 2292 	mov.w	r2, r2, lsr #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400bbc:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  400bbe:	f240 435c 	movw	r3, #1116	; 0x45c
  400bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bc6:	681b      	ldr	r3, [r3, #0]
  400bc8:	8919      	ldrh	r1, [r3, #8]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400bca:	f243 1007 	movw	r0, #12551	; 0x3107
  400bce:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400bd2:	f641 0345 	movw	r3, #6213	; 0x1845
  400bd6:	f2c0 0340 	movt	r3, #64	; 0x40
  400bda:	4798      	blx	r3
  400bdc:	2800      	cmp	r0, #0
  400bde:	f000 8203 	beq.w	400fe8 <sd_mmc_check+0x998>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400be2:	f240 435c 	movw	r3, #1116	; 0x45c
  400be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400bea:	681b      	ldr	r3, [r3, #0]
  400bec:	7ada      	ldrb	r2, [r3, #11]
  400bee:	f012 0f01 	tst.w	r2, #1
  400bf2:	d04e      	beq.n	400c92 <sd_mmc_check+0x642>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400bf4:	8919      	ldrh	r1, [r3, #8]
  400bf6:	f241 1037 	movw	r0, #4407	; 0x1137
  400bfa:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400bfe:	f641 0345 	movw	r3, #6213	; 0x1845
  400c02:	f2c0 0340 	movt	r3, #64	; 0x40
  400c06:	4798      	blx	r3
  400c08:	2800      	cmp	r0, #0
  400c0a:	f000 81ed 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  400c0e:	f04f 0301 	mov.w	r3, #1
  400c12:	9300      	str	r3, [sp, #0]
  400c14:	f241 1033 	movw	r0, #4403	; 0x1133
  400c18:	f2c0 0008 	movt	r0, #8
  400c1c:	f04f 0100 	mov.w	r1, #0
  400c20:	f04f 0208 	mov.w	r2, #8
  400c24:	4d4c      	ldr	r5, [pc, #304]	; (400d58 <sd_mmc_check+0x708>)
  400c26:	47a8      	blx	r5
  400c28:	2800      	cmp	r0, #0
  400c2a:	f000 81dd 	beq.w	400fe8 <sd_mmc_check+0x998>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  400c2e:	a804      	add	r0, sp, #16
  400c30:	f04f 0101 	mov.w	r1, #1
  400c34:	4b49      	ldr	r3, [pc, #292]	; (400d5c <sd_mmc_check+0x70c>)
  400c36:	4798      	blx	r3
  400c38:	2800      	cmp	r0, #0
  400c3a:	f000 81d5 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400c3e:	4b48      	ldr	r3, [pc, #288]	; (400d60 <sd_mmc_check+0x710>)
  400c40:	4798      	blx	r3
  400c42:	2800      	cmp	r0, #0
  400c44:	f000 81d0 	beq.w	400fe8 <sd_mmc_check+0x998>
  400c48:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  400c4c:	f003 030f 	and.w	r3, r3, #15
  400c50:	2b01      	cmp	r3, #1
  400c52:	d009      	beq.n	400c68 <sd_mmc_check+0x618>
  400c54:	b113      	cbz	r3, 400c5c <sd_mmc_check+0x60c>
  400c56:	2b02      	cmp	r3, #2
  400c58:	d116      	bne.n	400c88 <sd_mmc_check+0x638>
  400c5a:	e00b      	b.n	400c74 <sd_mmc_check+0x624>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c5c:	4b41      	ldr	r3, [pc, #260]	; (400d64 <sd_mmc_check+0x714>)
  400c5e:	681b      	ldr	r3, [r3, #0]
  400c60:	f04f 0210 	mov.w	r2, #16
  400c64:	731a      	strb	r2, [r3, #12]
  400c66:	e014      	b.n	400c92 <sd_mmc_check+0x642>
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  400c68:	4b3e      	ldr	r3, [pc, #248]	; (400d64 <sd_mmc_check+0x714>)
  400c6a:	681b      	ldr	r3, [r3, #0]
  400c6c:	f04f 021a 	mov.w	r2, #26
  400c70:	731a      	strb	r2, [r3, #12]
  400c72:	e00e      	b.n	400c92 <sd_mmc_check+0x642>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400c74:	f89d 3012 	ldrb.w	r3, [sp, #18]
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  400c78:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  400c7a:	4b3a      	ldr	r3, [pc, #232]	; (400d64 <sd_mmc_check+0x714>)
  400c7c:	681b      	ldr	r3, [r3, #0]
  400c7e:	bf14      	ite	ne
  400c80:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  400c82:	2220      	moveq	r2, #32
  400c84:	731a      	strb	r2, [r3, #12]
  400c86:	e004      	b.n	400c92 <sd_mmc_check+0x642>
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400c88:	4b36      	ldr	r3, [pc, #216]	; (400d64 <sd_mmc_check+0x714>)
  400c8a:	681b      	ldr	r3, [r3, #0]
  400c8c:	f04f 0210 	mov.w	r2, #16
  400c90:	731a      	strb	r2, [r3, #12]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!sd_acmd51()) {
			return false;
		}
	}
	if (IS_SDIO()) {
  400c92:	f240 435c 	movw	r3, #1116	; 0x45c
  400c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400c9a:	681b      	ldr	r3, [r3, #0]
  400c9c:	7adb      	ldrb	r3, [r3, #11]
  400c9e:	f003 0304 	and.w	r3, r3, #4
  400ca2:	b2db      	uxtb	r3, r3
  400ca4:	2b00      	cmp	r3, #0
  400ca6:	f000 8095 	beq.w	400dd4 <sd_mmc_check+0x784>
 	uint32_t unit;
	uint32_t mul;
	uint8_t tplfe_max_tran_speed;

	// Read CIS area address in CCCR area
	addr_cis = 0; // Init all bytes, because the next function fill 3 bytes only
  400caa:	f04f 0100 	mov.w	r1, #0
  400cae:	9103      	str	r1, [sp, #12]
	if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, SDIO_CCCR_CIS_PTR,
  400cb0:	f04f 0303 	mov.w	r3, #3
  400cb4:	9300      	str	r3, [sp, #0]
  400cb6:	f04f 0301 	mov.w	r3, #1
  400cba:	9301      	str	r3, [sp, #4]
  400cbc:	4608      	mov	r0, r1
  400cbe:	f04f 0209 	mov.w	r2, #9
  400cc2:	f240 5529 	movw	r5, #1321	; 0x529
  400cc6:	f2c0 0540 	movt	r5, #64	; 0x40
  400cca:	47a8      	blx	r5
  400ccc:	2800      	cmp	r0, #0
  400cce:	f000 818b 	beq.w	400fe8 <sd_mmc_check+0x998>
			1, 3, true)) {
		sd_mmc_debug("%s: CMD53 Read CIS Fail\n\r", __func__);
		return false;
	}
	if (!driver_start_read_blocks((uint8_t *)&addr_cis, 1)) {
  400cd2:	a803      	add	r0, sp, #12
  400cd4:	f04f 0101 	mov.w	r1, #1
  400cd8:	4b20      	ldr	r3, [pc, #128]	; (400d5c <sd_mmc_check+0x70c>)
  400cda:	4798      	blx	r3
  400cdc:	2800      	cmp	r0, #0
  400cde:	f000 8183 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400ce2:	4b1f      	ldr	r3, [pc, #124]	; (400d60 <sd_mmc_check+0x710>)
  400ce4:	4798      	blx	r3
  400ce6:	2800      	cmp	r0, #0
  400ce8:	f000 817e 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	addr_cis = le32_to_cpu(addr_cis);
  400cec:	9d03      	ldr	r5, [sp, #12]

	// Search Fun0 tuple in the CIA area
	addr = addr_cis;
	while (1) {
		// Read a sample of CIA area
		if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 3, true)) {
  400cee:	f8df 8078 	ldr.w	r8, [pc, #120]	; 400d68 <sd_mmc_check+0x718>
			sd_mmc_debug("%s: CMD53 Read CIA Fail\n\r", __func__);
			return false;
		}
		if (!driver_start_read_blocks(buf, 1)) {
  400cf2:	4f1a      	ldr	r7, [pc, #104]	; (400d5c <sd_mmc_check+0x70c>)
			return false;
		}
		if (!driver_wait_end_of_read_blocks()) {
  400cf4:	4e1a      	ldr	r6, [pc, #104]	; (400d60 <sd_mmc_check+0x710>)

	// Search Fun0 tuple in the CIA area
	addr = addr_cis;
	while (1) {
		// Read a sample of CIA area
		if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 3, true)) {
  400cf6:	f04f 0303 	mov.w	r3, #3
  400cfa:	9300      	str	r3, [sp, #0]
  400cfc:	f04f 0301 	mov.w	r3, #1
  400d00:	9301      	str	r3, [sp, #4]
  400d02:	f04f 0000 	mov.w	r0, #0
  400d06:	4601      	mov	r1, r0
  400d08:	462a      	mov	r2, r5
  400d0a:	47c0      	blx	r8
  400d0c:	2800      	cmp	r0, #0
  400d0e:	f000 816b 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Read CIA Fail\n\r", __func__);
			return false;
		}
		if (!driver_start_read_blocks(buf, 1)) {
  400d12:	a804      	add	r0, sp, #16
  400d14:	f04f 0101 	mov.w	r1, #1
  400d18:	47b8      	blx	r7
  400d1a:	2800      	cmp	r0, #0
  400d1c:	f000 8164 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
		if (!driver_wait_end_of_read_blocks()) {
  400d20:	47b0      	blx	r6
  400d22:	2800      	cmp	r0, #0
  400d24:	f000 8160 	beq.w	400fe8 <sd_mmc_check+0x998>
			return false;
		}
		if (buf[0] == SDIO_CISTPL_END) {
  400d28:	f89d 3010 	ldrb.w	r3, [sp, #16]
  400d2c:	2bff      	cmp	r3, #255	; 0xff
  400d2e:	f000 815b 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Tuple error\n\r", __func__);
			return false; // Tuple error
		}
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
  400d32:	2b22      	cmp	r3, #34	; 0x22
  400d34:	d102      	bne.n	400d3c <sd_mmc_check+0x6ec>
  400d36:	f89d 3012 	ldrb.w	r3, [sp, #18]
  400d3a:	b1bb      	cbz	r3, 400d6c <sd_mmc_check+0x71c>
			break; // Fun0 tuple found
		}
		if (buf[1] == 0) {
  400d3c:	f89d 3011 	ldrb.w	r3, [sp, #17]
  400d40:	2b00      	cmp	r3, #0
  400d42:	f000 8151 	beq.w	400fe8 <sd_mmc_check+0x998>
			sd_mmc_debug("%s: CMD53 Tuple error\n\r", __func__);
			return false; // Tuple error
		}

		// Next address
		addr += (buf[1] + 2);
  400d46:	f103 0302 	add.w	r3, r3, #2
  400d4a:	18ed      	adds	r5, r5, r3
		if (addr > (addr_cis + 256)) {
  400d4c:	9b03      	ldr	r3, [sp, #12]
  400d4e:	f503 7380 	add.w	r3, r3, #256	; 0x100
  400d52:	429d      	cmp	r5, r3
  400d54:	d9cf      	bls.n	400cf6 <sd_mmc_check+0x6a6>
  400d56:	e147      	b.n	400fe8 <sd_mmc_check+0x998>
  400d58:	004018a9 	.word	0x004018a9
  400d5c:	00401a11 	.word	0x00401a11
  400d60:	00401a5d 	.word	0x00401a5d
  400d64:	2000045c 	.word	0x2000045c
  400d68:	00400529 	.word	0x00400529
			return false; // Outoff CIS area
		}
	}

	// Read all Fun0 tuple fields: fn0_blk_siz & max_tran_speed
	if (!sdio_cmd53(SDIO_CMD53_READ_FLAG, SDIO_CIA, addr, 1, 6, true)) {
  400d6c:	f04f 0306 	mov.w	r3, #6
  400d70:	9300      	str	r3, [sp, #0]
  400d72:	f04f 0301 	mov.w	r3, #1
  400d76:	9301      	str	r3, [sp, #4]
  400d78:	f04f 0000 	mov.w	r0, #0
  400d7c:	4601      	mov	r1, r0
  400d7e:	462a      	mov	r2, r5
  400d80:	4db9      	ldr	r5, [pc, #740]	; (401068 <sd_mmc_check+0xa18>)
  400d82:	47a8      	blx	r5
  400d84:	2800      	cmp	r0, #0
  400d86:	f000 812f 	beq.w	400fe8 <sd_mmc_check+0x998>
		sd_mmc_debug("%s: CMD53 Read all Fun0 Fail\n\r", __func__);
		return false;
	}
	if (!driver_start_read_blocks(buf, 1)) {
  400d8a:	a804      	add	r0, sp, #16
  400d8c:	f04f 0101 	mov.w	r1, #1
  400d90:	4bb6      	ldr	r3, [pc, #728]	; (40106c <sd_mmc_check+0xa1c>)
  400d92:	4798      	blx	r3
  400d94:	2800      	cmp	r0, #0
  400d96:	f000 8127 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400d9a:	4bb5      	ldr	r3, [pc, #724]	; (401070 <sd_mmc_check+0xa20>)
  400d9c:	4798      	blx	r3
  400d9e:	2800      	cmp	r0, #0
  400da0:	f000 8122 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	tplfe_max_tran_speed = buf[5];
  400da4:	f89d 3015 	ldrb.w	r3, [sp, #21]
  400da8:	2b32      	cmp	r3, #50	; 0x32
  400daa:	bf28      	it	cs
  400dac:	2332      	movcs	r3, #50	; 0x32
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400dae:	4ab1      	ldr	r2, [pc, #708]	; (401074 <sd_mmc_check+0xa24>)
  400db0:	6812      	ldr	r2, [r2, #0]
		 */
		tplfe_max_tran_speed = 0x32; // 25Mhz
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
  400db2:	f003 0007 	and.w	r0, r3, #7
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400db6:	49b0      	ldr	r1, [pc, #704]	; (401078 <sd_mmc_check+0xa28>)
  400db8:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  400dbc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  400dc0:	fb00 f101 	mul.w	r1, r0, r1
		tplfe_max_tran_speed = 0x32; // 25Mhz
	}

	// Decode transfer speed in Hz.
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
  400dc4:	f3c3 03c3 	ubfx	r3, r3, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400dc8:	48ac      	ldr	r0, [pc, #688]	; (40107c <sd_mmc_check+0xa2c>)
  400dca:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  400dce:	fb03 f301 	mul.w	r3, r3, r1
  400dd2:	6013      	str	r3, [r2, #0]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  400dd4:	f240 4362 	movw	r3, #1122	; 0x462
  400dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ddc:	7818      	ldrb	r0, [r3, #0]
  400dde:	f241 7395 	movw	r3, #6037	; 0x1795
  400de2:	f2c0 0340 	movt	r3, #64	; 0x40
  400de6:	4798      	blx	r3
  400de8:	2803      	cmp	r0, #3
  400dea:	d959      	bls.n	400ea0 <sd_mmc_check+0x850>
		// TRY to enable 4-bit mode
		if (IS_SDIO()) {
  400dec:	f240 435c 	movw	r3, #1116	; 0x45c
  400df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400df4:	681b      	ldr	r3, [r3, #0]
  400df6:	7adb      	ldrb	r3, [r3, #11]
  400df8:	f003 0304 	and.w	r3, r3, #4
  400dfc:	b2db      	uxtb	r3, r3
  400dfe:	b333      	cbz	r3, 400e4e <sd_mmc_check+0x7fe>
	 * A SDIO Low-Speed alone can supports 4bit (Optional)
	 */
	uint8_t u8_value;

	// Check 4bit support in 4BLS of "Card Capability" register
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP,
  400e00:	ab03      	add	r3, sp, #12
  400e02:	9300      	str	r3, [sp, #0]
  400e04:	f04f 0000 	mov.w	r0, #0
  400e08:	4601      	mov	r1, r0
  400e0a:	f04f 0208 	mov.w	r2, #8
  400e0e:	4603      	mov	r3, r0
  400e10:	4d9b      	ldr	r5, [pc, #620]	; (401080 <sd_mmc_check+0xa30>)
  400e12:	47a8      	blx	r5
  400e14:	2800      	cmp	r0, #0
  400e16:	f000 80e7 	beq.w	400fe8 <sd_mmc_check+0x998>
			0, &u8_value)) {
		return false;
	}
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
  400e1a:	f99d 300c 	ldrsb.w	r3, [sp, #12]
  400e1e:	2b00      	cmp	r3, #0
  400e20:	da15      	bge.n	400e4e <sd_mmc_check+0x7fe>
		// No supported, it is not a protocol error
		return true;
	}
	// HS mode possible, then enable
	u8_value = SDIO_BUSWIDTH_4B;
  400e22:	ab14      	add	r3, sp, #80	; 0x50
  400e24:	f04f 0202 	mov.w	r2, #2
  400e28:	f803 2d44 	strb.w	r2, [r3, #-68]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL,
  400e2c:	9300      	str	r3, [sp, #0]
  400e2e:	f04f 0001 	mov.w	r0, #1
  400e32:	f04f 0100 	mov.w	r1, #0
  400e36:	f04f 0207 	mov.w	r2, #7
  400e3a:	4603      	mov	r3, r0
  400e3c:	47a8      	blx	r5
  400e3e:	2800      	cmp	r0, #0
  400e40:	f000 80d2 	beq.w	400fe8 <sd_mmc_check+0x998>
			1, &u8_value)) {
		return false;
	}
	sd_mmc_card->bus_width = 4;
  400e44:	4b8b      	ldr	r3, [pc, #556]	; (401074 <sd_mmc_check+0xa24>)
  400e46:	681b      	ldr	r3, [r3, #0]
  400e48:	f04f 0204 	mov.w	r2, #4
  400e4c:	735a      	strb	r2, [r3, #13]
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400e4e:	f240 435c 	movw	r3, #1116	; 0x45c
  400e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400e56:	681b      	ldr	r3, [r3, #0]
  400e58:	7ada      	ldrb	r2, [r3, #11]
  400e5a:	f012 0f01 	tst.w	r2, #1
  400e5e:	d01a      	beq.n	400e96 <sd_mmc_check+0x846>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400e60:	8919      	ldrh	r1, [r3, #8]
  400e62:	f241 1037 	movw	r0, #4407	; 0x1137
  400e66:	ea4f 4101 	mov.w	r1, r1, lsl #16
  400e6a:	f641 0345 	movw	r3, #6213	; 0x1845
  400e6e:	f2c0 0340 	movt	r3, #64	; 0x40
  400e72:	4798      	blx	r3
  400e74:	2800      	cmp	r0, #0
  400e76:	f000 80b7 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  400e7a:	f241 1006 	movw	r0, #4358	; 0x1106
  400e7e:	f04f 0102 	mov.w	r1, #2
  400e82:	4b80      	ldr	r3, [pc, #512]	; (401084 <sd_mmc_check+0xa34>)
  400e84:	4798      	blx	r3
  400e86:	2800      	cmp	r0, #0
  400e88:	f000 80ae 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  400e8c:	4b79      	ldr	r3, [pc, #484]	; (401074 <sd_mmc_check+0xa24>)
  400e8e:	681b      	ldr	r3, [r3, #0]
  400e90:	f04f 0204 	mov.w	r2, #4
  400e94:	735a      	strb	r2, [r3, #13]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  400e96:	f240 437d 	movw	r3, #1149	; 0x47d
  400e9a:	f2c0 0340 	movt	r3, #64	; 0x40
  400e9e:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  400ea0:	f241 73a1 	movw	r3, #6049	; 0x17a1
  400ea4:	f2c0 0340 	movt	r3, #64	; 0x40
  400ea8:	4798      	blx	r3
  400eaa:	2800      	cmp	r0, #0
  400eac:	d07e      	beq.n	400fac <sd_mmc_check+0x95c>
		// TRY to enable High-Speed Mode
		if (IS_SDIO()) {
  400eae:	f240 435c 	movw	r3, #1116	; 0x45c
  400eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400eb6:	681b      	ldr	r3, [r3, #0]
  400eb8:	7adb      	ldrb	r3, [r3, #11]
  400eba:	f003 0304 	and.w	r3, r3, #4
  400ebe:	b2db      	uxtb	r3, r3
  400ec0:	b353      	cbz	r3, 400f18 <sd_mmc_check+0x8c8>
static bool sdio_cmd52_set_high_speed(void)
{
	uint8_t u8_value;

	// Check CIA.HS
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
  400ec2:	ab03      	add	r3, sp, #12
  400ec4:	9300      	str	r3, [sp, #0]
  400ec6:	f04f 0000 	mov.w	r0, #0
  400eca:	4601      	mov	r1, r0
  400ecc:	f04f 0213 	mov.w	r2, #19
  400ed0:	4603      	mov	r3, r0
  400ed2:	4d6b      	ldr	r5, [pc, #428]	; (401080 <sd_mmc_check+0xa30>)
  400ed4:	47a8      	blx	r5
  400ed6:	2800      	cmp	r0, #0
  400ed8:	f000 8086 	beq.w	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
  400edc:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400ee0:	f013 0f01 	tst.w	r3, #1
  400ee4:	d018      	beq.n	400f18 <sd_mmc_check+0x8c8>
		// No supported, it is not a protocol error
		return true;
	}
	// HS mode possible, then enable
	u8_value = SDIO_EHS;
  400ee6:	ab14      	add	r3, sp, #80	; 0x50
  400ee8:	f04f 0202 	mov.w	r2, #2
  400eec:	f803 2d44 	strb.w	r2, [r3, #-68]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS,
  400ef0:	9300      	str	r3, [sp, #0]
  400ef2:	f04f 0001 	mov.w	r0, #1
  400ef6:	f04f 0100 	mov.w	r1, #0
  400efa:	f04f 0213 	mov.w	r2, #19
  400efe:	4603      	mov	r3, r0
  400f00:	47a8      	blx	r5
  400f02:	2800      	cmp	r0, #0
  400f04:	d070      	beq.n	400fe8 <sd_mmc_check+0x998>
			1, &u8_value)) {
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400f06:	4b5b      	ldr	r3, [pc, #364]	; (401074 <sd_mmc_check+0xa24>)
  400f08:	681b      	ldr	r3, [r3, #0]
  400f0a:	f04f 0201 	mov.w	r2, #1
  400f0e:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f10:	681a      	ldr	r2, [r3, #0]
  400f12:	ea4f 0242 	mov.w	r2, r2, lsl #1
  400f16:	601a      	str	r2, [r3, #0]
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400f18:	f240 435c 	movw	r3, #1116	; 0x45c
  400f1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400f20:	681b      	ldr	r3, [r3, #0]
  400f22:	7ada      	ldrb	r2, [r3, #11]
  400f24:	f012 0f01 	tst.w	r2, #1
  400f28:	d03b      	beq.n	400fa2 <sd_mmc_check+0x952>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  400f2a:	7b1b      	ldrb	r3, [r3, #12]
  400f2c:	2b10      	cmp	r3, #16
  400f2e:	d938      	bls.n	400fa2 <sd_mmc_check+0x952>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400f30:	f04f 0301 	mov.w	r3, #1
  400f34:	9300      	str	r3, [sp, #0]
  400f36:	f241 1006 	movw	r0, #4358	; 0x1106
  400f3a:	f2c0 0008 	movt	r0, #8
  400f3e:	f64f 7101 	movw	r1, #65281	; 0xff01
  400f42:	f2c8 01ff 	movt	r1, #33023	; 0x80ff
  400f46:	f04f 0240 	mov.w	r2, #64	; 0x40
  400f4a:	4d4f      	ldr	r5, [pc, #316]	; (401088 <sd_mmc_check+0xa38>)
  400f4c:	47a8      	blx	r5
  400f4e:	2800      	cmp	r0, #0
  400f50:	d04a      	beq.n	400fe8 <sd_mmc_check+0x998>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  400f52:	a804      	add	r0, sp, #16
  400f54:	f04f 0101 	mov.w	r1, #1
  400f58:	4b44      	ldr	r3, [pc, #272]	; (40106c <sd_mmc_check+0xa1c>)
  400f5a:	4798      	blx	r3
  400f5c:	2800      	cmp	r0, #0
  400f5e:	d043      	beq.n	400fe8 <sd_mmc_check+0x998>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400f60:	4b43      	ldr	r3, [pc, #268]	; (401070 <sd_mmc_check+0xa20>)
  400f62:	4798      	blx	r3
  400f64:	2800      	cmp	r0, #0
  400f66:	d03f      	beq.n	400fe8 <sd_mmc_check+0x998>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400f68:	4b48      	ldr	r3, [pc, #288]	; (40108c <sd_mmc_check+0xa3c>)
  400f6a:	4798      	blx	r3
  400f6c:	f010 0f80 	tst.w	r0, #128	; 0x80
  400f70:	d13a      	bne.n	400fe8 <sd_mmc_check+0x998>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400f72:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  400f76:	f003 030f 	and.w	r3, r3, #15
  400f7a:	2b0f      	cmp	r3, #15
  400f7c:	d011      	beq.n	400fa2 <sd_mmc_check+0x952>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400f7e:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f82:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  400f86:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  400f8a:	d12d      	bne.n	400fe8 <sd_mmc_check+0x998>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  400f8c:	4b40      	ldr	r3, [pc, #256]	; (401090 <sd_mmc_check+0xa40>)
  400f8e:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
  400f90:	4b38      	ldr	r3, [pc, #224]	; (401074 <sd_mmc_check+0xa24>)
  400f92:	681b      	ldr	r3, [r3, #0]
  400f94:	f04f 0201 	mov.w	r2, #1
  400f98:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f9a:	681a      	ldr	r2, [r3, #0]
  400f9c:	ea4f 0242 	mov.w	r2, r2, lsl #1
  400fa0:	601a      	str	r2, [r3, #0]
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  400fa2:	f240 437d 	movw	r3, #1149	; 0x47d
  400fa6:	f2c0 0340 	movt	r3, #64	; 0x40
  400faa:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400fac:	f240 435c 	movw	r3, #1116	; 0x45c
  400fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400fb4:	681b      	ldr	r3, [r3, #0]
  400fb6:	7adb      	ldrb	r3, [r3, #11]
  400fb8:	f013 0f01 	tst.w	r3, #1
  400fbc:	d006      	beq.n	400fcc <sd_mmc_check+0x97c>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400fbe:	f241 1010 	movw	r0, #4368	; 0x1110
  400fc2:	f44f 7100 	mov.w	r1, #512	; 0x200
  400fc6:	4b2f      	ldr	r3, [pc, #188]	; (401084 <sd_mmc_check+0xa34>)
  400fc8:	4798      	blx	r3
		sd_mmc_deselect_slot();
		return sd_mmc_err;
	}

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
  400fca:	b168      	cbz	r0, 400fe8 <sd_mmc_check+0x998>
			: sd_mmc_mci_card_init()) {
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  400fcc:	f240 435c 	movw	r3, #1116	; 0x45c
  400fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400fd4:	681b      	ldr	r3, [r3, #0]
  400fd6:	f04f 0200 	mov.w	r2, #0
  400fda:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
  400fdc:	f240 537d 	movw	r3, #1405	; 0x57d
  400fe0:	f2c0 0340 	movt	r3, #64	; 0x40
  400fe4:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
  400fe6:	e07e      	b.n	4010e6 <sd_mmc_check+0xa96>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  400fe8:	f240 435c 	movw	r3, #1116	; 0x45c
  400fec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ff0:	681b      	ldr	r3, [r3, #0]
  400ff2:	f04f 0403 	mov.w	r4, #3
  400ff6:	729c      	strb	r4, [r3, #10]
	sd_mmc_deselect_slot();
  400ff8:	f240 537d 	movw	r3, #1405	; 0x57d
  400ffc:	f2c0 0340 	movt	r3, #64	; 0x40
  401000:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
  401002:	e070      	b.n	4010e6 <sd_mmc_check+0xa96>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  401004:	f04f 0700 	mov.w	r7, #0
  401008:	e001      	b.n	40100e <sd_mmc_check+0x9be>
  40100a:	f04f 0700 	mov.w	r7, #0
static bool sdio_op_cond(void)
{
	uint32_t resp;

	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
  40100e:	f244 5005 	movw	r0, #17669	; 0x4505
  401012:	f04f 0100 	mov.w	r1, #0
  401016:	f641 0345 	movw	r3, #6213	; 0x1845
  40101a:	f2c0 0340 	movt	r3, #64	; 0x40
  40101e:	4798      	blx	r3
  401020:	2800      	cmp	r0, #0
  401022:	f47f ab64 	bne.w	4006ee <sd_mmc_check+0x9e>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401026:	f240 435c 	movw	r3, #1116	; 0x45c
  40102a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40102e:	681b      	ldr	r3, [r3, #0]
  401030:	7adb      	ldrb	r3, [r3, #11]
  401032:	f013 0f01 	tst.w	r3, #1
  401036:	f43f ad4d 	beq.w	400ad4 <sd_mmc_check+0x484>
  40103a:	f7ff bb89 	b.w	400750 <sd_mmc_check+0x100>
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  40103e:	f240 435c 	movw	r3, #1116	; 0x45c
  401042:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401046:	681b      	ldr	r3, [r3, #0]
  401048:	f04f 0202 	mov.w	r2, #2
  40104c:	72da      	strb	r2, [r3, #11]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40104e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401052:	f04f 0100 	mov.w	r1, #0
  401056:	f641 0345 	movw	r3, #6213	; 0x1845
  40105a:	f2c0 0340 	movt	r3, #64	; 0x40
  40105e:	4798      	blx	r3
  401060:	2800      	cmp	r0, #0
  401062:	f47f abae 	bne.w	4007c2 <sd_mmc_check+0x172>
  401066:	e7b0      	b.n	400fca <sd_mmc_check+0x97a>
  401068:	00400529 	.word	0x00400529
  40106c:	00401a11 	.word	0x00401a11
  401070:	00401a5d 	.word	0x00401a5d
  401074:	2000045c 	.word	0x2000045c
  401078:	004044f4 	.word	0x004044f4
  40107c:	004044b4 	.word	0x004044b4
  401080:	0040059d 	.word	0x0040059d
  401084:	00401845 	.word	0x00401845
  401088:	004018a9 	.word	0x004018a9
  40108c:	00401875 	.word	0x00401875
  401090:	00401821 	.word	0x00401821
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401094:	f240 435c 	movw	r3, #1116	; 0x45c
  401098:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40109c:	681b      	ldr	r3, [r3, #0]
  40109e:	7adb      	ldrb	r3, [r3, #11]
  4010a0:	f013 0f01 	tst.w	r3, #1
  4010a4:	f47f ad0a 	bne.w	400abc <sd_mmc_check+0x46c>
  4010a8:	e514      	b.n	400ad4 <sd_mmc_check+0x484>
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4010aa:	f645 3002 	movw	r0, #23298	; 0x5b02
  4010ae:	f04f 0100 	mov.w	r1, #0
  4010b2:	4b0f      	ldr	r3, [pc, #60]	; (4010f0 <sd_mmc_check+0xaa0>)
  4010b4:	4798      	blx	r3
  4010b6:	2800      	cmp	r0, #0
  4010b8:	f47f abae 	bne.w	400818 <sd_mmc_check+0x1c8>
  4010bc:	e785      	b.n	400fca <sd_mmc_check+0x97a>
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
		return false;
	}

	if (!mmc_mci_op_cond()) {
		return false;
  4010be:	f04f 0000 	mov.w	r0, #0
  4010c2:	e782      	b.n	400fca <sd_mmc_check+0x97a>
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
  4010c4:	f04f 0000 	mov.w	r0, #0
  4010c8:	e77f      	b.n	400fca <sd_mmc_check+0x97a>
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  4010ca:	4b0a      	ldr	r3, [pc, #40]	; (4010f4 <sd_mmc_check+0xaa4>)
  4010cc:	7818      	ldrb	r0, [r3, #0]
  4010ce:	4b0a      	ldr	r3, [pc, #40]	; (4010f8 <sd_mmc_check+0xaa8>)
  4010d0:	4798      	blx	r3
  4010d2:	2803      	cmp	r0, #3
  4010d4:	f63f ac6b 	bhi.w	4009ae <sd_mmc_check+0x35e>
  4010d8:	e492      	b.n	400a00 <sd_mmc_check+0x3b0>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
  4010da:	f04f 0000 	mov.w	r0, #0
  4010de:	e774      	b.n	400fca <sd_mmc_check+0x97a>
			sd_mmc_configure_slot();
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
  4010e0:	f04f 0000 	mov.w	r0, #0
  4010e4:	e771      	b.n	400fca <sd_mmc_check+0x97a>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  4010e6:	4620      	mov	r0, r4
  4010e8:	b015      	add	sp, #84	; 0x54
  4010ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4010ee:	bf00      	nop
  4010f0:	00401845 	.word	0x00401845
  4010f4:	20000462 	.word	0x20000462
  4010f8:	00401795 	.word	0x00401795

004010fc <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
  4010fc:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4010fe:	f240 43ad 	movw	r3, #1197	; 0x4ad
  401102:	f2c0 0340 	movt	r3, #64	; 0x40
  401106:	4798      	blx	r3
  401108:	b958      	cbnz	r0, 401122 <sd_mmc_get_type+0x26>
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
  40110a:	f240 537d 	movw	r3, #1405	; 0x57d
  40110e:	f2c0 0340 	movt	r3, #64	; 0x40
  401112:	4798      	blx	r3
	return sd_mmc_card->type;
  401114:	f240 435c 	movw	r3, #1116	; 0x45c
  401118:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40111c:	681b      	ldr	r3, [r3, #0]
  40111e:	7ad8      	ldrb	r0, [r3, #11]
  401120:	bd08      	pop	{r3, pc}
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  401122:	f04f 0000 	mov.w	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
}
  401126:	bd08      	pop	{r3, pc}

00401128 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  401128:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  40112a:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40112e:	f2c0 0340 	movt	r3, #64	; 0x40
  401132:	4798      	blx	r3
  401134:	b958      	cbnz	r0, 40114e <sd_mmc_get_capacity+0x26>
		return 0;
	}
	sd_mmc_deselect_slot();
  401136:	f240 537d 	movw	r3, #1405	; 0x57d
  40113a:	f2c0 0340 	movt	r3, #64	; 0x40
  40113e:	4798      	blx	r3
	return sd_mmc_card->capacity;
  401140:	f240 435c 	movw	r3, #1116	; 0x45c
  401144:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401148:	681b      	ldr	r3, [r3, #0]
  40114a:	6858      	ldr	r0, [r3, #4]
  40114c:	bd08      	pop	{r3, pc}
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  40114e:	f04f 0000 	mov.w	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
}
  401152:	bd08      	pop	{r3, pc}

00401154 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  401154:	f04f 0000 	mov.w	r0, #0
  401158:	4770      	bx	lr
  40115a:	bf00      	nop

0040115c <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  40115c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401160:	b083      	sub	sp, #12
  401162:	468b      	mov	fp, r1
  401164:	4692      	mov	sl, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401166:	f240 43ad 	movw	r3, #1197	; 0x4ad
  40116a:	f2c0 0340 	movt	r3, #64	; 0x40
  40116e:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
  401170:	4681      	mov	r9, r0
  401172:	2800      	cmp	r0, #0
  401174:	d178      	bne.n	401268 <sd_mmc_init_read_blocks+0x10c>
  401176:	f640 5441 	movw	r4, #3393	; 0xd41
  40117a:	f2c0 0403 	movt	r4, #3
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40117e:	f240 475c 	movw	r7, #1116	; 0x45c
  401182:	f2c2 0700 	movt	r7, #8192	; 0x2000
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  401186:	f241 160d 	movw	r6, #4365	; 0x110d
  40118a:	f641 0545 	movw	r5, #6213	; 0x1845
  40118e:	f2c0 0540 	movt	r5, #64	; 0x40
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401192:	f641 0875 	movw	r8, #6261	; 0x1875
  401196:	f2c0 0840 	movt	r8, #64	; 0x40
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40119a:	683b      	ldr	r3, [r7, #0]
  40119c:	8919      	ldrh	r1, [r3, #8]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  40119e:	4630      	mov	r0, r6
  4011a0:	ea4f 4101 	mov.w	r1, r1, lsl #16
  4011a4:	47a8      	blx	r5
  4011a6:	2800      	cmp	r0, #0
  4011a8:	d03d      	beq.n	401226 <sd_mmc_init_read_blocks+0xca>
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  4011aa:	47c0      	blx	r8
  4011ac:	f410 7f80 	tst.w	r0, #256	; 0x100
  4011b0:	d141      	bne.n	401236 <sd_mmc_init_read_blocks+0xda>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  4011b2:	3c01      	subs	r4, #1
  4011b4:	d1f1      	bne.n	40119a <sd_mmc_init_read_blocks+0x3e>
  4011b6:	e036      	b.n	401226 <sd_mmc_init_read_blocks+0xca>
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4011b8:	ea4f 214b 	mov.w	r1, fp, lsl #9
  4011bc:	e7ff      	b.n	4011be <sd_mmc_init_read_blocks+0x62>
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4011be:	f04f 0201 	mov.w	r2, #1
  4011c2:	9200      	str	r2, [sp, #0]
  4011c4:	f44f 7200 	mov.w	r2, #512	; 0x200
  4011c8:	4653      	mov	r3, sl
  4011ca:	f641 04a9 	movw	r4, #6313	; 0x18a9
  4011ce:	f2c0 0440 	movt	r4, #64	; 0x40
  4011d2:	47a0      	blx	r4
  4011d4:	b938      	cbnz	r0, 4011e6 <sd_mmc_init_read_blocks+0x8a>
		sd_mmc_deselect_slot();
  4011d6:	f240 537d 	movw	r3, #1405	; 0x57d
  4011da:	f2c0 0340 	movt	r3, #64	; 0x40
  4011de:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  4011e0:	f04f 0905 	mov.w	r9, #5
  4011e4:	e040      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4011e6:	f641 0375 	movw	r3, #6261	; 0x1875
  4011ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4011ee:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4011f0:	f04f 0300 	mov.w	r3, #0
  4011f4:	f2ce 4358 	movt	r3, #58456	; 0xe458
  4011f8:	4003      	ands	r3, r0
  4011fa:	b13b      	cbz	r3, 40120c <sd_mmc_init_read_blocks+0xb0>
			sd_mmc_debug("%s: Read blocks %02d resp32 0x%08x CARD_STATUS_ERR_RD_WR\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
  4011fc:	f240 537d 	movw	r3, #1405	; 0x57d
  401200:	f2c0 0340 	movt	r3, #64	; 0x40
  401204:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  401206:	f04f 0905 	mov.w	r9, #5
  40120a:	e02d      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40120c:	f240 4360 	movw	r3, #1120	; 0x460
  401210:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401214:	f8a3 a000 	strh.w	sl, [r3]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401218:	f240 4358 	movw	r3, #1112	; 0x458
  40121c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401220:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  401224:	e020      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
		return sd_mmc_err;
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
  401226:	f240 537d 	movw	r3, #1405	; 0x57d
  40122a:	f2c0 0340 	movt	r3, #64	; 0x40
  40122e:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  401230:	f04f 0905 	mov.w	r9, #5
  401234:	e018      	b.n	401268 <sd_mmc_init_read_blocks+0x10c>
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
  401236:	f241 1011 	movw	r0, #4369	; 0x1111
  40123a:	f2c0 0008 	movt	r0, #8
  40123e:	f241 1312 	movw	r3, #4370	; 0x1112
  401242:	f2c0 0310 	movt	r3, #16
  401246:	f1ba 0f01 	cmp.w	sl, #1
  40124a:	bf88      	it	hi
  40124c:	4618      	movhi	r0, r3
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40124e:	f240 435c 	movw	r3, #1116	; 0x45c
  401252:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401256:	681b      	ldr	r3, [r3, #0]
  401258:	7adb      	ldrb	r3, [r3, #11]
  40125a:	f003 0308 	and.w	r3, r3, #8
  40125e:	b2db      	uxtb	r3, r3
		arg = start;
  401260:	4659      	mov	r1, fp
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401262:	2b00      	cmp	r3, #0
  401264:	d1ab      	bne.n	4011be <sd_mmc_init_read_blocks+0x62>
  401266:	e7a7      	b.n	4011b8 <sd_mmc_init_read_blocks+0x5c>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401268:	4648      	mov	r0, r9
  40126a:	b003      	add	sp, #12
  40126c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00401270 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401270:	b510      	push	{r4, lr}
  401272:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  401274:	f641 2311 	movw	r3, #6673	; 0x1a11
  401278:	f2c0 0340 	movt	r3, #64	; 0x40
  40127c:	4798      	blx	r3
  40127e:	b948      	cbnz	r0, 401294 <sd_mmc_start_read_blocks+0x24>
		sd_mmc_nb_block_remaining = 0;
  401280:	f240 4360 	movw	r3, #1120	; 0x460
  401284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401288:	f04f 0200 	mov.w	r2, #0
  40128c:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  40128e:	f04f 0005 	mov.w	r0, #5
  401292:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401294:	f240 4360 	movw	r3, #1120	; 0x460
  401298:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40129c:	881a      	ldrh	r2, [r3, #0]
  40129e:	1b14      	subs	r4, r2, r4
  4012a0:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  4012a2:	f04f 0000 	mov.w	r0, #0
}
  4012a6:	bd10      	pop	{r4, pc}

004012a8 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(void)
{
  4012a8:	b508      	push	{r3, lr}
	if (!driver_wait_end_of_read_blocks()) {
  4012aa:	f641 235d 	movw	r3, #6749	; 0x1a5d
  4012ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4012b2:	4798      	blx	r3
  4012b4:	2800      	cmp	r0, #0
  4012b6:	d030      	beq.n	40131a <sd_mmc_wait_end_of_read_blocks+0x72>
		return SD_MMC_ERR_COMM;
	}
	if (sd_mmc_nb_block_remaining) {
  4012b8:	f240 4360 	movw	r3, #1120	; 0x460
  4012bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012c0:	881b      	ldrh	r3, [r3, #0]
  4012c2:	2b00      	cmp	r3, #0
  4012c4:	d12c      	bne.n	401320 <sd_mmc_wait_end_of_read_blocks+0x78>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4012c6:	f240 4358 	movw	r3, #1112	; 0x458
  4012ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4012ce:	881b      	ldrh	r3, [r3, #0]
  4012d0:	2b01      	cmp	r3, #1
  4012d2:	d107      	bne.n	4012e4 <sd_mmc_wait_end_of_read_blocks+0x3c>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
  4012d4:	f240 537d 	movw	r3, #1405	; 0x57d
  4012d8:	f2c0 0340 	movt	r3, #64	; 0x40
  4012dc:	4798      	blx	r3
		return SD_MMC_OK;
  4012de:	f04f 0000 	mov.w	r0, #0
  4012e2:	bd08      	pop	{r3, pc}
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4012e4:	f243 100c 	movw	r0, #12556	; 0x310c
  4012e8:	f04f 0100 	mov.w	r1, #0
  4012ec:	f641 0345 	movw	r3, #6213	; 0x1845
  4012f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4012f4:	4798      	blx	r3
  4012f6:	b940      	cbnz	r0, 40130a <sd_mmc_wait_end_of_read_blocks+0x62>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  4012f8:	f243 100c 	movw	r0, #12556	; 0x310c
  4012fc:	f04f 0100 	mov.w	r1, #0
  401300:	f641 0345 	movw	r3, #6213	; 0x1845
  401304:	f2c0 0340 	movt	r3, #64	; 0x40
  401308:	4798      	blx	r3
	}
	sd_mmc_deselect_slot();
  40130a:	f240 537d 	movw	r3, #1405	; 0x57d
  40130e:	f2c0 0340 	movt	r3, #64	; 0x40
  401312:	4798      	blx	r3
	return SD_MMC_OK;
  401314:	f04f 0000 	mov.w	r0, #0
  401318:	bd08      	pop	{r3, pc}
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(void)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
  40131a:	f04f 0005 	mov.w	r0, #5
  40131e:	bd08      	pop	{r3, pc}
	}
	if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
  401320:	f04f 0000 	mov.w	r0, #0
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  401324:	bd08      	pop	{r3, pc}
  401326:	bf00      	nop

00401328 <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401328:	b5f0      	push	{r4, r5, r6, r7, lr}
  40132a:	b083      	sub	sp, #12
  40132c:	4605      	mov	r5, r0
  40132e:	460f      	mov	r7, r1
  401330:	4616      	mov	r6, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401332:	f240 44ad 	movw	r4, #1197	; 0x4ad
  401336:	f2c0 0440 	movt	r4, #64	; 0x40
  40133a:	47a0      	blx	r4
	if (sd_mmc_err != SD_MMC_OK) {
  40133c:	4604      	mov	r4, r0
  40133e:	2800      	cmp	r0, #0
  401340:	d157      	bne.n	4013f2 <sd_mmc_init_write_blocks+0xca>
		return sd_mmc_err;
	}
	if (sd_mmc_is_write_protected(slot)) {
  401342:	4628      	mov	r0, r5
  401344:	f241 1555 	movw	r5, #4437	; 0x1155
  401348:	f2c0 0540 	movt	r5, #64	; 0x40
  40134c:	47a8      	blx	r5
  40134e:	b138      	cbz	r0, 401360 <sd_mmc_init_write_blocks+0x38>
		sd_mmc_deselect_slot();
  401350:	f240 537d 	movw	r3, #1405	; 0x57d
  401354:	f2c0 0340 	movt	r3, #64	; 0x40
  401358:	4798      	blx	r3
		return SD_MMC_ERR_WP;
  40135a:	f04f 0407 	mov.w	r4, #7
  40135e:	e048      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  401360:	f249 1018 	movw	r0, #37144	; 0x9118
  401364:	f2c0 0008 	movt	r0, #8
  401368:	f249 1319 	movw	r3, #37145	; 0x9119
  40136c:	f2c0 0310 	movt	r3, #16
  401370:	2e01      	cmp	r6, #1
  401372:	bf88      	it	hi
  401374:	4618      	movhi	r0, r3
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401376:	f240 435c 	movw	r3, #1116	; 0x45c
  40137a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40137e:	681b      	ldr	r3, [r3, #0]
  401380:	7adb      	ldrb	r3, [r3, #11]
  401382:	f003 0308 	and.w	r3, r3, #8
  401386:	b2db      	uxtb	r3, r3
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401388:	ea4f 2147 	mov.w	r1, r7, lsl #9
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40138c:	b103      	cbz	r3, 401390 <sd_mmc_init_write_blocks+0x68>
		arg = start;
  40138e:	4639      	mov	r1, r7
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401390:	f04f 0301 	mov.w	r3, #1
  401394:	9300      	str	r3, [sp, #0]
  401396:	f44f 7200 	mov.w	r2, #512	; 0x200
  40139a:	4633      	mov	r3, r6
  40139c:	f641 05a9 	movw	r5, #6313	; 0x18a9
  4013a0:	f2c0 0540 	movt	r5, #64	; 0x40
  4013a4:	47a8      	blx	r5
  4013a6:	b938      	cbnz	r0, 4013b8 <sd_mmc_init_write_blocks+0x90>
		sd_mmc_deselect_slot();
  4013a8:	f240 537d 	movw	r3, #1405	; 0x57d
  4013ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4013b0:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
  4013b2:	f04f 0405 	mov.w	r4, #5
  4013b6:	e01c      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4013b8:	f641 0375 	movw	r3, #6261	; 0x1875
  4013bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4013c0:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4013c2:	f04f 0300 	mov.w	r3, #0
  4013c6:	f2ce 4358 	movt	r3, #58456	; 0xe458
  4013ca:	4003      	ands	r3, r0
  4013cc:	b13b      	cbz	r3, 4013de <sd_mmc_init_write_blocks+0xb6>
			sd_mmc_debug("%s: Write blocks %02d r1 0x%08x CARD_STATUS_ERR_RD_WR\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
  4013ce:	f240 537d 	movw	r3, #1405	; 0x57d
  4013d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4013d6:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  4013d8:	f04f 0405 	mov.w	r4, #5
  4013dc:	e009      	b.n	4013f2 <sd_mmc_init_write_blocks+0xca>
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4013de:	f240 4360 	movw	r3, #1120	; 0x460
  4013e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4013e6:	801e      	strh	r6, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  4013e8:	f240 4358 	movw	r3, #1112	; 0x458
  4013ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4013f0:	801e      	strh	r6, [r3, #0]
	return SD_MMC_OK;
}
  4013f2:	4620      	mov	r0, r4
  4013f4:	b003      	add	sp, #12
  4013f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

004013f8 <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4013f8:	b510      	push	{r4, lr}
  4013fa:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4013fc:	f641 23ed 	movw	r3, #6893	; 0x1aed
  401400:	f2c0 0340 	movt	r3, #64	; 0x40
  401404:	4798      	blx	r3
  401406:	b948      	cbnz	r0, 40141c <sd_mmc_start_write_blocks+0x24>
		sd_mmc_nb_block_remaining = 0;
  401408:	f240 4360 	movw	r3, #1120	; 0x460
  40140c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401410:	f04f 0200 	mov.w	r2, #0
  401414:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
  401416:	f04f 0005 	mov.w	r0, #5
  40141a:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  40141c:	f240 4360 	movw	r3, #1120	; 0x460
  401420:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401424:	881a      	ldrh	r2, [r3, #0]
  401426:	1b14      	subs	r4, r2, r4
  401428:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  40142a:	f04f 0000 	mov.w	r0, #0
}
  40142e:	bd10      	pop	{r4, pc}

00401430 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(void)
{
  401430:	b508      	push	{r3, lr}
	if (!driver_wait_end_of_write_blocks()) {
  401432:	f641 333d 	movw	r3, #6973	; 0x1b3d
  401436:	f2c0 0340 	movt	r3, #64	; 0x40
  40143a:	4798      	blx	r3
  40143c:	2800      	cmp	r0, #0
  40143e:	d02f      	beq.n	4014a0 <sd_mmc_wait_end_of_write_blocks+0x70>
		return SD_MMC_ERR_COMM;
	}
	if (sd_mmc_nb_block_remaining) {
  401440:	f240 4360 	movw	r3, #1120	; 0x460
  401444:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401448:	881b      	ldrh	r3, [r3, #0]
  40144a:	2b00      	cmp	r3, #0
  40144c:	d12b      	bne.n	4014a6 <sd_mmc_wait_end_of_write_blocks+0x76>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40144e:	f240 4358 	movw	r3, #1112	; 0x458
  401452:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401456:	881b      	ldrh	r3, [r3, #0]
  401458:	2b01      	cmp	r3, #1
  40145a:	d107      	bne.n	40146c <sd_mmc_wait_end_of_write_blocks+0x3c>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
  40145c:	f240 537d 	movw	r3, #1405	; 0x57d
  401460:	f2c0 0340 	movt	r3, #64	; 0x40
  401464:	4798      	blx	r3
		return SD_MMC_OK;
  401466:	f04f 0000 	mov.w	r0, #0
  40146a:	bd08      	pop	{r3, pc}
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  40146c:	f243 100c 	movw	r0, #12556	; 0x310c
  401470:	f04f 0100 	mov.w	r1, #0
  401474:	f641 0345 	movw	r3, #6213	; 0x1845
  401478:	f2c0 0340 	movt	r3, #64	; 0x40
  40147c:	4798      	blx	r3
  40147e:	b938      	cbnz	r0, 401490 <sd_mmc_wait_end_of_write_blocks+0x60>
			sd_mmc_deselect_slot();
  401480:	f240 537d 	movw	r3, #1405	; 0x57d
  401484:	f2c0 0340 	movt	r3, #64	; 0x40
  401488:	4798      	blx	r3
			return SD_MMC_ERR_COMM;
  40148a:	f04f 0005 	mov.w	r0, #5
  40148e:	bd08      	pop	{r3, pc}
		}
	}
	sd_mmc_deselect_slot();
  401490:	f240 537d 	movw	r3, #1405	; 0x57d
  401494:	f2c0 0340 	movt	r3, #64	; 0x40
  401498:	4798      	blx	r3
	return SD_MMC_OK;
  40149a:	f04f 0000 	mov.w	r0, #0
  40149e:	bd08      	pop	{r3, pc}
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(void)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
  4014a0:	f04f 0005 	mov.w	r0, #5
  4014a4:	bd08      	pop	{r3, pc}
	}
	if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
  4014a6:	f04f 0000 	mov.w	r0, #0
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  4014aa:	bd08      	pop	{r3, pc}

004014ac <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  4014ac:	b510      	push	{r4, lr}
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4014ae:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4014b2:	f2c0 7027 	movt	r0, #1831	; 0x727
  4014b6:	f242 33c9 	movw	r3, #9161	; 0x23c9
  4014ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4014be:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  4014c0:	f04f 0000 	mov.w	r0, #0
  4014c4:	f04f 013e 	mov.w	r1, #62	; 0x3e
  4014c8:	f641 73f1 	movw	r3, #8177	; 0x1ff1
  4014cc:	f2c0 0340 	movt	r3, #64	; 0x40
  4014d0:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4014d2:	f242 0461 	movw	r4, #8289	; 0x2061
  4014d6:	f2c0 0440 	movt	r4, #64	; 0x40
  4014da:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4014dc:	2800      	cmp	r0, #0
  4014de:	d0fc      	beq.n	4014da <sysclk_init+0x2e>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4014e0:	f242 0371 	movw	r3, #8305	; 0x2071
  4014e4:	f2c0 0340 	movt	r3, #64	; 0x40
  4014e8:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4014ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014ee:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014f2:	f643 7201 	movw	r2, #16129	; 0x3f01
  4014f6:	f2c2 0209 	movt	r2, #8201	; 0x2009
  4014fa:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
		return pmc_is_locked_pllack();
  4014fc:	f242 0481 	movw	r4, #8321	; 0x2081
  401500:	f2c0 0440 	movt	r4, #64	; 0x40
  401504:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  401506:	2800      	cmp	r0, #0
  401508:	d0fc      	beq.n	401504 <sysclk_init+0x58>
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  40150a:	f04f 0000 	mov.w	r0, #0
  40150e:	f641 7369 	movw	r3, #8041	; 0x1f69
  401512:	f2c0 0340 	movt	r3, #64	; 0x40
  401516:	4798      	blx	r3
		break;
#endif	
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  401518:	f242 2311 	movw	r3, #8721	; 0x2211
  40151c:	f2c0 0340 	movt	r3, #64	; 0x40
  401520:	4798      	blx	r3
  401522:	bd10      	pop	{r4, pc}

00401524 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  401524:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401526:	2801      	cmp	r0, #1
  401528:	d809      	bhi.n	40153e <mem_test_unit_ready+0x1a>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  40152a:	f244 5350 	movw	r3, #17744	; 0x4550
  40152e:	f2c0 0340 	movt	r3, #64	; 0x40
  401532:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401536:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  40153a:	4798      	blx	r3
  40153c:	bd08      	pop	{r3, pc}
  40153e:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401542:	bd08      	pop	{r3, pc}

00401544 <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  401544:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401546:	2801      	cmp	r0, #1
  401548:	d80b      	bhi.n	401562 <mem_read_capacity+0x1e>
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  40154a:	f244 5350 	movw	r3, #17744	; 0x4550
  40154e:	f2c0 0340 	movt	r3, #64	; 0x40
  401552:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  401556:	eb03 0380 	add.w	r3, r3, r0, lsl #2
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  40155a:	685b      	ldr	r3, [r3, #4]
  40155c:	4608      	mov	r0, r1
  40155e:	4798      	blx	r3
  401560:	bd08      	pop	{r3, pc}
  401562:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401566:	bd08      	pop	{r3, pc}

00401568 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  401568:	2801      	cmp	r0, #1
  40156a:	bf8c      	ite	hi
  40156c:	2000      	movhi	r0, #0
  40156e:	2001      	movls	r0, #1
  401570:	4770      	bx	lr
  401572:	bf00      	nop

00401574 <mem_wr_protect>:


bool mem_wr_protect(U8 lun)
{
  401574:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401576:	2801      	cmp	r0, #1
  401578:	d80a      	bhi.n	401590 <mem_wr_protect+0x1c>
  40157a:	f244 5350 	movw	r3, #17744	; 0x4550
  40157e:	f2c0 0340 	movt	r3, #64	; 0x40
  401582:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  401586:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  40158a:	689b      	ldr	r3, [r3, #8]
  40158c:	4798      	blx	r3
  40158e:	bd08      	pop	{r3, pc}
  401590:	f04f 0001 	mov.w	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  401594:	bd08      	pop	{r3, pc}
  401596:	bf00      	nop

00401598 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  401598:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  40159a:	2801      	cmp	r0, #1
  40159c:	d80c      	bhi.n	4015b8 <memory_2_ram+0x20>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  40159e:	f244 5350 	movw	r3, #17744	; 0x4550
  4015a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4015a6:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  4015aa:	eb03 0380 	add.w	r3, r3, r0, lsl #2
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  4015ae:	691b      	ldr	r3, [r3, #16]
  4015b0:	4608      	mov	r0, r1
  4015b2:	4611      	mov	r1, r2
  4015b4:	4798      	blx	r3
  4015b6:	bd08      	pop	{r3, pc}
  4015b8:	f04f 0001 	mov.w	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  4015bc:	bd08      	pop	{r3, pc}
  4015be:	bf00      	nop

004015c0 <dacc_reset>:
 *
 * \param p_dacc Pointer to a DACC instance. 
 */
void dacc_reset(Dacc *p_dacc)
{
	p_dacc->DACC_CR = DACC_CR_SWRST;
  4015c0:	f04f 0301 	mov.w	r3, #1
  4015c4:	6003      	str	r3, [r0, #0]
  4015c6:	4770      	bx	lr

004015c8 <dacc_set_transfer_mode>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_transfer_mode(Dacc *p_dacc, uint32_t ul_mode)
{
	if (ul_mode) {
  4015c8:	b121      	cbz	r1, 4015d4 <dacc_set_transfer_mode+0xc>
#if (SAM3N) || (SAM4L)
		p_dacc->DACC_MR |= DACC_MR_WORD;
#else
		p_dacc->DACC_MR |= DACC_MR_WORD_WORD;
  4015ca:	6843      	ldr	r3, [r0, #4]
  4015cc:	f043 0310 	orr.w	r3, r3, #16
  4015d0:	6043      	str	r3, [r0, #4]
  4015d2:	e003      	b.n	4015dc <dacc_set_transfer_mode+0x14>
#endif
	} else {
#if (SAM3N) || (SAM4L)
		p_dacc->DACC_MR &= (~DACC_MR_WORD);
#else
		p_dacc->DACC_MR &= (~DACC_MR_WORD_WORD);
  4015d4:	6843      	ldr	r3, [r0, #4]
  4015d6:	f023 0310 	bic.w	r3, r3, #16
  4015da:	6043      	str	r3, [r0, #4]
#endif
	}
	return DACC_RC_OK;
}
  4015dc:	f04f 0000 	mov.w	r0, #0
  4015e0:	4770      	bx	lr
  4015e2:	bf00      	nop

004015e4 <dacc_get_interrupt_status>:
 *
 * \return The interrupt status.
 */
uint32_t dacc_get_interrupt_status(Dacc *p_dacc)
{
	return p_dacc->DACC_ISR;
  4015e4:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
  4015e6:	4770      	bx	lr

004015e8 <dacc_write_conversion_data>:
 * \param p_dacc Pointer to a DACC instance. 
 * \param ul_data The data to be transferred to analog value. 
 */
void dacc_write_conversion_data(Dacc *p_dacc, uint32_t ul_data)
{
	p_dacc->DACC_CDR = ul_data;
  4015e8:	6201      	str	r1, [r0, #32]
  4015ea:	4770      	bx	lr

004015ec <dacc_enable_flexible_selection>:
 *
 * \param p_dacc Pointer to a DACC instance. 
 */
void dacc_enable_flexible_selection(Dacc *p_dacc)
{
	p_dacc->DACC_MR |= DACC_MR_TAG;
  4015ec:	6843      	ldr	r3, [r0, #4]
  4015ee:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4015f2:	6043      	str	r3, [r0, #4]
  4015f4:	4770      	bx	lr
  4015f6:	bf00      	nop

004015f8 <dacc_set_power_save>:
 * \return \ref DACC_RC_OK if successful.
 */
uint32_t dacc_set_power_save(Dacc *p_dacc,
		uint32_t ul_sleep_mode, uint32_t ul_fast_wakeup_mode)
{
	if (ul_sleep_mode) {
  4015f8:	b121      	cbz	r1, 401604 <dacc_set_power_save+0xc>
		p_dacc->DACC_MR |= DACC_MR_SLEEP;
  4015fa:	6843      	ldr	r3, [r0, #4]
  4015fc:	f043 0320 	orr.w	r3, r3, #32
  401600:	6043      	str	r3, [r0, #4]
  401602:	e003      	b.n	40160c <dacc_set_power_save+0x14>
	} else {
		p_dacc->DACC_MR &= (~DACC_MR_SLEEP);
  401604:	6843      	ldr	r3, [r0, #4]
  401606:	f023 0320 	bic.w	r3, r3, #32
  40160a:	6043      	str	r3, [r0, #4]
	}
	if (ul_fast_wakeup_mode) {
  40160c:	b122      	cbz	r2, 401618 <dacc_set_power_save+0x20>
		p_dacc->DACC_MR |= DACC_MR_FASTWKUP;
  40160e:	6843      	ldr	r3, [r0, #4]
  401610:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401614:	6043      	str	r3, [r0, #4]
  401616:	e003      	b.n	401620 <dacc_set_power_save+0x28>
	} else {
		p_dacc->DACC_MR &= (~DACC_MR_FASTWKUP);
  401618:	6843      	ldr	r3, [r0, #4]
  40161a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  40161e:	6043      	str	r3, [r0, #4]
	}
	return DACC_RC_OK;
}
  401620:	f04f 0000 	mov.w	r0, #0
  401624:	4770      	bx	lr
  401626:	bf00      	nop

00401628 <dacc_set_timing>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_timing(Dacc *p_dacc,
		uint32_t ul_refresh, uint32_t ul_maxs, uint32_t ul_startup)
{
  401628:	b410      	push	{r4}
	uint32_t mr = p_dacc->DACC_MR
  40162a:	6844      	ldr	r4, [r0, #4]
  40162c:	f024 547c 	bic.w	r4, r4, #1056964608	; 0x3f000000
  401630:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00
		& (~(DACC_MR_REFRESH_Msk | DACC_MR_STARTUP_Msk));
	mr |= DACC_MR_REFRESH(ul_refresh);
  401634:	ea4f 6101 	mov.w	r1, r1, lsl #24
  401638:	ea44 4411 	orr.w	r4, r4, r1, lsr #16
	if (ul_maxs) {
  40163c:	b112      	cbz	r2, 401644 <dacc_set_timing+0x1c>
		mr |= DACC_MR_MAXS;
  40163e:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
  401642:	e001      	b.n	401648 <dacc_set_timing+0x20>
	} else {
		mr &= ~DACC_MR_MAXS;
  401644:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
	}
	mr |= (DACC_MR_STARTUP_Msk & ((ul_startup) << DACC_MR_STARTUP_Pos));
  401648:	ea4f 6303 	mov.w	r3, r3, lsl #24
  40164c:	f003 537c 	and.w	r3, r3, #1056964608	; 0x3f000000
  401650:	431c      	orrs	r4, r3
	p_dacc->DACC_MR = mr;
  401652:	6044      	str	r4, [r0, #4]
	return DACC_RC_OK;
}
  401654:	f04f 0000 	mov.w	r0, #0
  401658:	bc10      	pop	{r4}
  40165a:	4770      	bx	lr

0040165c <dacc_enable_channel>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_enable_channel(Dacc *p_dacc, uint32_t ul_channel)
{
	if (ul_channel > MAX_CH_NB)
  40165c:	2901      	cmp	r1, #1
		return DACC_RC_INVALID_PARAM;

	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
  40165e:	bf9f      	itttt	ls
  401660:	2301      	movls	r3, #1
  401662:	fa03 f101 	lslls.w	r1, r3, r1
  401666:	6101      	strls	r1, [r0, #16]
	return DACC_RC_OK;
  401668:	2000      	movls	r0, #0
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_enable_channel(Dacc *p_dacc, uint32_t ul_channel)
{
	if (ul_channel > MAX_CH_NB)
		return DACC_RC_INVALID_PARAM;
  40166a:	bf88      	it	hi
  40166c:	2001      	movhi	r0, #1

	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
	return DACC_RC_OK;
}
  40166e:	4770      	bx	lr

00401670 <dacc_set_analog_control>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_analog_control(Dacc *p_dacc, uint32_t ul_analog_control)
{
	p_dacc->DACC_ACR = ul_analog_control;
  401670:	f8c0 1094 	str.w	r1, [r0, #148]	; 0x94
	return DACC_RC_OK;
}
  401674:	f04f 0000 	mov.w	r0, #0
  401678:	4770      	bx	lr
  40167a:	bf00      	nop

0040167c <hsmci_reset>:

/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
  40167c:	b470      	push	{r4, r5, r6}
	uint32_t mr = HSMCI->HSMCI_MR;
  40167e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401682:	685d      	ldr	r5, [r3, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401684:	689c      	ldr	r4, [r3, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401686:	68d8      	ldr	r0, [r3, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401688:	69d9      	ldr	r1, [r3, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40168a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40168c:	f04f 0680 	mov.w	r6, #128	; 0x80
  401690:	601e      	str	r6, [r3, #0]
	HSMCI->HSMCI_MR = mr;
  401692:	605d      	str	r5, [r3, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401694:	609c      	str	r4, [r3, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401696:	60d8      	str	r0, [r3, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401698:	61d9      	str	r1, [r3, #28]
	HSMCI->HSMCI_CFG = cfg;
  40169a:	655a      	str	r2, [r3, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40169c:	f04f 0205 	mov.w	r2, #5
  4016a0:	601a      	str	r2, [r3, #0]
}
  4016a2:	bc70      	pop	{r4, r5, r6}
  4016a4:	4770      	bx	lr
  4016a6:	bf00      	nop

004016a8 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  4016a8:	b508      	push	{r3, lr}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  4016aa:	f001 033f 	and.w	r3, r1, #63	; 0x3f
  4016ae:	4318      	orrs	r0, r3
	if (cmd & SDMMC_RESP_PRESENT) {
  4016b0:	f411 7f80 	tst.w	r1, #256	; 0x100
  4016b4:	d00c      	beq.n	4016d0 <hsmci_send_cmd_execute+0x28>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  4016b6:	f411 6f00 	tst.w	r1, #2048	; 0x800
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  4016ba:	bf18      	it	ne
  4016bc:	f440 5084 	orrne.w	r0, r0, #4224	; 0x1080
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  4016c0:	d106      	bne.n	4016d0 <hsmci_send_cmd_execute+0x28>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  4016c2:	f411 5f00 	tst.w	r1, #8192	; 0x2000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  4016c6:	bf14      	ite	ne
  4016c8:	f440 5086 	orrne.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  4016cc:	f440 5082 	orreq.w	r0, r0, #4160	; 0x1040
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  4016d0:	f411 4f80 	tst.w	r1, #16384	; 0x4000
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  4016d4:	bf18      	it	ne
  4016d6:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  4016da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4016de:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  4016e0:	6158      	str	r0, [r3, #20]

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  4016e2:	4618      	mov	r0, r3
		if (cmd & SDMMC_RESP_CRC) {
  4016e4:	f401 5280 	and.w	r2, r1, #4096	; 0x1000
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  4016e8:	6c03      	ldr	r3, [r0, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  4016ea:	b152      	cbz	r2, 401702 <hsmci_send_cmd_execute+0x5a>
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  4016ec:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  4016f0:	d012      	beq.n	401718 <hsmci_send_cmd_execute+0x70>
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  4016f2:	f241 637d 	movw	r3, #5757	; 0x167d
  4016f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4016fa:	4798      	blx	r3
				return false;
  4016fc:	f04f 0000 	mov.w	r0, #0
  401700:	bd08      	pop	{r3, pc}
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401702:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401706:	d007      	beq.n	401718 <hsmci_send_cmd_execute+0x70>
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  401708:	f241 637d 	movw	r3, #5757	; 0x167d
  40170c:	f2c0 0340 	movt	r3, #64	; 0x40
  401710:	4798      	blx	r3
				return false;
  401712:	f04f 0000 	mov.w	r0, #0
  401716:	bd08      	pop	{r3, pc}
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401718:	f013 0f01 	tst.w	r3, #1
  40171c:	d0e4      	beq.n	4016e8 <hsmci_send_cmd_execute+0x40>

	if (cmd & SDMMC_RESP_BUSY) {
  40171e:	f411 5f00 	tst.w	r1, #8192	; 0x2000
  401722:	d114      	bne.n	40174e <hsmci_send_cmd_execute+0xa6>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401724:	f04f 0001 	mov.w	r0, #1
  401728:	bd08      	pop	{r3, pc}
{
	uint32_t busy_wait = 1000000;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  40172a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  40172c:	3b01      	subs	r3, #1
  40172e:	d107      	bne.n	401740 <hsmci_send_cmd_execute+0x98>
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
  401730:	f241 637d 	movw	r3, #5757	; 0x167d
  401734:	f2c0 0340 	movt	r3, #64	; 0x40
  401738:	4798      	blx	r3
			return false;
  40173a:	f04f 0000 	mov.w	r0, #0
  40173e:	bd08      	pop	{r3, pc}
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401740:	f002 0230 	and.w	r2, r2, #48	; 0x30
  401744:	2a20      	cmp	r2, #32
  401746:	d1f0      	bne.n	40172a <hsmci_send_cmd_execute+0x82>
	return true;
  401748:	f04f 0001 	mov.w	r0, #1
  40174c:	bd08      	pop	{r3, pc}
{
	uint32_t busy_wait = 1000000;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  40174e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401752:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  401754:	f244 2340 	movw	r3, #16960	; 0x4240
  401758:	f2c0 030f 	movt	r3, #15
  40175c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401760:	e7ee      	b.n	401740 <hsmci_send_cmd_execute+0x98>
  401762:	bf00      	nop

00401764 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401764:	b508      	push	{r3, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  401766:	f04f 0012 	mov.w	r0, #18
  40176a:	f242 0391 	movw	r3, #8337	; 0x2091
  40176e:	f2c0 0340 	movt	r3, #64	; 0x40
  401772:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401774:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401778:	f04f 0272 	mov.w	r2, #114	; 0x72
  40177c:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  40177e:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401780:	f04f 0211 	mov.w	r2, #17
  401784:	655a      	str	r2, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401786:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  40178a:	605a      	str	r2, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  40178c:	f04f 0205 	mov.w	r2, #5
  401790:	601a      	str	r2, [r3, #0]
  401792:	bd08      	pop	{r3, pc}

00401794 <hsmci_get_bus_width>:
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401794:	2800      	cmp	r0, #0
  401796:	bf0c      	ite	eq
  401798:	2004      	moveq	r0, #4
  40179a:	2000      	movne	r0, #0
  40179c:	4770      	bx	lr
  40179e:	bf00      	nop

004017a0 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  4017a0:	f04f 0001 	mov.w	r0, #1
  4017a4:	4770      	bx	lr
  4017a6:	bf00      	nop

004017a8 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  4017a8:	b133      	cbz	r3, 4017b8 <hsmci_select_device+0x10>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  4017aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017ae:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4017b0:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  4017b4:	6558      	str	r0, [r3, #84]	; 0x54
  4017b6:	e005      	b.n	4017c4 <hsmci_select_device+0x1c>
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4017b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017bc:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4017be:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  4017c2:	6558      	str	r0, [r3, #84]	; 0x54
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
  4017c4:	f04f 0000 	mov.w	r0, #0
{
	uint32_t clkdiv;
	uint32_t rest;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if (speed > 0) {
  4017c8:	b181      	cbz	r1, 4017ec <hsmci_select_device+0x44>
		clkdiv = mck / (2 * speed);
  4017ca:	ea4f 0141 	mov.w	r1, r1, lsl #1
  4017ce:	f44f 6360 	mov.w	r3, #3584	; 0xe00
  4017d2:	f2c0 7327 	movt	r3, #1831	; 0x727
  4017d6:	fbb3 f0f1 	udiv	r0, r3, r1
		rest = mck % (2 * speed);
  4017da:	fb01 3110 	mls	r1, r1, r0, r3
		if (rest > 0) {
  4017de:	b109      	cbz	r1, 4017e4 <hsmci_select_device+0x3c>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  4017e0:	f100 0001 	add.w	r0, r0, #1
		}
		if (clkdiv > 0) {
  4017e4:	b110      	cbz	r0, 4017ec <hsmci_select_device+0x44>
			clkdiv -= 1;
  4017e6:	f100 30ff 	add.w	r0, r0, #4294967295
  4017ea:	e7ff      	b.n	4017ec <hsmci_select_device+0x44>
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  4017ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017f0:	6859      	ldr	r1, [r3, #4]
  4017f2:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  4017f6:	6059      	str	r1, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  4017f8:	6859      	ldr	r1, [r3, #4]
  4017fa:	b2c0      	uxtb	r0, r0
  4017fc:	4308      	orrs	r0, r1
  4017fe:	6058      	str	r0, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401800:	2a04      	cmp	r2, #4
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401802:	bf08      	it	eq
  401804:	2280      	moveq	r2, #128	; 0x80
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401806:	d004      	beq.n	401812 <hsmci_select_device+0x6a>
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401808:	2a08      	cmp	r2, #8
  40180a:	bf0c      	ite	eq
  40180c:	22c0      	moveq	r2, #192	; 0xc0
  40180e:	2200      	movne	r2, #0
  401810:	e7ff      	b.n	401812 <hsmci_select_device+0x6a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401812:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401816:	60da      	str	r2, [r3, #12]
  401818:	4770      	bx	lr
  40181a:	bf00      	nop

0040181c <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  40181c:	4770      	bx	lr
  40181e:	bf00      	nop

00401820 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401820:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401824:	685a      	ldr	r2, [r3, #4]
  401826:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  40182a:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  40182c:	f04f 0200 	mov.w	r2, #0
  401830:	611a      	str	r2, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401832:	f44f 6210 	mov.w	r2, #2304	; 0x900
  401836:	615a      	str	r2, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401838:	461a      	mov	r2, r3
  40183a:	6c13      	ldr	r3, [r2, #64]	; 0x40
  40183c:	f013 0f01 	tst.w	r3, #1
  401840:	d0fb      	beq.n	40183a <hsmci_send_clock+0x1a>
}
  401842:	4770      	bx	lr

00401844 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401844:	b510      	push	{r4, lr}
  401846:	4604      	mov	r4, r0
  401848:	460a      	mov	r2, r1
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  40184a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  40184e:	6859      	ldr	r1, [r3, #4]
  401850:	f421 5160 	bic.w	r1, r1, #14336	; 0x3800
  401854:	6059      	str	r1, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401856:	6859      	ldr	r1, [r3, #4]
  401858:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
  40185c:	6059      	str	r1, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
  40185e:	f04f 0000 	mov.w	r0, #0
  401862:	6198      	str	r0, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401864:	4621      	mov	r1, r4
  401866:	f241 63a9 	movw	r3, #5801	; 0x16a9
  40186a:	f2c0 0340 	movt	r3, #64	; 0x40
  40186e:	4798      	blx	r3
}
  401870:	bd10      	pop	{r4, pc}
  401872:	bf00      	nop

00401874 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401874:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401878:	6a18      	ldr	r0, [r3, #32]
}
  40187a:	4770      	bx	lr

0040187c <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  40187c:	b410      	push	{r4}
uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
}

void hsmci_get_response_128(uint8_t* response)
  40187e:	f100 0410 	add.w	r4, r0, #16
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  401882:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401886:	6a0b      	ldr	r3, [r1, #32]
		*response = (response_32 >> 24) & 0xFF;
  401888:	ea4f 6213 	mov.w	r2, r3, lsr #24
  40188c:	7002      	strb	r2, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  40188e:	ea4f 4213 	mov.w	r2, r3, lsr #16
  401892:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401894:	ea4f 2213 	mov.w	r2, r3, lsr #8
  401898:	7082      	strb	r2, [r0, #2]
		response++;
		*response = (response_32 >>  0) & 0xFF;
  40189a:	70c3      	strb	r3, [r0, #3]
uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
}

void hsmci_get_response_128(uint8_t* response)
  40189c:	f100 0004 	add.w	r0, r0, #4
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  4018a0:	4284      	cmp	r4, r0
  4018a2:	d1f0      	bne.n	401886 <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  4018a4:	bc10      	pop	{r4}
  4018a6:	4770      	bx	lr

004018a8 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  4018a8:	b570      	push	{r4, r5, r6, lr}
  4018aa:	4604      	mov	r4, r0
  4018ac:	460e      	mov	r6, r1
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  4018ae:	f89d 1010 	ldrb.w	r1, [sp, #16]
  4018b2:	b131      	cbz	r1, 4018c2 <hsmci_adtc_start+0x1a>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  4018b4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4018b8:	6848      	ldr	r0, [r1, #4]
  4018ba:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  4018be:	6048      	str	r0, [r1, #4]
  4018c0:	e005      	b.n	4018ce <hsmci_adtc_start+0x26>
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  4018c2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4018c6:	6848      	ldr	r0, [r1, #4]
  4018c8:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  4018cc:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  4018ce:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4018d2:	6841      	ldr	r1, [r0, #4]
  4018d4:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  4018d8:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
  4018da:	f012 0f03 	tst.w	r2, #3
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4018de:	bf1d      	ittte	ne
  4018e0:	4601      	movne	r1, r0
  4018e2:	6848      	ldrne	r0, [r1, #4]
  4018e4:	f440 5000 	orrne.w	r0, r0, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4018e8:	f04f 4180 	moveq.w	r1, #1073741824	; 0x40000000
  4018ec:	bf04      	itt	eq
  4018ee:	6848      	ldreq	r0, [r1, #4]
  4018f0:	f420 5000 	biceq.w	r0, r0, #8192	; 0x2000
  4018f4:	6048      	str	r0, [r1, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
  4018f6:	f404 4000 	and.w	r0, r4, #32768	; 0x8000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  4018fa:	2800      	cmp	r0, #0
  4018fc:	bf0c      	ite	eq
  4018fe:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  401902:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401906:	f414 3f80 	tst.w	r4, #65536	; 0x10000
  40190a:	d005      	beq.n	401918 <hsmci_adtc_start+0x70>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  40190c:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BCNT_Pos);
  401910:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401914:	618a      	str	r2, [r1, #24]
  401916:	e018      	b.n	40194a <hsmci_adtc_start+0xa2>
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401918:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  40191c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401920:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  401922:	f414 3f00 	tst.w	r4, #131072	; 0x20000
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  401926:	bf18      	it	ne
  401928:	f440 1020 	orrne.w	r0, r0, #2621440	; 0x280000
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  40192c:	d10d      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  40192e:	f414 2f80 	tst.w	r4, #262144	; 0x40000
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  401932:	bf18      	it	ne
  401934:	f440 1080 	orrne.w	r0, r0, #1048576	; 0x100000
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401938:	d107      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  40193a:	f414 2f00 	tst.w	r4, #524288	; 0x80000
  40193e:	d104      	bne.n	40194a <hsmci_adtc_start+0xa2>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  401940:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401944:	bf18      	it	ne
  401946:	f440 2000 	orrne.w	r0, r0, #524288	; 0x80000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  40194a:	f240 4588 	movw	r5, #1160	; 0x488
  40194e:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401952:	f04f 0100 	mov.w	r1, #0
  401956:	6029      	str	r1, [r5, #0]
	hsmci_block_size = block_size;
  401958:	f240 4584 	movw	r5, #1156	; 0x484
  40195c:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401960:	802a      	strh	r2, [r5, #0]
	hsmci_nb_block = nb_block;
  401962:	f240 4586 	movw	r5, #1158	; 0x486
  401966:	f2c2 0500 	movt	r5, #8192	; 0x2000
  40196a:	802b      	strh	r3, [r5, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  40196c:	4621      	mov	r1, r4
  40196e:	4632      	mov	r2, r6
  401970:	f241 63a9 	movw	r3, #5801	; 0x16a9
  401974:	f2c0 0340 	movt	r3, #64	; 0x40
  401978:	4798      	blx	r3
}
  40197a:	bd70      	pop	{r4, r5, r6, pc}

0040197c <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  40197c:	b508      	push	{r3, lr}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40197e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401982:	f04f 0200 	mov.w	r2, #0
  401986:	f2cc 0260 	movt	r2, #49248	; 0xc060

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40198a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40198c:	4213      	tst	r3, r2
  40198e:	d007      	beq.n	4019a0 <hsmci_read_word+0x24>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  401990:	f241 637d 	movw	r3, #5757	; 0x167d
  401994:	f2c0 0340 	movt	r3, #64	; 0x40
  401998:	4798      	blx	r3
			return false;
  40199a:	f04f 0000 	mov.w	r0, #0
  40199e:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  4019a0:	f013 0f02 	tst.w	r3, #2
  4019a4:	d0f1      	beq.n	40198a <hsmci_read_word+0xe>

	// Read data
	*value = HSMCI->HSMCI_RDR;
  4019a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4019aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4019ac:	6003      	str	r3, [r0, #0]
	hsmci_transfert_pos += 4;
  4019ae:	f240 4388 	movw	r3, #1160	; 0x488
  4019b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019b6:	681a      	ldr	r2, [r3, #0]
  4019b8:	f102 0204 	add.w	r2, r2, #4
  4019bc:	601a      	str	r2, [r3, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  4019be:	f240 4386 	movw	r3, #1158	; 0x486
  4019c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019c6:	8819      	ldrh	r1, [r3, #0]
  4019c8:	f240 4384 	movw	r3, #1156	; 0x484
  4019cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4019d0:	881b      	ldrh	r3, [r3, #0]
  4019d2:	fb03 f301 	mul.w	r3, r3, r1
  4019d6:	429a      	cmp	r2, r3
  4019d8:	d316      	bcc.n	401a08 <hsmci_read_word+0x8c>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  4019da:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4019de:	f04f 0200 	mov.w	r2, #0
  4019e2:	f2cc 0260 	movt	r2, #49248	; 0xc060
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  4019e6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4019e8:	4213      	tst	r3, r2
  4019ea:	d007      	beq.n	4019fc <hsmci_read_word+0x80>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  4019ec:	f241 637d 	movw	r3, #5757	; 0x167d
  4019f0:	f2c0 0340 	movt	r3, #64	; 0x40
  4019f4:	4798      	blx	r3
			return false;
  4019f6:	f04f 0000 	mov.w	r0, #0
  4019fa:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  4019fc:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401a00:	d0f1      	beq.n	4019e6 <hsmci_read_word+0x6a>
	return true;
  401a02:	f04f 0001 	mov.w	r0, #1
  401a06:	bd08      	pop	{r3, pc}

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  401a08:	f04f 0001 	mov.w	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401a0c:	bd08      	pop	{r3, pc}
  401a0e:	bf00      	nop

00401a10 <hsmci_start_read_blocks>:
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401a10:	f240 4384 	movw	r3, #1156	; 0x484
  401a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a18:	881b      	ldrh	r3, [r3, #0]
  401a1a:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  401a1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a22:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401a26:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  401a28:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401a2c:	bf0c      	ite	eq
  401a2e:	088a      	lsreq	r2, r1, #2
  401a30:	460a      	movne	r2, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401a32:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a36:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  401a3a:	f04f 0200 	mov.w	r2, #0
  401a3e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	// Start transfert
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  401a42:	f04f 0001 	mov.w	r0, #1
  401a46:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401a4a:	f240 4388 	movw	r3, #1160	; 0x488
  401a4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a52:	681a      	ldr	r2, [r3, #0]
  401a54:	1889      	adds	r1, r1, r2
  401a56:	6019      	str	r1, [r3, #0]
	return true;
}
  401a58:	4770      	bx	lr
  401a5a:	bf00      	nop

00401a5c <hsmci_wait_end_of_read_blocks>:

bool hsmci_wait_end_of_read_blocks(void)
{
  401a5c:	b508      	push	{r3, lr}
	uint32_t sr;
	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401a5e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401a62:	f04f 0200 	mov.w	r2, #0
  401a66:	f2cc 0260 	movt	r2, #49248	; 0xc060
{
	uint32_t sr;
	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401a6a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401a6c:	4213      	tst	r3, r2
  401a6e:	d00d      	beq.n	401a8c <hsmci_wait_end_of_read_blocks+0x30>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401a70:	f240 2202 	movw	r2, #514	; 0x202
  401a74:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401a78:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			hsmci_reset();
  401a7c:	f241 637d 	movw	r3, #5757	; 0x167d
  401a80:	f2c0 0340 	movt	r3, #64	; 0x40
  401a84:	4798      	blx	r3
			return false;
  401a86:	f04f 0000 	mov.w	r0, #0
  401a8a:	bd08      	pop	{r3, pc}
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  401a8c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  401a90:	d0eb      	beq.n	401a6a <hsmci_wait_end_of_read_blocks+0xe>

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401a92:	f240 4386 	movw	r3, #1158	; 0x486
  401a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a9a:	881a      	ldrh	r2, [r3, #0]
  401a9c:	f240 4384 	movw	r3, #1156	; 0x484
  401aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401aa4:	881b      	ldrh	r3, [r3, #0]
  401aa6:	fb03 f202 	mul.w	r2, r3, r2
  401aaa:	f240 4388 	movw	r3, #1160	; 0x488
  401aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401ab2:	681b      	ldr	r3, [r3, #0]
  401ab4:	429a      	cmp	r2, r3
  401ab6:	d816      	bhi.n	401ae6 <hsmci_wait_end_of_read_blocks+0x8a>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ab8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401abc:	f04f 0200 	mov.w	r2, #0
  401ac0:	f2cc 0260 	movt	r2, #49248	; 0xc060
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ac4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401ac6:	4213      	tst	r3, r2
  401ac8:	d007      	beq.n	401ada <hsmci_wait_end_of_read_blocks+0x7e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  401aca:	f241 637d 	movw	r3, #5757	; 0x167d
  401ace:	f2c0 0340 	movt	r3, #64	; 0x40
  401ad2:	4798      	blx	r3
			return false;
  401ad4:	f04f 0000 	mov.w	r0, #0
  401ad8:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401ada:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
  401ade:	d0f1      	beq.n	401ac4 <hsmci_wait_end_of_read_blocks+0x68>
	return true;
  401ae0:	f04f 0001 	mov.w	r0, #1
  401ae4:	bd08      	pop	{r3, pc}
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401ae6:	f04f 0001 	mov.w	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401aea:	bd08      	pop	{r3, pc}

00401aec <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401aec:	f240 4384 	movw	r3, #1156	; 0x484
  401af0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401af4:	881b      	ldrh	r3, [r3, #0]
  401af6:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_TPR = (uint32_t)src;
  401afa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401afe:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401b02:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
  401b04:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  401b08:	bf0c      	ite	eq
  401b0a:	088a      	lsreq	r2, r1, #2
  401b0c:	460a      	movne	r2, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Configure PDC transfert
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401b0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401b12:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  401b16:	f04f 0200 	mov.w	r2, #0
  401b1a:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
	// Start transfert
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401b1e:	f44f 7280 	mov.w	r2, #256	; 0x100
  401b22:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401b26:	f240 4388 	movw	r3, #1160	; 0x488
  401b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b2e:	681a      	ldr	r2, [r3, #0]
  401b30:	1889      	adds	r1, r1, r2
  401b32:	6019      	str	r1, [r3, #0]
	return true;
}
  401b34:	f04f 0001 	mov.w	r0, #1
  401b38:	4770      	bx	lr
  401b3a:	bf00      	nop

00401b3c <hsmci_wait_end_of_write_blocks>:

bool hsmci_wait_end_of_write_blocks(void)
{
  401b3c:	b508      	push	{r3, lr}
	uint32_t sr;

	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b3e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  401b42:	f04f 0200 	mov.w	r2, #0
  401b46:	f2cc 0260 	movt	r2, #49248	; 0xc060
	uint32_t sr;

	// Wait end of transfert
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b4a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr &
  401b4c:	4213      	tst	r3, r2
  401b4e:	d00d      	beq.n	401b6c <hsmci_wait_end_of_write_blocks+0x30>
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  401b50:	f241 637d 	movw	r3, #5757	; 0x167d
  401b54:	f2c0 0340 	movt	r3, #64	; 0x40
  401b58:	4798      	blx	r3
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401b5a:	f240 2202 	movw	r2, #514	; 0x202
  401b5e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401b62:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			return false;
  401b66:	f04f 0000 	mov.w	r0, #0
  401b6a:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  401b6c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401b70:	d0eb      	beq.n	401b4a <hsmci_wait_end_of_write_blocks+0xe>


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401b72:	f240 4386 	movw	r3, #1158	; 0x486
  401b76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b7a:	881a      	ldrh	r2, [r3, #0]
  401b7c:	f240 4384 	movw	r3, #1156	; 0x484
  401b80:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b84:	881b      	ldrh	r3, [r3, #0]
  401b86:	fb03 f202 	mul.w	r2, r3, r2
  401b8a:	f240 4388 	movw	r3, #1160	; 0x488
  401b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401b92:	681b      	ldr	r3, [r3, #0]
  401b94:	429a      	cmp	r2, r3
  401b96:	d816      	bhi.n	401bc6 <hsmci_wait_end_of_write_blocks+0x8a>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401b98:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401b9c:	f04f 0200 	mov.w	r2, #0
  401ba0:	f2cc 0260 	movt	r2, #49248	; 0xc060
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401ba4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401ba6:	4213      	tst	r3, r2
  401ba8:	d007      	beq.n	401bba <hsmci_wait_end_of_write_blocks+0x7e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  401baa:	f241 637d 	movw	r3, #5757	; 0x167d
  401bae:	f2c0 0340 	movt	r3, #64	; 0x40
  401bb2:	4798      	blx	r3
			return false;
  401bb4:	f04f 0000 	mov.w	r0, #0
  401bb8:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  401bba:	f013 0f20 	tst.w	r3, #32
  401bbe:	d0f1      	beq.n	401ba4 <hsmci_wait_end_of_write_blocks+0x68>
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
  401bc0:	f04f 0001 	mov.w	r0, #1
  401bc4:	bd08      	pop	{r3, pc}
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401bc6:	f04f 0001 	mov.w	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  401bca:	bd08      	pop	{r3, pc}

00401bcc <pio_pull_up>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  401bcc:	b10a      	cbz	r2, 401bd2 <pio_pull_up+0x6>
		p_pio->PIO_PUER = ul_mask;
  401bce:	6641      	str	r1, [r0, #100]	; 0x64
  401bd0:	4770      	bx	lr
	} else {
		p_pio->PIO_PUDR = ul_mask;
  401bd2:	6601      	str	r1, [r0, #96]	; 0x60
  401bd4:	4770      	bx	lr
  401bd6:	bf00      	nop

00401bd8 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  401bd8:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  401bda:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S)
	switch (ul_type) {
  401bdc:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  401be0:	d02f      	beq.n	401c42 <pio_set_peripheral+0x6a>
  401be2:	d808      	bhi.n	401bf6 <pio_set_peripheral+0x1e>
  401be4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  401be8:	d014      	beq.n	401c14 <pio_set_peripheral+0x3c>
  401bea:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  401bee:	d01e      	beq.n	401c2e <pio_set_peripheral+0x56>
  401bf0:	2900      	cmp	r1, #0
  401bf2:	d037      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401bf4:	e035      	b.n	401c62 <pio_set_peripheral+0x8a>
  401bf6:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  401bfa:	d033      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401bfc:	d803      	bhi.n	401c06 <pio_set_peripheral+0x2e>
  401bfe:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  401c02:	d12e      	bne.n	401c62 <pio_set_peripheral+0x8a>
  401c04:	e027      	b.n	401c56 <pio_set_peripheral+0x7e>
  401c06:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  401c0a:	d02b      	beq.n	401c64 <pio_set_peripheral+0x8c>
  401c0c:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  401c10:	d127      	bne.n	401c62 <pio_set_peripheral+0x8a>
  401c12:	e027      	b.n	401c64 <pio_set_peripheral+0x8c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c14:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401c16:	6f04      	ldr	r4, [r0, #112]	; 0x70
  401c18:	ea6f 0302 	mvn.w	r3, r2
  401c1c:	4021      	ands	r1, r4
  401c1e:	4019      	ands	r1, r3
  401c20:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c22:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401c24:	6f44      	ldr	r4, [r0, #116]	; 0x74
  401c26:	4021      	ands	r1, r4
  401c28:	400b      	ands	r3, r1
  401c2a:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c2c:	e019      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c2e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401c30:	4313      	orrs	r3, r2
  401c32:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c34:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  401c36:	6f41      	ldr	r1, [r0, #116]	; 0x74
  401c38:	400b      	ands	r3, r1
  401c3a:	ea23 0302 	bic.w	r3, r3, r2
  401c3e:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c40:	e00f      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c42:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  401c44:	6f01      	ldr	r1, [r0, #112]	; 0x70
  401c46:	400b      	ands	r3, r1
  401c48:	ea23 0302 	bic.w	r3, r3, r2
  401c4c:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c4e:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401c50:	4313      	orrs	r3, r2
  401c52:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401c54:	e005      	b.n	401c62 <pio_set_peripheral+0x8a>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401c56:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401c58:	4313      	orrs	r3, r2
  401c5a:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401c5c:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401c5e:	4313      	orrs	r3, r2
  401c60:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
  401c62:	6042      	str	r2, [r0, #4]
}
  401c64:	bc10      	pop	{r4}
  401c66:	4770      	bx	lr

00401c68 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  401c68:	6441      	str	r1, [r0, #68]	; 0x44
  401c6a:	4770      	bx	lr

00401c6c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  401c6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401c70:	4604      	mov	r4, r0
  401c72:	460d      	mov	r5, r1
  401c74:	4617      	mov	r7, r2
  401c76:	4698      	mov	r8, r3
	pio_disable_interrupt(p_pio, ul_mask);
  401c78:	f641 4669 	movw	r6, #7273	; 0x1c69
  401c7c:	f2c0 0640 	movt	r6, #64	; 0x40
  401c80:	47b0      	blx	r6
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  401c82:	4620      	mov	r0, r4
  401c84:	4629      	mov	r1, r5
  401c86:	9a06      	ldr	r2, [sp, #24]
  401c88:	f641 36cd 	movw	r6, #7117	; 0x1bcd
  401c8c:	f2c0 0640 	movt	r6, #64	; 0x40
  401c90:	47b0      	blx	r6

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  401c92:	f1b8 0f00 	cmp.w	r8, #0
  401c96:	d001      	beq.n	401c9c <pio_set_output+0x30>
		p_pio->PIO_MDER = ul_mask;
  401c98:	6525      	str	r5, [r4, #80]	; 0x50
  401c9a:	e000      	b.n	401c9e <pio_set_output+0x32>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  401c9c:	6565      	str	r5, [r4, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  401c9e:	b10f      	cbz	r7, 401ca4 <pio_set_output+0x38>
		p_pio->PIO_SODR = ul_mask;
  401ca0:	6325      	str	r5, [r4, #48]	; 0x30
  401ca2:	e000      	b.n	401ca6 <pio_set_output+0x3a>
	} else {
		p_pio->PIO_CODR = ul_mask;
  401ca4:	6365      	str	r5, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  401ca6:	6125      	str	r5, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  401ca8:	6025      	str	r5, [r4, #0]
  401caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401cae:	bf00      	nop

00401cb0 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  401cb0:	b570      	push	{r4, r5, r6, lr}
  401cb2:	4604      	mov	r4, r0
  401cb4:	460d      	mov	r5, r1
  401cb6:	4616      	mov	r6, r2
	pio_disable_interrupt(p_pio, ul_mask);
  401cb8:	f641 4369 	movw	r3, #7273	; 0x1c69
  401cbc:	f2c0 0340 	movt	r3, #64	; 0x40
  401cc0:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  401cc2:	4620      	mov	r0, r4
  401cc4:	4629      	mov	r1, r5
  401cc6:	f006 0201 	and.w	r2, r6, #1
  401cca:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401cce:	f2c0 0340 	movt	r3, #64	; 0x40
  401cd2:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  401cd4:	f016 0f0a 	tst.w	r6, #10
		p_pio->PIO_IFER = ul_mask;
  401cd8:	bf14      	ite	ne
  401cda:	6225      	strne	r5, [r4, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  401cdc:	6265      	streq	r5, [r4, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  401cde:	f016 0f02 	tst.w	r6, #2
		p_pio->PIO_IFSCDR = ul_mask;
  401ce2:	bf18      	it	ne
  401ce4:	f8c4 5080 	strne.w	r5, [r4, #128]	; 0x80
		p_pio->PIO_IFDR = ul_mask;
	}

#if (SAM3S || SAM3N || SAM4S)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  401ce8:	d104      	bne.n	401cf4 <pio_set_input+0x44>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  401cea:	f016 0f08 	tst.w	r6, #8
			p_pio->PIO_IFSCER = ul_mask;
  401cee:	bf18      	it	ne
  401cf0:	f8c4 5084 	strne.w	r5, [r4, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  401cf4:	6165      	str	r5, [r4, #20]
	p_pio->PIO_PER = ul_mask;
  401cf6:	6025      	str	r5, [r4, #0]
  401cf8:	bd70      	pop	{r4, r5, r6, pc}
  401cfa:	bf00      	nop

00401cfc <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  401cfc:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  401cfe:	4770      	bx	lr

00401d00 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  401d00:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  401d02:	4770      	bx	lr

00401d04 <pio_set_pin_high>:
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d04:	ea4f 1350 	mov.w	r3, r0, lsr #5
  401d08:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d0c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d10:	ea4f 2343 	mov.w	r3, r3, lsl #9
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  401d14:	f000 001f 	and.w	r0, r0, #31
  401d18:	f04f 0201 	mov.w	r2, #1
  401d1c:	fa02 f000 	lsl.w	r0, r2, r0
  401d20:	6318      	str	r0, [r3, #48]	; 0x30
  401d22:	4770      	bx	lr

00401d24 <pio_set_pin_low>:
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d24:	ea4f 1350 	mov.w	r3, r0, lsr #5
  401d28:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d2c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d30:	ea4f 2343 	mov.w	r3, r3, lsl #9
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  401d34:	f000 001f 	and.w	r0, r0, #31
  401d38:	f04f 0201 	mov.w	r2, #1
  401d3c:	fa02 f000 	lsl.w	r0, r2, r0
  401d40:	6358      	str	r0, [r3, #52]	; 0x34
  401d42:	4770      	bx	lr

00401d44 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  401d44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401d48:	b082      	sub	sp, #8
  401d4a:	460d      	mov	r5, r1
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  401d4c:	ea4f 1650 	mov.w	r6, r0, lsr #5
  401d50:	f506 1600 	add.w	r6, r6, #2097152	; 0x200000
  401d54:	f206 7607 	addw	r6, r6, #1799	; 0x707
  401d58:	ea4f 2646 	mov.w	r6, r6, lsl #9

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  401d5c:	f001 44f0 	and.w	r4, r1, #2013265920	; 0x78000000
  401d60:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  401d64:	d064      	beq.n	401e30 <pio_configure_pin+0xec>
  401d66:	d80a      	bhi.n	401d7e <pio_configure_pin+0x3a>
  401d68:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  401d6c:	d02c      	beq.n	401dc8 <pio_configure_pin+0x84>
  401d6e:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  401d72:	d043      	beq.n	401dfc <pio_configure_pin+0xb8>
  401d74:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  401d78:	f040 809d 	bne.w	401eb6 <pio_configure_pin+0x172>
  401d7c:	e00a      	b.n	401d94 <pio_configure_pin+0x50>
  401d7e:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  401d82:	d07e      	beq.n	401e82 <pio_configure_pin+0x13e>
  401d84:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  401d88:	d07b      	beq.n	401e82 <pio_configure_pin+0x13e>
  401d8a:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  401d8e:	f040 8092 	bne.w	401eb6 <pio_configure_pin+0x172>
  401d92:	e067      	b.n	401e64 <pio_configure_pin+0x120>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  401d94:	f000 031f 	and.w	r3, r0, #31
  401d98:	f04f 0701 	mov.w	r7, #1
  401d9c:	fa07 f803 	lsl.w	r8, r7, r3
  401da0:	4630      	mov	r0, r6
  401da2:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401da6:	4642      	mov	r2, r8
  401da8:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401dac:	f2c0 0440 	movt	r4, #64	; 0x40
  401db0:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401db2:	4630      	mov	r0, r6
  401db4:	4641      	mov	r1, r8
  401db6:	ea05 0207 	and.w	r2, r5, r7
  401dba:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401dbe:	f2c0 0340 	movt	r3, #64	; 0x40
  401dc2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401dc4:	4638      	mov	r0, r7
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401dc6:	e078      	b.n	401eba <pio_configure_pin+0x176>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  401dc8:	f000 031f 	and.w	r3, r0, #31
  401dcc:	f04f 0701 	mov.w	r7, #1
  401dd0:	fa07 f803 	lsl.w	r8, r7, r3
  401dd4:	4630      	mov	r0, r6
  401dd6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  401dda:	4642      	mov	r2, r8
  401ddc:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401de0:	f2c0 0440 	movt	r4, #64	; 0x40
  401de4:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401de6:	4630      	mov	r0, r6
  401de8:	4641      	mov	r1, r8
  401dea:	ea05 0207 	and.w	r2, r5, r7
  401dee:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401df2:	f2c0 0340 	movt	r3, #64	; 0x40
  401df6:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401df8:	4638      	mov	r0, r7
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401dfa:	e05e      	b.n	401eba <pio_configure_pin+0x176>
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  401dfc:	f000 031f 	and.w	r3, r0, #31
  401e00:	f04f 0701 	mov.w	r7, #1
  401e04:	fa07 f803 	lsl.w	r8, r7, r3
  401e08:	4630      	mov	r0, r6
  401e0a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  401e0e:	4642      	mov	r2, r8
  401e10:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401e14:	f2c0 0440 	movt	r4, #64	; 0x40
  401e18:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401e1a:	4630      	mov	r0, r6
  401e1c:	4641      	mov	r1, r8
  401e1e:	ea05 0207 	and.w	r2, r5, r7
  401e22:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401e26:	f2c0 0340 	movt	r3, #64	; 0x40
  401e2a:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e2c:	4638      	mov	r0, r7
#     if (SAM3S || SAM3N || SAM4S)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401e2e:	e044      	b.n	401eba <pio_configure_pin+0x176>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  401e30:	f000 031f 	and.w	r3, r0, #31
  401e34:	f04f 0701 	mov.w	r7, #1
  401e38:	fa07 f803 	lsl.w	r8, r7, r3
  401e3c:	4630      	mov	r0, r6
  401e3e:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  401e42:	4642      	mov	r2, r8
  401e44:	f641 34d9 	movw	r4, #7129	; 0x1bd9
  401e48:	f2c0 0440 	movt	r4, #64	; 0x40
  401e4c:	47a0      	blx	r4
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401e4e:	4630      	mov	r0, r6
  401e50:	4641      	mov	r1, r8
  401e52:	ea05 0207 	and.w	r2, r5, r7
  401e56:	f641 33cd 	movw	r3, #7117	; 0x1bcd
  401e5a:	f2c0 0340 	movt	r3, #64	; 0x40
  401e5e:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e60:	4638      	mov	r0, r7
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401e62:	e02a      	b.n	401eba <pio_configure_pin+0x176>
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  401e64:	f000 011f 	and.w	r1, r0, #31
  401e68:	f04f 0401 	mov.w	r4, #1
  401e6c:	4630      	mov	r0, r6
  401e6e:	fa04 f101 	lsl.w	r1, r4, r1
  401e72:	462a      	mov	r2, r5
  401e74:	f641 43b1 	movw	r3, #7345	; 0x1cb1
  401e78:	f2c0 0340 	movt	r3, #64	; 0x40
  401e7c:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401e7e:	4620      	mov	r0, r4
		break;
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  401e80:	e01b      	b.n	401eba <pio_configure_pin+0x176>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401e82:	f000 031f 	and.w	r3, r0, #31
  401e86:	f04f 0701 	mov.w	r7, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  401e8a:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401e8e:	ea05 0107 	and.w	r1, r5, r7
  401e92:	9100      	str	r1, [sp, #0]
  401e94:	4630      	mov	r0, r6
  401e96:	fa07 f103 	lsl.w	r1, r7, r3
  401e9a:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  401e9e:	bf14      	ite	ne
  401ea0:	2200      	movne	r2, #0
  401ea2:	2201      	moveq	r2, #1
  401ea4:	f3c5 0380 	ubfx	r3, r5, #2, #1
  401ea8:	f641 446d 	movw	r4, #7277	; 0x1c6d
  401eac:	f2c0 0440 	movt	r4, #64	; 0x40
  401eb0:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
  401eb2:	4638      	mov	r0, r7
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  401eb4:	e001      	b.n	401eba <pio_configure_pin+0x176>

	default:
		return 0;
  401eb6:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  401eba:	b002      	add	sp, #8
  401ebc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00401ec0 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  401ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401ec2:	4604      	mov	r4, r0
  401ec4:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  401ec6:	f641 43fd 	movw	r3, #7421	; 0x1cfd
  401eca:	f2c0 0340 	movt	r3, #64	; 0x40
  401ece:	4798      	blx	r3
  401ed0:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  401ed2:	4620      	mov	r0, r4
  401ed4:	f641 5301 	movw	r3, #7425	; 0x1d01
  401ed8:	f2c0 0340 	movt	r3, #64	; 0x40
  401edc:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  401ede:	4005      	ands	r5, r0
  401ee0:	d014      	beq.n	401f0c <pio_handler_process+0x4c>
  401ee2:	4c0b      	ldr	r4, [pc, #44]	; (401f10 <pio_handler_process+0x50>)
 * \brief Process an interrupt request on the given PIO controller.
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
  401ee4:	4627      	mov	r7, r4
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  401ee6:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  401eea:	42b3      	cmp	r3, r6
  401eec:	d10a      	bne.n	401f04 <pio_handler_process+0x44>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  401eee:	f854 1c08 	ldr.w	r1, [r4, #-8]
  401ef2:	4229      	tst	r1, r5
  401ef4:	d006      	beq.n	401f04 <pio_handler_process+0x44>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  401ef6:	6823      	ldr	r3, [r4, #0]
  401ef8:	4630      	mov	r0, r6
  401efa:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  401efc:	f854 3c08 	ldr.w	r3, [r4, #-8]
  401f00:	ea25 0503 	bic.w	r5, r5, r3
  401f04:	f104 0410 	add.w	r4, r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  401f08:	2d00      	cmp	r5, #0
  401f0a:	d1eb      	bne.n	401ee4 <pio_handler_process+0x24>
  401f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401f0e:	bf00      	nop
  401f10:	20000498 	.word	0x20000498

00401f14 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  401f14:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  401f16:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  401f1a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f1e:	f04f 010b 	mov.w	r1, #11
  401f22:	f641 63c1 	movw	r3, #7873	; 0x1ec1
  401f26:	f2c0 0340 	movt	r3, #64	; 0x40
  401f2a:	4798      	blx	r3
  401f2c:	bd08      	pop	{r3, pc}
  401f2e:	bf00      	nop

00401f30 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  401f30:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  401f32:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  401f36:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f3a:	f04f 010c 	mov.w	r1, #12
  401f3e:	f641 63c1 	movw	r3, #7873	; 0x1ec1
  401f42:	f2c0 0340 	movt	r3, #64	; 0x40
  401f46:	4798      	blx	r3
  401f48:	bd08      	pop	{r3, pc}
  401f4a:	bf00      	nop

00401f4c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  401f4c:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  401f4e:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  401f52:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f56:	f04f 010d 	mov.w	r1, #13
  401f5a:	f641 63c1 	movw	r3, #7873	; 0x1ec1
  401f5e:	f2c0 0340 	movt	r3, #64	; 0x40
  401f62:	4798      	blx	r3
  401f64:	bd08      	pop	{r3, pc}
  401f66:	bf00      	nop

00401f68 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  401f68:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401f6c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401f70:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401f72:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  401f76:	4310      	orrs	r0, r2
  401f78:	6318      	str	r0, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401f7a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401f7c:	f013 0f08 	tst.w	r3, #8
  401f80:	bf02      	ittt	eq
  401f82:	f44f 6300 	moveq.w	r3, #2048	; 0x800
  401f86:	f44f 6180 	moveq.w	r1, #1024	; 0x400
  401f8a:	f2c4 010e 	movteq	r1, #16398	; 0x400e
  401f8e:	d003      	beq.n	401f98 <pmc_switch_mck_to_pllack+0x30>
  401f90:	e006      	b.n	401fa0 <pmc_switch_mck_to_pllack+0x38>
			--ul_timeout) {
		if (ul_timeout == 0) {
  401f92:	3b01      	subs	r3, #1
  401f94:	d100      	bne.n	401f98 <pmc_switch_mck_to_pllack+0x30>
  401f96:	e025      	b.n	401fe4 <pmc_switch_mck_to_pllack+0x7c>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401f98:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  401f9a:	f012 0f08 	tst.w	r2, #8
  401f9e:	d0f8      	beq.n	401f92 <pmc_switch_mck_to_pllack+0x2a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  401fa0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401fa4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401fa8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401faa:	f022 0203 	bic.w	r2, r2, #3
  401fae:	f042 0202 	orr.w	r2, r2, #2
  401fb2:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401fb4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401fb6:	f013 0f08 	tst.w	r3, #8
  401fba:	bf02      	ittt	eq
  401fbc:	f44f 6300 	moveq.w	r3, #2048	; 0x800
  401fc0:	f44f 6180 	moveq.w	r1, #1024	; 0x400
  401fc4:	f2c4 010e 	movteq	r1, #16398	; 0x400e
  401fc8:	d005      	beq.n	401fd6 <pmc_switch_mck_to_pllack+0x6e>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401fca:	f04f 0000 	mov.w	r0, #0
  401fce:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  401fd0:	3b01      	subs	r3, #1
  401fd2:	d100      	bne.n	401fd6 <pmc_switch_mck_to_pllack+0x6e>
  401fd4:	e009      	b.n	401fea <pmc_switch_mck_to_pllack+0x82>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401fd6:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  401fd8:	f012 0f08 	tst.w	r2, #8
  401fdc:	d0f8      	beq.n	401fd0 <pmc_switch_mck_to_pllack+0x68>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401fde:	f04f 0000 	mov.w	r0, #0
  401fe2:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401fe4:	f04f 0001 	mov.w	r0, #1
  401fe8:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401fea:	f04f 0001 	mov.w	r0, #1
		}
	}

	return 0;
}
  401fee:	4770      	bx	lr

00401ff0 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  401ff0:	b180      	cbz	r0, 402014 <pmc_switch_mainck_to_xtal+0x24>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  401ff2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401ff6:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401ffa:	6a0b      	ldr	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
  401ffc:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  402000:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  402004:	401a      	ands	r2, r3
  402006:	f04f 0302 	mov.w	r3, #2
  40200a:	f2c0 1337 	movt	r3, #311	; 0x137
  40200e:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402010:	620b      	str	r3, [r1, #32]
  402012:	4770      	bx	lr
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402014:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402018:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40201c:	6a1a      	ldr	r2, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  40201e:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  402022:	f022 0203 	bic.w	r2, r2, #3
  402026:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
  40202a:	f042 0201 	orr.w	r2, r2, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40202e:	ea4f 6101 	mov.w	r1, r1, lsl #24
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
  402032:	ea42 4111 	orr.w	r1, r2, r1, lsr #16
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402036:	6219      	str	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  402038:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40203c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  402040:	6e93      	ldr	r3, [r2, #104]	; 0x68
  402042:	f013 0f01 	tst.w	r3, #1
  402046:	d0fb      	beq.n	402040 <pmc_switch_mainck_to_xtal+0x50>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
  402048:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40204c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402050:	6a1a      	ldr	r2, [r3, #32]
  402052:	f042 729b 	orr.w	r2, r2, #20316160	; 0x1360000
  402056:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  40205a:	621a      	str	r2, [r3, #32]
  40205c:	4770      	bx	lr
  40205e:	bf00      	nop

00402060 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  402060:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402064:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402068:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40206a:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  40206e:	4770      	bx	lr

00402070 <pmc_disable_pllack>:
/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  402070:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402074:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402078:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40207c:	629a      	str	r2, [r3, #40]	; 0x28
  40207e:	4770      	bx	lr

00402080 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  402080:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402084:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402088:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40208a:	f000 0002 	and.w	r0, r0, #2
  40208e:	4770      	bx	lr

00402090 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  402090:	2822      	cmp	r0, #34	; 0x22
  402092:	d835      	bhi.n	402100 <pmc_enable_periph_clk+0x70>
		return 1;
	}

	if (ul_id < 32) {
  402094:	281f      	cmp	r0, #31
  402096:	d817      	bhi.n	4020c8 <pmc_enable_periph_clk+0x38>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  402098:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40209c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020a0:	699a      	ldr	r2, [r3, #24]
  4020a2:	f04f 0301 	mov.w	r3, #1
  4020a6:	fa03 f300 	lsl.w	r3, r3, r0
  4020aa:	401a      	ands	r2, r3
  4020ac:	4293      	cmp	r3, r2
  4020ae:	d02a      	beq.n	402106 <pmc_enable_periph_clk+0x76>
			PMC->PMC_PCER0 = 1 << ul_id;
  4020b0:	f04f 0301 	mov.w	r3, #1
  4020b4:	fa03 f000 	lsl.w	r0, r3, r0
  4020b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020bc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020c0:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  4020c2:	f04f 0000 	mov.w	r0, #0
  4020c6:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4020c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020cc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020d0:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
  4020d4:	f1a0 0020 	sub.w	r0, r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4020d8:	f04f 0301 	mov.w	r3, #1
  4020dc:	fa03 f300 	lsl.w	r3, r3, r0
  4020e0:	401a      	ands	r2, r3
  4020e2:	4293      	cmp	r3, r2
  4020e4:	d012      	beq.n	40210c <pmc_enable_periph_clk+0x7c>
			PMC->PMC_PCER1 = 1 << ul_id;
  4020e6:	f04f 0301 	mov.w	r3, #1
  4020ea:	fa03 f000 	lsl.w	r0, r3, r0
  4020ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4020f2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020f6:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  4020fa:	f04f 0000 	mov.w	r0, #0
  4020fe:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  402100:	f04f 0001 	mov.w	r0, #1
  402104:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  402106:	f04f 0000 	mov.w	r0, #0
  40210a:	4770      	bx	lr
  40210c:	f04f 0000 	mov.w	r0, #0
}
  402110:	4770      	bx	lr
  402112:	bf00      	nop

00402114 <rtc_set_hour_mode>:
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode. 
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  402114:	b121      	cbz	r1, 402120 <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  402116:	6843      	ldr	r3, [r0, #4]
  402118:	f043 0301 	orr.w	r3, r3, #1
  40211c:	6043      	str	r3, [r0, #4]
  40211e:	4770      	bx	lr
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  402120:	6843      	ldr	r3, [r0, #4]
  402122:	f023 0301 	bic.w	r3, r3, #1
  402126:	6043      	str	r3, [r0, #4]
  402128:	4770      	bx	lr
  40212a:	bf00      	nop

0040212c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40212c:	e7fe      	b.n	40212c <Dummy_Handler>
  40212e:	bf00      	nop

00402130 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  402130:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
  402132:	f644 4250 	movw	r2, #19536	; 0x4c50
  402136:	f2c0 0240 	movt	r2, #64	; 0x40
  40213a:	f240 0300 	movw	r3, #0
  40213e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402142:	429a      	cmp	r2, r3
  402144:	d003      	beq.n	40214e <Reset_Handler+0x1e>
		for (; pDest < &_erelocate;) {
  402146:	4b2a      	ldr	r3, [pc, #168]	; (4021f0 <Reset_Handler+0xc0>)
  402148:	4a2a      	ldr	r2, [pc, #168]	; (4021f4 <Reset_Handler+0xc4>)
  40214a:	429a      	cmp	r2, r3
  40214c:	d304      	bcc.n	402158 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40214e:	4b2a      	ldr	r3, [pc, #168]	; (4021f8 <Reset_Handler+0xc8>)
  402150:	4a2a      	ldr	r2, [pc, #168]	; (4021fc <Reset_Handler+0xcc>)
  402152:	429a      	cmp	r2, r3
  402154:	d318      	bcc.n	402188 <Reset_Handler+0x58>
  402156:	e027      	b.n	4021a8 <Reset_Handler+0x78>

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  402158:	4b29      	ldr	r3, [pc, #164]	; (402200 <Reset_Handler+0xd0>)
  40215a:	4c2a      	ldr	r4, [pc, #168]	; (402204 <Reset_Handler+0xd4>)
  40215c:	1ae4      	subs	r4, r4, r3
  40215e:	f024 0403 	bic.w	r4, r4, #3
  402162:	f104 0404 	add.w	r4, r4, #4
  402166:	f04f 0300 	mov.w	r3, #0
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  40216a:	f240 0000 	movw	r0, #0
  40216e:	f2c2 0000 	movt	r0, #8192	; 0x2000
  402172:	f644 4150 	movw	r1, #19536	; 0x4c50
  402176:	f2c0 0140 	movt	r1, #64	; 0x40
  40217a:	585a      	ldr	r2, [r3, r1]
  40217c:	501a      	str	r2, [r3, r0]
  40217e:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
  402182:	42a3      	cmp	r3, r4
  402184:	d1f9      	bne.n	40217a <Reset_Handler+0x4a>
  402186:	e7e2      	b.n	40214e <Reset_Handler+0x1e>
  402188:	4b1f      	ldr	r3, [pc, #124]	; (402208 <Reset_Handler+0xd8>)

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  40218a:	4920      	ldr	r1, [pc, #128]	; (40220c <Reset_Handler+0xdc>)
  40218c:	1ac9      	subs	r1, r1, r3
  40218e:	f021 0103 	bic.w	r1, r1, #3
  402192:	f240 423c 	movw	r2, #1084	; 0x43c
  402196:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40219a:	188a      	adds	r2, r1, r2
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  40219c:	f04f 0100 	mov.w	r1, #0
  4021a0:	f843 1f04 	str.w	r1, [r3, #4]!
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4021a4:	4293      	cmp	r3, r2
  4021a6:	d1fb      	bne.n	4021a0 <Reset_Handler+0x70>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4021a8:	f240 0300 	movw	r3, #0
  4021ac:	f2c0 0340 	movt	r3, #64	; 0x40
  4021b0:	f023 017f 	bic.w	r1, r3, #127	; 0x7f
  4021b4:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4021b8:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4021bc:	6091      	str	r1, [r2, #8]

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4021be:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  4021c2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4021c6:	bf3f      	itttt	cc
  4021c8:	f44f 436d 	movcc.w	r3, #60672	; 0xed00
  4021cc:	f2ce 0300 	movtcc	r3, #57344	; 0xe000
  4021d0:	689a      	ldrcc	r2, [r3, #8]
  4021d2:	f042 5200 	orrcc.w	r2, r2, #536870912	; 0x20000000
  4021d6:	bf38      	it	cc
  4021d8:	609a      	strcc	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4021da:	f244 2305 	movw	r3, #16901	; 0x4205
  4021de:	f2c0 0340 	movt	r3, #64	; 0x40
  4021e2:	4798      	blx	r3

	/* Branch to main function */
	main();
  4021e4:	f643 7355 	movw	r3, #16213	; 0x3f55
  4021e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4021ec:	4798      	blx	r3
  4021ee:	e7fe      	b.n	4021ee <Reset_Handler+0xbe>
  4021f0:	2000043c 	.word	0x2000043c
  4021f4:	20000000 	.word	0x20000000
  4021f8:	20000e84 	.word	0x20000e84
  4021fc:	2000043c 	.word	0x2000043c
  402200:	20000004 	.word	0x20000004
  402204:	2000043f 	.word	0x2000043f
  402208:	20000438 	.word	0x20000438
  40220c:	20000e7f 	.word	0x20000e7f

00402210 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  402210:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402214:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402218:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40221a:	f003 0303 	and.w	r3, r3, #3
  40221e:	2b03      	cmp	r3, #3
  402220:	f200 80a9 	bhi.w	402376 <SystemCoreClockUpdate+0x166>
  402224:	e8df f003 	tbb	[pc, r3]
  402228:	4f4f1402 	.word	0x4f4f1402
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  40222c:	f241 4310 	movw	r3, #5136	; 0x1410
  402230:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402234:	695b      	ldr	r3, [r3, #20]
  402236:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40223a:	f240 0300 	movw	r3, #0
  40223e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402242:	bf14      	ite	ne
  402244:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  402248:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  40224c:	601a      	str	r2, [r3, #0]
  40224e:	e092      	b.n	402376 <SystemCoreClockUpdate+0x166>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  402250:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402254:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402258:	6a1b      	ldr	r3, [r3, #32]
  40225a:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40225e:	d009      	beq.n	402274 <SystemCoreClockUpdate+0x64>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  402260:	f240 0300 	movw	r3, #0
  402264:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402268:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  40226c:	f2c0 02b7 	movt	r2, #183	; 0xb7
  402270:	601a      	str	r2, [r3, #0]
  402272:	e080      	b.n	402376 <SystemCoreClockUpdate+0x166>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  402274:	f240 0300 	movw	r3, #0
  402278:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40227c:	f44f 6210 	mov.w	r2, #2304	; 0x900
  402280:	f2c0 023d 	movt	r2, #61	; 0x3d
  402284:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  402286:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40228a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40228e:	6a1b      	ldr	r3, [r3, #32]
  402290:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402294:	2b10      	cmp	r3, #16
  402296:	d002      	beq.n	40229e <SystemCoreClockUpdate+0x8e>
  402298:	2b20      	cmp	r3, #32
  40229a:	d16c      	bne.n	402376 <SystemCoreClockUpdate+0x166>
  40229c:	e009      	b.n	4022b2 <SystemCoreClockUpdate+0xa2>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  40229e:	f240 0300 	movw	r3, #0
  4022a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022a6:	f44f 5290 	mov.w	r2, #4608	; 0x1200
  4022aa:	f2c0 027a 	movt	r2, #122	; 0x7a
  4022ae:	601a      	str	r2, [r3, #0]
				break;
  4022b0:	e061      	b.n	402376 <SystemCoreClockUpdate+0x166>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  4022b2:	f240 0300 	movw	r3, #0
  4022b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022ba:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  4022be:	f2c0 02b7 	movt	r2, #183	; 0xb7
  4022c2:	601a      	str	r2, [r3, #0]
				break;
  4022c4:	e057      	b.n	402376 <SystemCoreClockUpdate+0x166>
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4022c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4022ca:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4022ce:	6a1b      	ldr	r3, [r3, #32]
  4022d0:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  4022d4:	d009      	beq.n	4022ea <SystemCoreClockUpdate+0xda>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  4022d6:	f240 0300 	movw	r3, #0
  4022da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022de:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  4022e2:	f2c0 02b7 	movt	r2, #183	; 0xb7
  4022e6:	601a      	str	r2, [r3, #0]
  4022e8:	e027      	b.n	40233a <SystemCoreClockUpdate+0x12a>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4022ea:	f240 0300 	movw	r3, #0
  4022ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4022f2:	f44f 6210 	mov.w	r2, #2304	; 0x900
  4022f6:	f2c0 023d 	movt	r2, #61	; 0x3d
  4022fa:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  4022fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  402300:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402304:	6a1b      	ldr	r3, [r3, #32]
  402306:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40230a:	2b10      	cmp	r3, #16
  40230c:	d002      	beq.n	402314 <SystemCoreClockUpdate+0x104>
  40230e:	2b20      	cmp	r3, #32
  402310:	d113      	bne.n	40233a <SystemCoreClockUpdate+0x12a>
  402312:	e009      	b.n	402328 <SystemCoreClockUpdate+0x118>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
  402314:	f240 0300 	movw	r3, #0
  402318:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40231c:	f44f 5290 	mov.w	r2, #4608	; 0x1200
  402320:	f2c0 027a 	movt	r2, #122	; 0x7a
  402324:	601a      	str	r2, [r3, #0]
				break;
  402326:	e008      	b.n	40233a <SystemCoreClockUpdate+0x12a>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
  402328:	f240 0300 	movw	r3, #0
  40232c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402330:	f44f 52d8 	mov.w	r2, #6912	; 0x1b00
  402334:	f2c0 02b7 	movt	r2, #183	; 0xb7
  402338:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40233a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40233e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402342:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402344:	f003 0303 	and.w	r3, r3, #3
  402348:	2b02      	cmp	r3, #2
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  40234a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40234e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402352:	bf07      	ittee	eq
  402354:	6a98      	ldreq	r0, [r3, #40]	; 0x28
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
  402356:	6a99      	ldreq	r1, [r3, #40]	; 0x28
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  402358:	6ad8      	ldrne	r0, [r3, #44]	; 0x2c
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  40235a:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
  40235c:	f240 0300 	movw	r3, #0
  402360:	f2c2 0300 	movt	r3, #8192	; 0x2000
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                          CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                          CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk) >> 
  402364:	f3c0 400a 	ubfx	r0, r0, #16, #11
  402368:	681a      	ldr	r2, [r3, #0]
  40236a:	fb00 2202 	mla	r2, r0, r2, r2
				                           CKGR_PLLBR_MULB_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk) >> 
  40236e:	b2c9      	uxtb	r1, r1
  402370:	fbb2 f2f1 	udiv	r2, r2, r1
  402374:	601a      	str	r2, [r3, #0]
		break;
	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  402376:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40237a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40237e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402380:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402384:	2b70      	cmp	r3, #112	; 0x70
  402386:	d10e      	bne.n	4023a6 <SystemCoreClockUpdate+0x196>
		SystemCoreClock /= 3U;
  402388:	f240 0300 	movw	r3, #0
  40238c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  402390:	6819      	ldr	r1, [r3, #0]
  402392:	f64a 22ab 	movw	r2, #43691	; 0xaaab
  402396:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
  40239a:	fba2 0201 	umull	r0, r2, r2, r1
  40239e:	ea4f 0252 	mov.w	r2, r2, lsr #1
  4023a2:	601a      	str	r2, [r3, #0]
  4023a4:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4023a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4023aa:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023ae:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4023b0:	f240 0300 	movw	r3, #0
  4023b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4023b8:	f3c1 1102 	ubfx	r1, r1, #4, #3
  4023bc:	681a      	ldr	r2, [r3, #0]
  4023be:	fa22 f201 	lsr.w	r2, r2, r1
  4023c2:	601a      	str	r2, [r3, #0]
  4023c4:	4770      	bx	lr
  4023c6:	bf00      	nop

004023c8 <system_init_flash>:
 */
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if (ul_clk < CHIP_FREQ_FWS_0) {
  4023c8:	f642 43ff 	movw	r3, #11519	; 0x2cff
  4023cc:	f2c0 1331 	movt	r3, #305	; 0x131
  4023d0:	4298      	cmp	r0, r3
  4023d2:	d807      	bhi.n	4023e4 <system_init_flash+0x1c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
  4023d4:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4023d8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023dc:	f04f 0200 	mov.w	r2, #0
  4023e0:	601a      	str	r2, [r3, #0]
  4023e2:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  4023e4:	f645 13ff 	movw	r3, #23039	; 0x59ff
  4023e8:	f2c0 2362 	movt	r3, #610	; 0x262
  4023ec:	4298      	cmp	r0, r3
  4023ee:	d807      	bhi.n	402400 <system_init_flash+0x38>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
  4023f0:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  4023f4:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4023f8:	f44f 7280 	mov.w	r2, #256	; 0x100
  4023fc:	601a      	str	r2, [r3, #0]
  4023fe:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  402400:	f248 63ff 	movw	r3, #34559	; 0x86ff
  402404:	f2c0 3393 	movt	r3, #915	; 0x393
  402408:	4298      	cmp	r0, r3
  40240a:	d807      	bhi.n	40241c <system_init_flash+0x54>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
  40240c:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402410:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402414:	f44f 7200 	mov.w	r2, #512	; 0x200
  402418:	601a      	str	r2, [r3, #0]
  40241a:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  40241c:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  402420:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  402424:	4298      	cmp	r0, r3
  402426:	d807      	bhi.n	402438 <system_init_flash+0x70>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
  402428:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  40242c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  402430:	f44f 7240 	mov.w	r2, #768	; 0x300
  402434:	601a      	str	r2, [r3, #0]
  402436:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  402438:	f24e 03ff 	movw	r3, #57599	; 0xe0ff
  40243c:	f2c0 53f5 	movt	r3, #1525	; 0x5f5
  402440:	4298      	cmp	r0, r3
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
  402442:	f44f 6320 	mov.w	r3, #2560	; 0xa00
  402446:	f2c4 030e 	movt	r3, #16398	; 0x400e
  40244a:	bf94      	ite	ls
  40244c:	f44f 6280 	movls.w	r2, #1024	; 0x400
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
  402450:	f44f 62a0 	movhi.w	r2, #1280	; 0x500
  402454:	601a      	str	r2, [r3, #0]
  402456:	4770      	bx	lr

00402458 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  402458:	b510      	push	{r4, lr}
  40245a:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3 || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  40245c:	f44f 50a3 	mov.w	r0, #5216	; 0x1460
  402460:	f2c4 000e 	movt	r0, #16398	; 0x400e
  402464:	f04f 0100 	mov.w	r1, #0
  402468:	f242 1315 	movw	r3, #8469	; 0x2115
  40246c:	f2c0 0340 	movt	r3, #64	; 0x40
  402470:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  402472:	2c02      	cmp	r4, #2
  402474:	d81b      	bhi.n	4024ae <disk_initialize+0x56>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  402476:	4620      	mov	r0, r4
  402478:	f241 5325 	movw	r3, #5413	; 0x1525
  40247c:	f2c0 0340 	movt	r3, #64	; 0x40
  402480:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  402482:	2803      	cmp	r0, #3
  402484:	d107      	bne.n	402496 <disk_initialize+0x3e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  402486:	4620      	mov	r0, r4
  402488:	f241 5325 	movw	r3, #5413	; 0x1525
  40248c:	f2c0 0340 	movt	r3, #64	; 0x40
  402490:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
  402492:	2803      	cmp	r0, #3
  402494:	d00e      	beq.n	4024b4 <disk_initialize+0x5c>
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  402496:	b980      	cbnz	r0, 4024ba <disk_initialize+0x62>
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  402498:	4620      	mov	r0, r4
  40249a:	f241 5375 	movw	r3, #5493	; 0x1575
  40249e:	f2c0 0340 	movt	r3, #64	; 0x40
  4024a2:	4798      	blx	r3
		return STA_PROTECT;
  4024a4:	2800      	cmp	r0, #0
  4024a6:	bf14      	ite	ne
  4024a8:	2004      	movne	r0, #4
  4024aa:	2000      	moveq	r0, #0
  4024ac:	bd10      	pop	{r4, pc}
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  4024ae:	f04f 0001 	mov.w	r0, #1
  4024b2:	bd10      	pop	{r4, pc}
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
  4024b4:	f04f 0001 	mov.w	r0, #1
  4024b8:	bd10      	pop	{r4, pc}
  4024ba:	f04f 0001 	mov.w	r0, #1
		return STA_PROTECT;
	}

	/* The memory should already be initialized */
	return 0;
}
  4024be:	bd10      	pop	{r4, pc}

004024c0 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  4024c0:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  4024c2:	f241 5325 	movw	r3, #5413	; 0x1525
  4024c6:	f2c0 0340 	movt	r3, #64	; 0x40
  4024ca:	4798      	blx	r3
  4024cc:	b120      	cbz	r0, 4024d8 <disk_status+0x18>
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  4024ce:	2802      	cmp	r0, #2
  4024d0:	bf0c      	ite	eq
  4024d2:	2003      	moveq	r0, #3
  4024d4:	2001      	movne	r0, #1
  4024d6:	bd08      	pop	{r3, pc}
 */
DSTATUS disk_status(BYTE drv)
{
	switch (mem_test_unit_ready(drv)) {
	case CTRL_GOOD:
		return 0;
  4024d8:	f04f 0000 	mov.w	r0, #0
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
	}
}
  4024dc:	bd08      	pop	{r3, pc}
  4024de:	bf00      	nop

004024e0 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  4024e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4024e4:	b082      	sub	sp, #8
  4024e6:	4606      	mov	r6, r0
  4024e8:	4688      	mov	r8, r1
  4024ea:	4617      	mov	r7, r2
  4024ec:	461d      	mov	r5, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  4024ee:	f241 5469 	movw	r4, #5481	; 0x1569
  4024f2:	f2c0 0440 	movt	r4, #64	; 0x40
  4024f6:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  4024f8:	4604      	mov	r4, r0
  4024fa:	b340      	cbz	r0, 40254e <disk_read+0x6e>
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  4024fc:	4630      	mov	r0, r6
  4024fe:	a901      	add	r1, sp, #4
  402500:	f241 5345 	movw	r3, #5445	; 0x1545
  402504:	f2c0 0340 	movt	r3, #64	; 0x40
  402508:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
  40250a:	fb04 7205 	mla	r2, r4, r5, r7
			(ul_last_sector_num + 1) * uc_sector_size) {
  40250e:	9b01      	ldr	r3, [sp, #4]
  402510:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402514:	429a      	cmp	r2, r3
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  402516:	bf88      	it	hi
  402518:	2004      	movhi	r0, #4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  40251a:	d820      	bhi.n	40255e <disk_read+0x7e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  40251c:	46a9      	mov	r9, r5
  40251e:	b1cd      	cbz	r5, 402554 <disk_read+0x74>
		if (memory_2_ram(drv, sector + uc_sector_size *
				SECTOR_SIZE_DEFAULT * i,
  402520:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  402524:	463c      	mov	r4, r7
  402526:	f04f 0500 	mov.w	r5, #0
 * \param sector Sector address (LBA).
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
  40252a:	ebc7 0808 	rsb	r8, r7, r8
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
		if (memory_2_ram(drv, sector + uc_sector_size *
  40252e:	f241 5799 	movw	r7, #5529	; 0x1599
  402532:	f2c0 0740 	movt	r7, #64	; 0x40
  402536:	4630      	mov	r0, r6
  402538:	4621      	mov	r1, r4
  40253a:	eb08 0204 	add.w	r2, r8, r4
  40253e:	47b8      	blx	r7
  402540:	b958      	cbnz	r0, 40255a <disk_read+0x7a>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402542:	f105 0501 	add.w	r5, r5, #1
  402546:	4454      	add	r4, sl
  402548:	454d      	cmp	r5, r9
  40254a:	d3f4      	bcc.n	402536 <disk_read+0x56>
  40254c:	e007      	b.n	40255e <disk_read+0x7e>
	uint8_t uc_sector_size = mem_sector_size(drv);
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
		return RES_ERROR;
  40254e:	f04f 0001 	mov.w	r0, #1
  402552:	e004      	b.n	40255e <disk_read+0x7e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  402554:	f04f 0000 	mov.w	r0, #0
  402558:	e001      	b.n	40255e <disk_read+0x7e>
				SECTOR_SIZE_DEFAULT * i,
				buff +
				uc_sector_size *
				SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
  40255a:	f04f 0001 	mov.w	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40255e:	b002      	add	sp, #8
  402560:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00402564 <chk_chr>:
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  402564:	7803      	ldrb	r3, [r0, #0]
  402566:	b133      	cbz	r3, 402576 <chk_chr+0x12>
  402568:	428b      	cmp	r3, r1
  40256a:	d004      	beq.n	402576 <chk_chr+0x12>
  40256c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  402570:	b10b      	cbz	r3, 402576 <chk_chr+0x12>
  402572:	428b      	cmp	r3, r1
  402574:	d1fa      	bne.n	40256c <chk_chr+0x8>
	return *str;
}
  402576:	4618      	mov	r0, r3
  402578:	4770      	bx	lr
  40257a:	bf00      	nop

0040257c <clust2sect>:
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  40257c:	f1a1 0102 	sub.w	r1, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402580:	68c3      	ldr	r3, [r0, #12]
  402582:	f1a3 0302 	sub.w	r3, r3, #2
  402586:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
  402588:	bf3d      	ittte	cc
  40258a:	7882      	ldrbcc	r2, [r0, #2]
  40258c:	69c3      	ldrcc	r3, [r0, #28]
  40258e:	fb02 3001 	mlacc	r0, r2, r1, r3
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402592:	2000      	movcs	r0, #0
	return clst * fs->csize + fs->database;
}
  402594:	4770      	bx	lr
  402596:	bf00      	nop

00402598 <sum_sfn>:
/*-----------------------------------------------------------------------*/
/* Calculate sum of an SFN                                               */
/*-----------------------------------------------------------------------*/
#if _USE_LFN
static
BYTE sum_sfn (
  402598:	f100 010b 	add.w	r1, r0, #11
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  40259c:	f04f 0300 	mov.w	r3, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  4025a0:	ea4f 0253 	mov.w	r2, r3, lsr #1
  4025a4:	ea42 13c3 	orr.w	r3, r2, r3, lsl #7
  4025a8:	f810 2b01 	ldrb.w	r2, [r0], #1
  4025ac:	fa52 f383 	uxtab	r3, r2, r3
  4025b0:	b2db      	uxtb	r3, r3
  4025b2:	4288      	cmp	r0, r1
  4025b4:	d1f4      	bne.n	4025a0 <sum_sfn+0x8>
	return sum;
}
  4025b6:	4618      	mov	r0, r3
  4025b8:	4770      	bx	lr
  4025ba:	bf00      	nop

004025bc <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  4025bc:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  4025be:	b188      	cbz	r0, 4025e4 <validate+0x28>
  4025c0:	7802      	ldrb	r2, [r0, #0]
  4025c2:	b192      	cbz	r2, 4025ea <validate+0x2e>
  4025c4:	88c2      	ldrh	r2, [r0, #6]
  4025c6:	428a      	cmp	r2, r1
  4025c8:	d112      	bne.n	4025f0 <validate+0x34>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  4025ca:	7840      	ldrb	r0, [r0, #1]
  4025cc:	f242 43c1 	movw	r3, #9409	; 0x24c1
  4025d0:	f2c0 0340 	movt	r3, #64	; 0x40
  4025d4:	4798      	blx	r3
  4025d6:	f000 0001 	and.w	r0, r0, #1
		return FR_NOT_READY;
  4025da:	2800      	cmp	r0, #0
  4025dc:	bf14      	ite	ne
  4025de:	2003      	movne	r0, #3
  4025e0:	2000      	moveq	r0, #0
  4025e2:	bd08      	pop	{r3, pc}
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
  4025e4:	f04f 0009 	mov.w	r0, #9
  4025e8:	bd08      	pop	{r3, pc}
  4025ea:	f04f 0009 	mov.w	r0, #9
  4025ee:	bd08      	pop	{r3, pc}
  4025f0:	f04f 0009 	mov.w	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  4025f4:	bd08      	pop	{r3, pc}
  4025f6:	bf00      	nop

004025f8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  4025f8:	b538      	push	{r3, r4, r5, lr}
  4025fa:	4604      	mov	r4, r0
  4025fc:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  4025fe:	7840      	ldrb	r0, [r0, #1]
  402600:	f104 0124 	add.w	r1, r4, #36	; 0x24
  402604:	f04f 0301 	mov.w	r3, #1
  402608:	f242 45e1 	movw	r5, #9441	; 0x24e1
  40260c:	f2c0 0540 	movt	r5, #64	; 0x40
  402610:	47a8      	blx	r5
  402612:	2800      	cmp	r0, #0
  402614:	d13c      	bne.n	402690 <check_fs+0x98>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  402616:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
  40261a:	f894 3222 	ldrb.w	r3, [r4, #546]	; 0x222
  40261e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  402622:	b212      	sxth	r2, r2
  402624:	f64a 2355 	movw	r3, #43605	; 0xaa55
  402628:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  40262c:	429a      	cmp	r2, r3
  40262e:	d132      	bne.n	402696 <check_fs+0x9e>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  402630:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  402634:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  402638:	ea4f 4303 	mov.w	r3, r3, lsl #16
  40263c:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  402640:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
  402644:	4313      	orrs	r3, r2
  402646:	f894 205b 	ldrb.w	r2, [r4, #91]	; 0x5b
  40264a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  40264e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  402652:	f244 1346 	movw	r3, #16710	; 0x4146
  402656:	f2c0 0354 	movt	r3, #84	; 0x54
  40265a:	429a      	cmp	r2, r3
  40265c:	d01e      	beq.n	40269c <check_fs+0xa4>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  40265e:	f894 0079 	ldrb.w	r0, [r4, #121]	; 0x79
  402662:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
  402666:	ea4f 4303 	mov.w	r3, r3, lsl #16
  40266a:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
  40266e:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  402672:	4303      	orrs	r3, r0
  402674:	f894 0077 	ldrb.w	r0, [r4, #119]	; 0x77
  402678:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  40267c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  402680:	f244 1346 	movw	r3, #16710	; 0x4146
  402684:	f2c0 0354 	movt	r3, #84	; 0x54
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
  402688:	1ac0      	subs	r0, r0, r3
  40268a:	bf18      	it	ne
  40268c:	2001      	movne	r0, #1
  40268e:	bd38      	pop	{r3, r4, r5, pc}
  402690:	f04f 0003 	mov.w	r0, #3
  402694:	bd38      	pop	{r3, r4, r5, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
  402696:	f04f 0002 	mov.w	r0, #2
  40269a:	bd38      	pop	{r3, r4, r5, pc}

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
  40269c:	f04f 0000 	mov.w	r0, #0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  4026a0:	bd38      	pop	{r3, r4, r5, pc}
  4026a2:	bf00      	nop

004026a4 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  4026a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  4026a8:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  4026aa:	781a      	ldrb	r2, [r3, #0]
  4026ac:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  4026b0:	2a09      	cmp	r2, #9
  4026b2:	d808      	bhi.n	4026c6 <chk_mounted+0x22>
  4026b4:	785c      	ldrb	r4, [r3, #1]
  4026b6:	2c3a      	cmp	r4, #58	; 0x3a
  4026b8:	d105      	bne.n	4026c6 <chk_mounted+0x22>
		p += 2; *path = p;				/* Return pointer to the path name */
  4026ba:	f103 0302 	add.w	r3, r3, #2
  4026be:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  4026c0:	2a00      	cmp	r2, #0
  4026c2:	f040 8108 	bne.w	4028d6 <chk_mounted+0x232>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  4026c6:	f240 5300 	movw	r3, #1280	; 0x500
  4026ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4026ce:	681c      	ldr	r4, [r3, #0]
  4026d0:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4026d2:	2c00      	cmp	r4, #0
  4026d4:	f000 8103 	beq.w	4028de <chk_mounted+0x23a>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  4026d8:	7823      	ldrb	r3, [r4, #0]
  4026da:	b14b      	cbz	r3, 4026f0 <chk_mounted+0x4c>
		stat = disk_status(fs->drv);
  4026dc:	7860      	ldrb	r0, [r4, #1]
  4026de:	f242 43c1 	movw	r3, #9409	; 0x24c1
  4026e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4026e6:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  4026e8:	f010 0f01 	tst.w	r0, #1
  4026ec:	f000 80fb 	beq.w	4028e6 <chk_mounted+0x242>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  4026f0:	f04f 0000 	mov.w	r0, #0
  4026f4:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  4026f6:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  4026f8:	f242 4359 	movw	r3, #9305	; 0x2459
  4026fc:	f2c0 0340 	movt	r3, #64	; 0x40
  402700:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  402702:	f010 0f01 	tst.w	r0, #1
  402706:	f040 80f2 	bne.w	4028ee <chk_mounted+0x24a>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40270a:	4620      	mov	r0, r4
  40270c:	f04f 0100 	mov.w	r1, #0
  402710:	f242 53f9 	movw	r3, #9721	; 0x25f9
  402714:	f2c0 0340 	movt	r3, #64	; 0x40
  402718:	4798      	blx	r3
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  40271a:	2801      	cmp	r0, #1
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40271c:	bf18      	it	ne
  40271e:	2500      	movne	r5, #0
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  402720:	d11b      	bne.n	40275a <chk_mounted+0xb6>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  402722:	f894 31e6 	ldrb.w	r3, [r4, #486]	; 0x1e6
  402726:	2b00      	cmp	r3, #0
  402728:	f000 80e5 	beq.w	4028f6 <chk_mounted+0x252>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  40272c:	f894 21ed 	ldrb.w	r2, [r4, #493]	; 0x1ed
  402730:	f894 31ec 	ldrb.w	r3, [r4, #492]	; 0x1ec
  402734:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402738:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  40273c:	f894 31ea 	ldrb.w	r3, [r4, #490]	; 0x1ea
  402740:	4313      	orrs	r3, r2
  402742:	f894 51eb 	ldrb.w	r5, [r4, #491]	; 0x1eb
  402746:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  40274a:	4620      	mov	r0, r4
  40274c:	4629      	mov	r1, r5
  40274e:	f242 53f9 	movw	r3, #9721	; 0x25f9
  402752:	f2c0 0340 	movt	r3, #64	; 0x40
  402756:	4798      	blx	r3
  402758:	e7ff      	b.n	40275a <chk_mounted+0xb6>
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  40275a:	2803      	cmp	r0, #3
  40275c:	f000 80cf 	beq.w	4028fe <chk_mounted+0x25a>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402760:	2800      	cmp	r0, #0
  402762:	f040 80d0 	bne.w	402906 <chk_mounted+0x262>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  402766:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  40276a:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
  40276e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402772:	b21b      	sxth	r3, r3
  402774:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402778:	f040 80c9 	bne.w	40290e <chk_mounted+0x26a>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  40277c:	f894 003b 	ldrb.w	r0, [r4, #59]	; 0x3b
  402780:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  402784:	ea53 2000 	orrs.w	r0, r3, r0, lsl #8
  402788:	d10e      	bne.n	4027a8 <chk_mounted+0x104>
  40278a:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
  40278e:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
  402792:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402796:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  40279a:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
  40279e:	4313      	orrs	r3, r2
  4027a0:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
  4027a4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
	fs->fsize = fasize;
  4027a8:	6120      	str	r0, [r4, #16]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  4027aa:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
  4027ae:	70e1      	strb	r1, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  4027b0:	f101 33ff 	add.w	r3, r1, #4294967295
  4027b4:	b2db      	uxtb	r3, r3
  4027b6:	2b01      	cmp	r3, #1
  4027b8:	f200 80ad 	bhi.w	402916 <chk_mounted+0x272>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  4027bc:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
  4027c0:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  4027c2:	2b00      	cmp	r3, #0
  4027c4:	f000 80ab 	beq.w	40291e <chk_mounted+0x27a>
  4027c8:	f103 32ff 	add.w	r2, r3, #4294967295
  4027cc:	421a      	tst	r2, r3
  4027ce:	f040 80aa 	bne.w	402926 <chk_mounted+0x282>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  4027d2:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
  4027d6:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
  4027da:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  4027de:	b296      	uxth	r6, r2
  4027e0:	8126      	strh	r6, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  4027e2:	f012 0f0f 	tst.w	r2, #15
  4027e6:	f040 80a2 	bne.w	40292e <chk_mounted+0x28a>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  4027ea:	f894 7038 	ldrb.w	r7, [r4, #56]	; 0x38
  4027ee:	f894 2037 	ldrb.w	r2, [r4, #55]	; 0x37
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  4027f2:	ea52 2207 	orrs.w	r2, r2, r7, lsl #8
  4027f6:	d10e      	bne.n	402816 <chk_mounted+0x172>
  4027f8:	f894 7047 	ldrb.w	r7, [r4, #71]	; 0x47
  4027fc:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
  402800:	ea4f 4202 	mov.w	r2, r2, lsl #16
  402804:	ea42 6707 	orr.w	r7, r2, r7, lsl #24
  402808:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
  40280c:	433a      	orrs	r2, r7
  40280e:	f894 7045 	ldrb.w	r7, [r4, #69]	; 0x45
  402812:	ea42 2207 	orr.w	r2, r2, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  402816:	f894 c033 	ldrb.w	ip, [r4, #51]	; 0x33
  40281a:	f894 7032 	ldrb.w	r7, [r4, #50]	; 0x32
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  40281e:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  402822:	f000 8088 	beq.w	402936 <chk_mounted+0x292>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  402826:	fb01 fc00 	mul.w	ip, r1, r0

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  40282a:	eb07 1116 	add.w	r1, r7, r6, lsr #4
  40282e:	4461      	add	r1, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  402830:	428a      	cmp	r2, r1
  402832:	f0c0 8084 	bcc.w	40293e <chk_mounted+0x29a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  402836:	1a52      	subs	r2, r2, r1
  402838:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  40283c:	2b00      	cmp	r3, #0
  40283e:	f000 8082 	beq.w	402946 <chk_mounted+0x2a2>
	fmt = FS_FAT12;
  402842:	f640 72f5 	movw	r2, #4085	; 0xff5
  402846:	4293      	cmp	r3, r2
  402848:	bf8c      	ite	hi
  40284a:	2202      	movhi	r2, #2
  40284c:	2201      	movls	r2, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  40284e:	f64f 78f5 	movw	r8, #65525	; 0xfff5
  402852:	4543      	cmp	r3, r8
  402854:	f200 8087 	bhi.w	402966 <chk_mounted+0x2c2>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402858:	f103 0302 	add.w	r3, r3, #2
  40285c:	60e3      	str	r3, [r4, #12]
	fs->database = bsect + sysect;						/* Data start sector */
  40285e:	1949      	adds	r1, r1, r5
  402860:	61e1      	str	r1, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402862:	19ed      	adds	r5, r5, r7
  402864:	6165      	str	r5, [r4, #20]
	if (fmt == FS_FAT32) {
  402866:	2a03      	cmp	r2, #3
  402868:	d114      	bne.n	402894 <chk_mounted+0x1f0>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40286a:	2e00      	cmp	r6, #0
  40286c:	d16f      	bne.n	40294e <chk_mounted+0x2aa>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  40286e:	f894 5053 	ldrb.w	r5, [r4, #83]	; 0x53
  402872:	f894 1052 	ldrb.w	r1, [r4, #82]	; 0x52
  402876:	ea4f 4101 	mov.w	r1, r1, lsl #16
  40287a:	ea41 6505 	orr.w	r5, r1, r5, lsl #24
  40287e:	f894 1050 	ldrb.w	r1, [r4, #80]	; 0x50
  402882:	4329      	orrs	r1, r5
  402884:	f894 5051 	ldrb.w	r5, [r4, #81]	; 0x51
  402888:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
  40288c:	61a1      	str	r1, [r4, #24]
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  40288e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  402892:	e00d      	b.n	4028b0 <chk_mounted+0x20c>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  402894:	2e00      	cmp	r6, #0
  402896:	d05e      	beq.n	402956 <chk_mounted+0x2b2>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  402898:	4465      	add	r5, ip
  40289a:	61a5      	str	r5, [r4, #24]
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  40289c:	2a02      	cmp	r2, #2
  40289e:	bf0f      	iteee	eq
  4028a0:	005b      	lsleq	r3, r3, #1
  4028a2:	2103      	movne	r1, #3
  4028a4:	4359      	mulne	r1, r3
  4028a6:	f003 0301 	andne.w	r3, r3, #1
  4028aa:	bf18      	it	ne
  4028ac:	eb03 0351 	addne.w	r3, r3, r1, lsr #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  4028b0:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  4028b4:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
  4028b8:	d351      	bcc.n	40295e <chk_mounted+0x2ba>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  4028ba:	7022      	strb	r2, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  4028bc:	4a2f      	ldr	r2, [pc, #188]	; (40297c <chk_mounted+0x2d8>)
  4028be:	8813      	ldrh	r3, [r2, #0]
  4028c0:	f103 0301 	add.w	r3, r3, #1
  4028c4:	b29b      	uxth	r3, r3
  4028c6:	8013      	strh	r3, [r2, #0]
  4028c8:	80e3      	strh	r3, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
  4028ca:	f04f 0000 	mov.w	r0, #0
  4028ce:	6220      	str	r0, [r4, #32]
	fs->wflag = 0;
  4028d0:	7120      	strb	r0, [r4, #4]
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  4028d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
  4028d6:	f04f 000b 	mov.w	r0, #11
  4028da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4028de:	f04f 000c 	mov.w	r0, #12
  4028e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  4028e6:	f04f 0000 	mov.w	r0, #0
  4028ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  4028ee:	f04f 0003 	mov.w	r0, #3
  4028f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  4028f6:	f04f 000d 	mov.w	r0, #13
  4028fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  4028fe:	f04f 0001 	mov.w	r0, #1
  402902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402906:	f04f 000d 	mov.w	r0, #13
  40290a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
  40290e:	f04f 000d 	mov.w	r0, #13
  402912:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402916:	f04f 000d 	mov.w	r0, #13
  40291a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  40291e:	f04f 000d 	mov.w	r0, #13
  402922:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402926:	f04f 000d 	mov.w	r0, #13
  40292a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  40292e:	f04f 000d 	mov.w	r0, #13
  402932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  402936:	f04f 000d 	mov.w	r0, #13
  40293a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  40293e:	f04f 000d 	mov.w	r0, #13
  402942:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  402946:	f04f 000d 	mov.w	r0, #13
  40294a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40294e:	f04f 000d 	mov.w	r0, #13
  402952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  402956:	f04f 000d 	mov.w	r0, #13
  40295a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
  40295e:	f04f 000d 	mov.w	r0, #13
  402962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402966:	f103 0302 	add.w	r3, r3, #2
  40296a:	60e3      	str	r3, [r4, #12]
	fs->database = bsect + sysect;						/* Data start sector */
  40296c:	1949      	adds	r1, r1, r5
  40296e:	61e1      	str	r1, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402970:	19ed      	adds	r5, r5, r7
  402972:	6165      	str	r5, [r4, #20]
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402974:	f04f 0203 	mov.w	r2, #3
  402978:	e777      	b.n	40286a <chk_mounted+0x1c6>
  40297a:	bf00      	nop
  40297c:	200004fc 	.word	0x200004fc

00402980 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  402980:	b570      	push	{r4, r5, r6, lr}
  402982:	4605      	mov	r5, r0
  402984:	460c      	mov	r4, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  402986:	6a03      	ldr	r3, [r0, #32]
  402988:	428b      	cmp	r3, r1
  40298a:	d00e      	beq.n	4029aa <move_window+0x2a>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  40298c:	b181      	cbz	r1, 4029b0 <move_window+0x30>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  40298e:	7840      	ldrb	r0, [r0, #1]
  402990:	f105 0124 	add.w	r1, r5, #36	; 0x24
  402994:	4622      	mov	r2, r4
  402996:	f04f 0301 	mov.w	r3, #1
  40299a:	f242 46e1 	movw	r6, #9441	; 0x24e1
  40299e:	f2c0 0640 	movt	r6, #64	; 0x40
  4029a2:	47b0      	blx	r6
  4029a4:	b938      	cbnz	r0, 4029b6 <move_window+0x36>
				return FR_DISK_ERR;
			fs->winsect = sector;
  4029a6:	622c      	str	r4, [r5, #32]
  4029a8:	bd70      	pop	{r4, r5, r6, pc}
		}
	}

	return FR_OK;
  4029aa:	f04f 0000 	mov.w	r0, #0
  4029ae:	bd70      	pop	{r4, r5, r6, pc}
  4029b0:	f04f 0000 	mov.w	r0, #0
  4029b4:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
  4029b6:	f04f 0001 	mov.w	r0, #1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
  4029ba:	bd70      	pop	{r4, r5, r6, pc}

004029bc <get_fat>:

static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
  4029bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4029be:	4605      	mov	r5, r0
  4029c0:	460c      	mov	r4, r1
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4029c2:	2901      	cmp	r1, #1
  4029c4:	d96e      	bls.n	402aa4 <get_fat+0xe8>
  4029c6:	68c3      	ldr	r3, [r0, #12]
  4029c8:	4299      	cmp	r1, r3
  4029ca:	d26e      	bcs.n	402aaa <get_fat+0xee>
		return 1;

	switch (fs->fs_type) {
  4029cc:	7803      	ldrb	r3, [r0, #0]
  4029ce:	2b02      	cmp	r3, #2
  4029d0:	d033      	beq.n	402a3a <get_fat+0x7e>
  4029d2:	2b03      	cmp	r3, #3
  4029d4:	d046      	beq.n	402a64 <get_fat+0xa8>
  4029d6:	2b01      	cmp	r3, #1
  4029d8:	d16a      	bne.n	402ab0 <get_fat+0xf4>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  4029da:	eb01 0651 	add.w	r6, r1, r1, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4029de:	6941      	ldr	r1, [r0, #20]
  4029e0:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4029e4:	f642 1381 	movw	r3, #10625	; 0x2981
  4029e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4029ec:	4798      	blx	r3
  4029ee:	2800      	cmp	r0, #0
  4029f0:	d161      	bne.n	402ab6 <get_fat+0xfa>
		wc = fs->win[bc % SS(fs)]; bc++;
  4029f2:	ea4f 53c6 	mov.w	r3, r6, lsl #23
  4029f6:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  4029fa:	18eb      	adds	r3, r5, r3
  4029fc:	f893 7024 	ldrb.w	r7, [r3, #36]	; 0x24
  402a00:	f106 0601 	add.w	r6, r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402a04:	6969      	ldr	r1, [r5, #20]
  402a06:	4628      	mov	r0, r5
  402a08:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402a0c:	f642 1381 	movw	r3, #10625	; 0x2981
  402a10:	f2c0 0340 	movt	r3, #64	; 0x40
  402a14:	4798      	blx	r3
  402a16:	2800      	cmp	r0, #0
  402a18:	d150      	bne.n	402abc <get_fat+0x100>
		wc |= fs->win[bc % SS(fs)] << 8;
  402a1a:	ea4f 56c6 	mov.w	r6, r6, lsl #23
  402a1e:	ea4f 56d6 	mov.w	r6, r6, lsr #23
  402a22:	19ad      	adds	r5, r5, r6
  402a24:	f895 0024 	ldrb.w	r0, [r5, #36]	; 0x24
  402a28:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402a2c:	f014 0f01 	tst.w	r4, #1
  402a30:	bf12      	itee	ne
  402a32:	0900      	lsrne	r0, r0, #4
  402a34:	0500      	lsleq	r0, r0, #20
  402a36:	0d00      	lsreq	r0, r0, #20
  402a38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402a3a:	6941      	ldr	r1, [r0, #20]
  402a3c:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  402a40:	f642 1381 	movw	r3, #10625	; 0x2981
  402a44:	f2c0 0340 	movt	r3, #64	; 0x40
  402a48:	4798      	blx	r3
  402a4a:	2800      	cmp	r0, #0
  402a4c:	d139      	bne.n	402ac2 <get_fat+0x106>
		p = &fs->win[clst * 2 % SS(fs)];
  402a4e:	ea4f 6404 	mov.w	r4, r4, lsl #24
		return LD_WORD(p);
  402a52:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
  402a56:	f895 0025 	ldrb.w	r0, [r5, #37]	; 0x25
  402a5a:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
  402a5e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402a62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  402a64:	6941      	ldr	r1, [r0, #20]
  402a66:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  402a6a:	f642 1381 	movw	r3, #10625	; 0x2981
  402a6e:	f2c0 0340 	movt	r3, #64	; 0x40
  402a72:	4798      	blx	r3
  402a74:	2800      	cmp	r0, #0
  402a76:	d127      	bne.n	402ac8 <get_fat+0x10c>
		p = &fs->win[clst * 4 % SS(fs)];
  402a78:	ea4f 6444 	mov.w	r4, r4, lsl #25
		return LD_DWORD(p) & 0x0FFFFFFF;
  402a7c:	eb05 55d4 	add.w	r5, r5, r4, lsr #23
  402a80:	f895 0027 	ldrb.w	r0, [r5, #39]	; 0x27
  402a84:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
  402a88:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402a8c:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
  402a90:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
  402a94:	4303      	orrs	r3, r0
  402a96:	f895 0025 	ldrb.w	r0, [r5, #37]	; 0x25
  402a9a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402a9e:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402aa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;
  402aa4:	f04f 0001 	mov.w	r0, #1
  402aa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402aaa:	f04f 0001 	mov.w	r0, #1
  402aae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402ab0:	f04f 30ff 	mov.w	r0, #4294967295
  402ab4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ab6:	f04f 30ff 	mov.w	r0, #4294967295
  402aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402abc:	f04f 30ff 	mov.w	r0, #4294967295
  402ac0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ac2:	f04f 30ff 	mov.w	r0, #4294967295
  402ac6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ac8:	f04f 30ff 	mov.w	r0, #4294967295
}
  402acc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402ace:	bf00      	nop

00402ad0 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402ad2:	4604      	mov	r4, r0
  402ad4:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  402ad6:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
  402ad8:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402ada:	2901      	cmp	r1, #1
  402adc:	d042      	beq.n	402b64 <dir_sdi+0x94>
  402ade:	6803      	ldr	r3, [r0, #0]
  402ae0:	68da      	ldr	r2, [r3, #12]
  402ae2:	4291      	cmp	r1, r2
  402ae4:	d241      	bcs.n	402b6a <dir_sdi+0x9a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  402ae6:	b979      	cbnz	r1, 402b08 <dir_sdi+0x38>
  402ae8:	781a      	ldrb	r2, [r3, #0]
  402aea:	2a03      	cmp	r2, #3
  402aec:	d101      	bne.n	402af2 <dir_sdi+0x22>
		clst = dj->fs->dirbase;
  402aee:	6999      	ldr	r1, [r3, #24]

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  402af0:	b951      	cbnz	r1, 402b08 <dir_sdi+0x38>
		dj->clust = clst;
  402af2:	f04f 0200 	mov.w	r2, #0
  402af6:	60e2      	str	r2, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  402af8:	891a      	ldrh	r2, [r3, #8]
  402afa:	42aa      	cmp	r2, r5
  402afc:	d938      	bls.n	402b70 <dir_sdi+0xa0>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402afe:	699b      	ldr	r3, [r3, #24]
  402b00:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402b04:	6123      	str	r3, [r4, #16]
  402b06:	e022      	b.n	402b4e <dir_sdi+0x7e>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  402b08:	789e      	ldrb	r6, [r3, #2]
  402b0a:	ea4f 1606 	mov.w	r6, r6, lsl #4
		while (idx >= ic) {	/* Follow cluster chain */
  402b0e:	42b5      	cmp	r5, r6
  402b10:	d313      	bcc.n	402b3a <dir_sdi+0x6a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  402b12:	f642 17bd 	movw	r7, #10685	; 0x29bd
  402b16:	f2c0 0740 	movt	r7, #64	; 0x40
  402b1a:	6820      	ldr	r0, [r4, #0]
  402b1c:	47b8      	blx	r7
  402b1e:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402b20:	f1b0 3fff 	cmp.w	r0, #4294967295
  402b24:	d027      	beq.n	402b76 <dir_sdi+0xa6>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  402b26:	2801      	cmp	r0, #1
  402b28:	d928      	bls.n	402b7c <dir_sdi+0xac>
  402b2a:	6823      	ldr	r3, [r4, #0]
  402b2c:	68db      	ldr	r3, [r3, #12]
  402b2e:	4298      	cmp	r0, r3
  402b30:	d227      	bcs.n	402b82 <dir_sdi+0xb2>
				return FR_INT_ERR;
			idx -= ic;
  402b32:	1bad      	subs	r5, r5, r6
  402b34:	b2ad      	uxth	r5, r5
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  402b36:	42ae      	cmp	r6, r5
  402b38:	d9ef      	bls.n	402b1a <dir_sdi+0x4a>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  402b3a:	60e1      	str	r1, [r4, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402b3c:	6820      	ldr	r0, [r4, #0]
  402b3e:	f242 537d 	movw	r3, #9597	; 0x257d
  402b42:	f2c0 0340 	movt	r3, #64	; 0x40
  402b46:	4798      	blx	r3
  402b48:	eb00 1015 	add.w	r0, r0, r5, lsr #4
  402b4c:	6120      	str	r0, [r4, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  402b4e:	f005 050f 	and.w	r5, r5, #15
  402b52:	6823      	ldr	r3, [r4, #0]
  402b54:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  402b58:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402b5c:	6163      	str	r3, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  402b5e:	f04f 0000 	mov.w	r0, #0
  402b62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
  402b64:	f04f 0002 	mov.w	r0, #2
  402b68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402b6a:	f04f 0002 	mov.w	r0, #2
  402b6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
  402b70:	f04f 0002 	mov.w	r0, #2
  402b74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402b76:	f04f 0001 	mov.w	r0, #1
  402b7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  402b7c:	f04f 0002 	mov.w	r0, #2
  402b80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402b82:	f04f 0002 	mov.w	r0, #2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
  402b86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00402b88 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402b88:	b570      	push	{r4, r5, r6, lr}
  402b8a:	4604      	mov	r4, r0
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  402b8c:	88c5      	ldrh	r5, [r0, #6]
  402b8e:	f105 0501 	add.w	r5, r5, #1
  402b92:	b2ad      	uxth	r5, r5
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402b94:	2d00      	cmp	r5, #0
  402b96:	d036      	beq.n	402c06 <dir_next+0x7e>
  402b98:	6903      	ldr	r3, [r0, #16]
  402b9a:	2b00      	cmp	r3, #0
  402b9c:	d036      	beq.n	402c0c <dir_next+0x84>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402b9e:	f015 060f 	ands.w	r6, r5, #15
  402ba2:	d126      	bne.n	402bf2 <dir_next+0x6a>
		dj->sect++;					/* Next sector */
  402ba4:	f103 0301 	add.w	r3, r3, #1
  402ba8:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
  402baa:	68c1      	ldr	r1, [r0, #12]
  402bac:	b921      	cbnz	r1, 402bb8 <dir_next+0x30>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402bae:	6803      	ldr	r3, [r0, #0]
  402bb0:	891b      	ldrh	r3, [r3, #8]
  402bb2:	42ab      	cmp	r3, r5
  402bb4:	d92d      	bls.n	402c12 <dir_next+0x8a>
  402bb6:	e01c      	b.n	402bf2 <dir_next+0x6a>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402bb8:	6800      	ldr	r0, [r0, #0]
  402bba:	7883      	ldrb	r3, [r0, #2]
  402bbc:	f103 33ff 	add.w	r3, r3, #4294967295
  402bc0:	ea13 1315 	ands.w	r3, r3, r5, lsr #4
  402bc4:	d115      	bne.n	402bf2 <dir_next+0x6a>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
  402bc6:	f642 13bd 	movw	r3, #10685	; 0x29bd
  402bca:	f2c0 0340 	movt	r3, #64	; 0x40
  402bce:	4798      	blx	r3
  402bd0:	4601      	mov	r1, r0
				if (clst <= 1) return FR_INT_ERR;
  402bd2:	2801      	cmp	r0, #1
  402bd4:	d920      	bls.n	402c18 <dir_next+0x90>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402bd6:	f1b0 3fff 	cmp.w	r0, #4294967295
  402bda:	d020      	beq.n	402c1e <dir_next+0x96>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402bdc:	6820      	ldr	r0, [r4, #0]
  402bde:	68c3      	ldr	r3, [r0, #12]
  402be0:	4299      	cmp	r1, r3
  402be2:	d21f      	bcs.n	402c24 <dir_next+0x9c>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402be4:	60e1      	str	r1, [r4, #12]
				dj->sect = clust2sect(dj->fs, clst);
  402be6:	f242 537d 	movw	r3, #9597	; 0x257d
  402bea:	f2c0 0340 	movt	r3, #64	; 0x40
  402bee:	4798      	blx	r3
  402bf0:	6120      	str	r0, [r4, #16]
			}
		}
	}

	dj->index = i;
  402bf2:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402bf4:	6823      	ldr	r3, [r4, #0]
  402bf6:	eb03 1346 	add.w	r3, r3, r6, lsl #5
  402bfa:	f103 0324 	add.w	r3, r3, #36	; 0x24
  402bfe:	6163      	str	r3, [r4, #20]

	return FR_OK;
  402c00:	f04f 0000 	mov.w	r0, #0
  402c04:	bd70      	pop	{r4, r5, r6, pc}


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
  402c06:	f04f 0004 	mov.w	r0, #4
  402c0a:	bd70      	pop	{r4, r5, r6, pc}
  402c0c:	f04f 0004 	mov.w	r0, #4
  402c10:	bd70      	pop	{r4, r5, r6, pc}
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
  402c12:	f04f 0004 	mov.w	r0, #4
  402c16:	bd70      	pop	{r4, r5, r6, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402c18:	f04f 0002 	mov.w	r0, #2
  402c1c:	bd70      	pop	{r4, r5, r6, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402c1e:	f04f 0001 	mov.w	r0, #1
  402c22:	bd70      	pop	{r4, r5, r6, pc}
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
  402c24:	f04f 0004 	mov.w	r0, #4

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  402c28:	bd70      	pop	{r4, r5, r6, pc}
  402c2a:	bf00      	nop

00402c2c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
  402c2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  402c30:	460d      	mov	r5, r1
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
  402c32:	f101 0409 	add.w	r4, r1, #9
	if (dj->sect) {
  402c36:	6903      	ldr	r3, [r0, #16]
  402c38:	2b00      	cmp	r3, #0
  402c3a:	d060      	beq.n	402cfe <get_fileinfo+0xd2>
		dir = dj->dir;
  402c3c:	6941      	ldr	r1, [r0, #20]
		nt = dir[DIR_NTres];		/* NT flag */
  402c3e:	f891 800c 	ldrb.w	r8, [r1, #12]
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  402c42:	780b      	ldrb	r3, [r1, #0]
			if (c == ' ') break;
  402c44:	2b20      	cmp	r3, #32
  402c46:	d01b      	beq.n	402c80 <get_fileinfo+0x54>
  402c48:	460e      	mov	r6, r1
  402c4a:	4622      	mov	r2, r4
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
  402c4c:	f104 0c08 	add.w	ip, r4, #8
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  402c50:	f008 0708 	and.w	r7, r8, #8
  402c54:	b2ff      	uxtb	r7, r7
  402c56:	e003      	b.n	402c60 <get_fileinfo+0x34>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  402c58:	f816 3f01 	ldrb.w	r3, [r6, #1]!
			if (c == ' ') break;
  402c5c:	2b20      	cmp	r3, #32
  402c5e:	d00f      	beq.n	402c80 <get_fileinfo+0x54>
			if (c == NDDE) c = (TCHAR)DDE;
  402c60:	2b05      	cmp	r3, #5
  402c62:	bf08      	it	eq
  402c64:	23e5      	moveq	r3, #229	; 0xe5
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  402c66:	b137      	cbz	r7, 402c76 <get_fileinfo+0x4a>
  402c68:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
  402c6c:	b2e4      	uxtb	r4, r4
  402c6e:	2c19      	cmp	r4, #25
  402c70:	bf9c      	itt	ls
  402c72:	3320      	addls	r3, #32
  402c74:	b2db      	uxtbls	r3, r3
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
  402c76:	f802 3b01 	strb.w	r3, [r2], #1
  402c7a:	4614      	mov	r4, r2

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  402c7c:	4562      	cmp	r2, ip
  402c7e:	d1eb      	bne.n	402c58 <get_fileinfo+0x2c>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
  402c80:	7a0b      	ldrb	r3, [r1, #8]
  402c82:	2b20      	cmp	r3, #32
  402c84:	d023      	beq.n	402cce <get_fileinfo+0xa2>
			*p++ = '.';
  402c86:	4623      	mov	r3, r4
  402c88:	f04f 022e 	mov.w	r2, #46	; 0x2e
  402c8c:	f803 2b01 	strb.w	r2, [r3], #1
			for (i = 8; i < 11; i++) {
				c = dir[i];
  402c90:	7a0a      	ldrb	r2, [r1, #8]
				if (c == ' ') break;
  402c92:	2a20      	cmp	r2, #32
  402c94:	d01a      	beq.n	402ccc <get_fileinfo+0xa0>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
  402c96:	f101 0608 	add.w	r6, r1, #8
  402c9a:	f104 0c04 	add.w	ip, r4, #4
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  402c9e:	f008 0810 	and.w	r8, r8, #16
  402ca2:	fa5f f788 	uxtb.w	r7, r8
  402ca6:	e003      	b.n	402cb0 <get_fileinfo+0x84>
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
  402ca8:	f816 2f01 	ldrb.w	r2, [r6, #1]!
				if (c == ' ') break;
  402cac:	2a20      	cmp	r2, #32
  402cae:	d00e      	beq.n	402cce <get_fileinfo+0xa2>
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  402cb0:	b137      	cbz	r7, 402cc0 <get_fileinfo+0x94>
  402cb2:	f1a2 0441 	sub.w	r4, r2, #65	; 0x41
  402cb6:	b2e4      	uxtb	r4, r4
  402cb8:	2c19      	cmp	r4, #25
  402cba:	bf9c      	itt	ls
  402cbc:	3220      	addls	r2, #32
  402cbe:	b2d2      	uxtbls	r2, r2
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
  402cc0:	f803 2b01 	strb.w	r2, [r3], #1
  402cc4:	461c      	mov	r4, r3
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
  402cc6:	4563      	cmp	r3, ip
  402cc8:	d1ee      	bne.n	402ca8 <get_fileinfo+0x7c>
  402cca:	e000      	b.n	402cce <get_fileinfo+0xa2>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
  402ccc:	461c      	mov	r4, r3
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  402cce:	7acb      	ldrb	r3, [r1, #11]
  402cd0:	722b      	strb	r3, [r5, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  402cd2:	7fca      	ldrb	r2, [r1, #31]
  402cd4:	7f8b      	ldrb	r3, [r1, #30]
  402cd6:	ea4f 4303 	mov.w	r3, r3, lsl #16
  402cda:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  402cde:	7f0a      	ldrb	r2, [r1, #28]
  402ce0:	4313      	orrs	r3, r2
  402ce2:	7f4a      	ldrb	r2, [r1, #29]
  402ce4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402ce8:	602b      	str	r3, [r5, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  402cea:	7e4a      	ldrb	r2, [r1, #25]
  402cec:	7e0b      	ldrb	r3, [r1, #24]
  402cee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402cf2:	80ab      	strh	r3, [r5, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  402cf4:	7dca      	ldrb	r2, [r1, #23]
  402cf6:	7d8b      	ldrb	r3, [r1, #22]
  402cf8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402cfc:	80eb      	strh	r3, [r5, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
  402cfe:	f04f 0300 	mov.w	r3, #0
  402d02:	7023      	strb	r3, [r4, #0]

#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
  402d04:	69ae      	ldr	r6, [r5, #24]
  402d06:	b38e      	cbz	r6, 402d6c <get_fileinfo+0x140>
  402d08:	69eb      	ldr	r3, [r5, #28]
  402d0a:	b37b      	cbz	r3, 402d6c <get_fileinfo+0x140>
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d0c:	6903      	ldr	r3, [r0, #16]
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d0e:	f04f 0400 	mov.w	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d12:	b343      	cbz	r3, 402d66 <get_fileinfo+0x13a>
  402d14:	8c02      	ldrh	r2, [r0, #32]
  402d16:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402d1a:	429a      	cmp	r2, r3
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d1c:	bf08      	it	eq
  402d1e:	2400      	moveq	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  402d20:	d021      	beq.n	402d66 <get_fileinfo+0x13a>
			lfn = dj->lfn;
  402d22:	69c7      	ldr	r7, [r0, #28]
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  402d24:	8838      	ldrh	r0, [r7, #0]
  402d26:	b1b0      	cbz	r0, 402d56 <get_fileinfo+0x12a>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d28:	f04f 0400 	mov.w	r4, #0
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
  402d2c:	46a1      	mov	r9, r4
  402d2e:	f643 08a5 	movw	r8, #14501	; 0x38a5
  402d32:	f2c0 0840 	movt	r8, #64	; 0x40
  402d36:	4649      	mov	r1, r9
  402d38:	47c0      	blx	r8
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
  402d3a:	b178      	cbz	r0, 402d5c <get_fileinfo+0x130>
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  402d3c:	69ea      	ldr	r2, [r5, #28]
  402d3e:	f102 32ff 	add.w	r2, r2, #4294967295
  402d42:	42a2      	cmp	r2, r4
  402d44:	d90d      	bls.n	402d62 <get_fileinfo+0x136>
				tp[i++] = (TCHAR)w;
  402d46:	5530      	strb	r0, [r6, r4]
  402d48:	f104 0401 	add.w	r4, r4, #1
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  402d4c:	f837 0f02 	ldrh.w	r0, [r7, #2]!
  402d50:	2800      	cmp	r0, #0
  402d52:	d1f0      	bne.n	402d36 <get_fileinfo+0x10a>
  402d54:	e007      	b.n	402d66 <get_fileinfo+0x13a>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  402d56:	f04f 0400 	mov.w	r4, #0
  402d5a:	e004      	b.n	402d66 <get_fileinfo+0x13a>
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
  402d5c:	f04f 0400 	mov.w	r4, #0
  402d60:	e001      	b.n	402d66 <get_fileinfo+0x13a>
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  402d62:	f04f 0400 	mov.w	r4, #0
				tp[i++] = (TCHAR)w;
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
  402d66:	f04f 0300 	mov.w	r3, #0
  402d6a:	5533      	strb	r3, [r6, r4]
  402d6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00402d70 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  402d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d74:	b08b      	sub	sp, #44	; 0x2c
  402d76:	4682      	mov	sl, r0
  402d78:	468b      	mov	fp, r1
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  402d7a:	780b      	ldrb	r3, [r1, #0]
  402d7c:	2b2f      	cmp	r3, #47	; 0x2f
  402d7e:	bf18      	it	ne
  402d80:	2b5c      	cmpne	r3, #92	; 0x5c
		path++;
  402d82:	bf08      	it	eq
  402d84:	f101 0b01 	addeq.w	fp, r1, #1
	dj->sclust = 0;						/* Start from the root dir */
  402d88:	f04f 0300 	mov.w	r3, #0
  402d8c:	6083      	str	r3, [r0, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  402d8e:	f89b 3000 	ldrb.w	r3, [fp]
  402d92:	2b1f      	cmp	r3, #31
  402d94:	d80c      	bhi.n	402db0 <follow_path+0x40>
		res = dir_sdi(dj, 0);
  402d96:	f04f 0100 	mov.w	r1, #0
  402d9a:	f642 23d1 	movw	r3, #10961	; 0x2ad1
  402d9e:	f2c0 0340 	movt	r3, #64	; 0x40
  402da2:	4798      	blx	r3
  402da4:	4607      	mov	r7, r0
		dj->dir = 0;
  402da6:	f04f 0300 	mov.w	r3, #0
  402daa:	f8ca 3014 	str.w	r3, [sl, #20]
  402dae:	e2cb      	b.n	403348 <follow_path+0x5d8>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402db0:	f643 03a5 	movw	r3, #14501	; 0x38a5
  402db4:	461e      	mov	r6, r3
  402db6:	f2c0 0640 	movt	r6, #64	; 0x40
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402dba:	f244 53cc 	movw	r3, #17868	; 0x45cc
  402dbe:	f2c0 0340 	movt	r3, #64	; 0x40
  402dc2:	9305      	str	r3, [sp, #20]
  402dc4:	f103 010c 	add.w	r1, r3, #12
  402dc8:	9107      	str	r1, [sp, #28]
  402dca:	46d9      	mov	r9, fp
  402dcc:	4683      	mov	fp, r0
  402dce:	46b2      	mov	sl, r6
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402dd0:	f899 3000 	ldrb.w	r3, [r9]
  402dd4:	2b2f      	cmp	r3, #47	; 0x2f
  402dd6:	bf18      	it	ne
  402dd8:	2b5c      	cmpne	r3, #92	; 0x5c
  402dda:	d108      	bne.n	402dee <follow_path+0x7e>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402ddc:	f109 0301 	add.w	r3, r9, #1
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402de0:	4699      	mov	r9, r3
  402de2:	f813 2b01 	ldrb.w	r2, [r3], #1
  402de6:	2a2f      	cmp	r2, #47	; 0x2f
  402de8:	bf18      	it	ne
  402dea:	2a5c      	cmpne	r2, #92	; 0x5c
  402dec:	d0f8      	beq.n	402de0 <follow_path+0x70>
	lfn = dj->lfn;
  402dee:	f8db 201c 	ldr.w	r2, [fp, #28]
  402df2:	9201      	str	r2, [sp, #4]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402df4:	f899 0000 	ldrb.w	r0, [r9]
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402df8:	282f      	cmp	r0, #47	; 0x2f
  402dfa:	bf18      	it	ne
  402dfc:	281f      	cmpne	r0, #31
  402dfe:	d940      	bls.n	402e82 <follow_path+0x112>
  402e00:	285c      	cmp	r0, #92	; 0x5c
  402e02:	f000 8241 	beq.w	403288 <follow_path+0x518>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402e06:	f1a2 0702 	sub.w	r7, r2, #2
  402e0a:	464e      	mov	r6, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e0c:	f04f 0401 	mov.w	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402e10:	46a0      	mov	r8, r4
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402e12:	f244 53b8 	movw	r3, #17848	; 0x45b8
  402e16:	f2c0 0340 	movt	r3, #64	; 0x40
  402e1a:	9302      	str	r3, [sp, #8]
  402e1c:	f242 5365 	movw	r3, #9573	; 0x2565
  402e20:	461d      	mov	r5, r3
  402e22:	f2c0 0540 	movt	r5, #64	; 0x40
  402e26:	f8cd b00c 	str.w	fp, [sp, #12]
  402e2a:	f8cd 9010 	str.w	r9, [sp, #16]
  402e2e:	f8dd 9008 	ldr.w	r9, [sp, #8]
  402e32:	46ab      	mov	fp, r5
  402e34:	e007      	b.n	402e46 <follow_path+0xd6>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402e36:	2b5c      	cmp	r3, #92	; 0x5c
  402e38:	f000 822b 	beq.w	403292 <follow_path+0x522>
		if (di >= _MAX_LFN)				/* Reject too long name */
  402e3c:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  402e40:	f000 8247 	beq.w	4032d2 <follow_path+0x562>
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e44:	4614      	mov	r4, r2
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402e46:	4641      	mov	r1, r8
  402e48:	47d0      	blx	sl
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  402e4a:	4605      	mov	r5, r0
  402e4c:	2800      	cmp	r0, #0
  402e4e:	f000 8240 	beq.w	4032d2 <follow_path+0x562>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402e52:	287f      	cmp	r0, #127	; 0x7f
  402e54:	d805      	bhi.n	402e62 <follow_path+0xf2>
  402e56:	4648      	mov	r0, r9
  402e58:	4629      	mov	r1, r5
  402e5a:	47d8      	blx	fp
  402e5c:	2800      	cmp	r0, #0
  402e5e:	f040 8238 	bne.w	4032d2 <follow_path+0x562>
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  402e62:	f827 5f02 	strh.w	r5, [r7, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402e66:	f816 3f01 	ldrb.w	r3, [r6, #1]!
  402e6a:	4618      	mov	r0, r3
  402e6c:	f104 0201 	add.w	r2, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402e70:	2b2f      	cmp	r3, #47	; 0x2f
  402e72:	bf18      	it	ne
  402e74:	2b1f      	cmpne	r3, #31
  402e76:	d8de      	bhi.n	402e36 <follow_path+0xc6>
  402e78:	f8dd b00c 	ldr.w	fp, [sp, #12]
  402e7c:	f8dd 9010 	ldr.w	r9, [sp, #16]
  402e80:	e003      	b.n	402e8a <follow_path+0x11a>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  402e82:	f04f 0400 	mov.w	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  402e86:	f04f 0201 	mov.w	r2, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  402e8a:	4491      	add	r9, r2
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402e8c:	281f      	cmp	r0, #31
  402e8e:	bf98      	it	ls
  402e90:	2704      	movls	r7, #4
  402e92:	d902      	bls.n	402e9a <follow_path+0x12a>
  402e94:	f04f 0700 	mov.w	r7, #0
  402e98:	e7ff      	b.n	402e9a <follow_path+0x12a>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402e9a:	2c00      	cmp	r4, #0
  402e9c:	f000 8219 	beq.w	4032d2 <follow_path+0x562>
		w = lfn[di-1];
  402ea0:	f104 33ff 	add.w	r3, r4, #4294967295
  402ea4:	9901      	ldr	r1, [sp, #4]
  402ea6:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
		if (w != ' ' && w != '.') break;
  402eaa:	2b2e      	cmp	r3, #46	; 0x2e
  402eac:	bf18      	it	ne
  402eae:	2b20      	cmpne	r3, #32
  402eb0:	f040 81f5 	bne.w	40329e <follow_path+0x52e>
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  402eb4:	eb01 0344 	add.w	r3, r1, r4, lsl #1
  402eb8:	e008      	b.n	402ecc <follow_path+0x15c>
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
		w = lfn[di-1];
  402eba:	f833 2c04 	ldrh.w	r2, [r3, #-4]
  402ebe:	f1a3 0302 	sub.w	r3, r3, #2
		if (w != ' ' && w != '.') break;
  402ec2:	2a2e      	cmp	r2, #46	; 0x2e
  402ec4:	bf18      	it	ne
  402ec6:	2a20      	cmpne	r2, #32
  402ec8:	f040 81e9 	bne.w	40329e <follow_path+0x52e>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402ecc:	3c01      	subs	r4, #1
  402ece:	d1f4      	bne.n	402eba <follow_path+0x14a>
  402ed0:	e1ff      	b.n	4032d2 <follow_path+0x562>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402ed2:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402ed6:	428b      	cmp	r3, r1
  402ed8:	d1fb      	bne.n	402ed2 <follow_path+0x162>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  402eda:	9a01      	ldr	r2, [sp, #4]
  402edc:	8813      	ldrh	r3, [r2, #0]
  402ede:	2b20      	cmp	r3, #32
  402ee0:	bf18      	it	ne
  402ee2:	2b2e      	cmpne	r3, #46	; 0x2e
  402ee4:	f040 81e9 	bne.w	4032ba <follow_path+0x54a>
  402ee8:	4611      	mov	r1, r2
  402eea:	f04f 0500 	mov.w	r5, #0
  402eee:	f105 0501 	add.w	r5, r5, #1
  402ef2:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  402ef6:	2b20      	cmp	r3, #32
  402ef8:	bf18      	it	ne
  402efa:	2b2e      	cmpne	r3, #46	; 0x2e
  402efc:	d0f7      	beq.n	402eee <follow_path+0x17e>
	if (si) cf |= NS_LOSS | NS_LFN;
  402efe:	2d00      	cmp	r5, #0
  402f00:	f000 81dd 	beq.w	4032be <follow_path+0x54e>
  402f04:	f047 0703 	orr.w	r7, r7, #3
  402f08:	e1d9      	b.n	4032be <follow_path+0x54e>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402f0a:	3c01      	subs	r4, #1
  402f0c:	d111      	bne.n	402f32 <follow_path+0x1c2>
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402f0e:	f04f 0308 	mov.w	r3, #8
  402f12:	9302      	str	r3, [sp, #8]
  402f14:	f04f 0800 	mov.w	r8, #0
  402f18:	f8cd 800c 	str.w	r8, [sp, #12]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402f1c:	f244 53c4 	movw	r3, #17860	; 0x45c4
  402f20:	f2c0 0340 	movt	r3, #64	; 0x40
  402f24:	9304      	str	r3, [sp, #16]
  402f26:	f242 5365 	movw	r3, #9573	; 0x2565
  402f2a:	f2c0 0340 	movt	r3, #64	; 0x40
  402f2e:	9306      	str	r3, [sp, #24]
  402f30:	e006      	b.n	402f40 <follow_path+0x1d0>
  402f32:	f1a3 0302 	sub.w	r3, r3, #2

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402f36:	f833 2c02 	ldrh.w	r2, [r3, #-2]
  402f3a:	2a2e      	cmp	r2, #46	; 0x2e
  402f3c:	d1e5      	bne.n	402f0a <follow_path+0x19a>
  402f3e:	e7e6      	b.n	402f0e <follow_path+0x19e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  402f40:	9a01      	ldr	r2, [sp, #4]
  402f42:	f832 6015 	ldrh.w	r6, [r2, r5, lsl #1]
  402f46:	f105 0501 	add.w	r5, r5, #1
		if (!w) break;					/* Break on end of the LFN */
  402f4a:	2e00      	cmp	r6, #0
  402f4c:	d063      	beq.n	403016 <follow_path+0x2a6>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402f4e:	2e20      	cmp	r6, #32
  402f50:	d008      	beq.n	402f64 <follow_path+0x1f4>
  402f52:	1b63      	subs	r3, r4, r5
  402f54:	bf18      	it	ne
  402f56:	2301      	movne	r3, #1
  402f58:	2e2e      	cmp	r6, #46	; 0x2e
  402f5a:	bf14      	ite	ne
  402f5c:	2200      	movne	r2, #0
  402f5e:	f003 0201 	andeq.w	r2, r3, #1
  402f62:	b112      	cbz	r2, 402f6a <follow_path+0x1fa>
			cf |= NS_LOSS | NS_LFN; continue;
  402f64:	f047 0703 	orr.w	r7, r7, #3
  402f68:	e7ea      	b.n	402f40 <follow_path+0x1d0>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  402f6a:	9902      	ldr	r1, [sp, #8]
  402f6c:	42ac      	cmp	r4, r5
  402f6e:	bf18      	it	ne
  402f70:	4588      	cmpne	r8, r1
  402f72:	d316      	bcc.n	402fa2 <follow_path+0x232>
			if (ni == 11) {				/* Long extension */
  402f74:	290b      	cmp	r1, #11
  402f76:	d103      	bne.n	402f80 <follow_path+0x210>
				cf |= NS_LOSS | NS_LFN; break;
  402f78:	f047 0703 	orr.w	r7, r7, #3
  402f7c:	9903      	ldr	r1, [sp, #12]
  402f7e:	e04d      	b.n	40301c <follow_path+0x2ac>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  402f80:	b10b      	cbz	r3, 402f86 <follow_path+0x216>
  402f82:	f047 0703 	orr.w	r7, r7, #3
			if (si > di) break;			/* No extension */
  402f86:	42ac      	cmp	r4, r5
  402f88:	d347      	bcc.n	40301a <follow_path+0x2aa>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  402f8a:	9a03      	ldr	r2, [sp, #12]
  402f8c:	ea4f 0382 	mov.w	r3, r2, lsl #2
  402f90:	b2db      	uxtb	r3, r3
  402f92:	9303      	str	r3, [sp, #12]
  402f94:	4625      	mov	r5, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402f96:	f04f 030b 	mov.w	r3, #11
  402f9a:	9302      	str	r3, [sp, #8]
  402f9c:	f04f 0808 	mov.w	r8, #8
  402fa0:	e7ce      	b.n	402f40 <follow_path+0x1d0>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  402fa2:	2e7f      	cmp	r6, #127	; 0x7f
  402fa4:	d910      	bls.n	402fc8 <follow_path+0x258>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  402fa6:	4630      	mov	r0, r6
  402fa8:	f04f 0100 	mov.w	r1, #0
  402fac:	47d0      	blx	sl
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  402fae:	2800      	cmp	r0, #0
  402fb0:	f000 81c7 	beq.w	403342 <follow_path+0x5d2>
  402fb4:	f244 53dc 	movw	r3, #17884	; 0x45dc
  402fb8:	f2c0 0340 	movt	r3, #64	; 0x40
  402fbc:	181b      	adds	r3, r3, r0
  402fbe:	f813 6c80 	ldrb.w	r6, [r3, #-128]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  402fc2:	f047 0702 	orr.w	r7, r7, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402fc6:	b126      	cbz	r6, 402fd2 <follow_path+0x262>
  402fc8:	9804      	ldr	r0, [sp, #16]
  402fca:	4631      	mov	r1, r6
  402fcc:	9a06      	ldr	r2, [sp, #24]
  402fce:	4790      	blx	r2
  402fd0:	b120      	cbz	r0, 402fdc <follow_path+0x26c>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  402fd2:	f047 0703 	orr.w	r7, r7, #3
  402fd6:	f04f 065f 	mov.w	r6, #95	; 0x5f
  402fda:	e015      	b.n	403008 <follow_path+0x298>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  402fdc:	f1a6 0341 	sub.w	r3, r6, #65	; 0x41
  402fe0:	b29b      	uxth	r3, r3
  402fe2:	2b19      	cmp	r3, #25
  402fe4:	d804      	bhi.n	402ff0 <follow_path+0x280>
					b |= 2;
  402fe6:	9b03      	ldr	r3, [sp, #12]
  402fe8:	f043 0302 	orr.w	r3, r3, #2
  402fec:	9303      	str	r3, [sp, #12]
  402fee:	e00b      	b.n	403008 <follow_path+0x298>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  402ff0:	f1a6 0361 	sub.w	r3, r6, #97	; 0x61
  402ff4:	b29b      	uxth	r3, r3
  402ff6:	2b19      	cmp	r3, #25
						b |= 1; w -= 0x20;
  402ff8:	bf9f      	itttt	ls
  402ffa:	9903      	ldrls	r1, [sp, #12]
  402ffc:	f041 0101 	orrls.w	r1, r1, #1
  403000:	9103      	strls	r1, [sp, #12]
  403002:	3e20      	subls	r6, #32
  403004:	bf98      	it	ls
  403006:	b2b6      	uxthls	r6, r6
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  403008:	f8db 3018 	ldr.w	r3, [fp, #24]
  40300c:	f803 6008 	strb.w	r6, [r3, r8]
  403010:	f108 0801 	add.w	r8, r8, #1
  403014:	e794      	b.n	402f40 <follow_path+0x1d0>
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
  403016:	9903      	ldr	r1, [sp, #12]
  403018:	e000      	b.n	40301c <follow_path+0x2ac>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  40301a:	9903      	ldr	r1, [sp, #12]
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  40301c:	f8db 3018 	ldr.w	r3, [fp, #24]
  403020:	781a      	ldrb	r2, [r3, #0]
  403022:	2ae5      	cmp	r2, #229	; 0xe5
  403024:	bf04      	itt	eq
  403026:	2205      	moveq	r2, #5
  403028:	701a      	strbeq	r2, [r3, #0]

	if (ni == 8) b <<= 2;
  40302a:	9a02      	ldr	r2, [sp, #8]
  40302c:	2a08      	cmp	r2, #8
  40302e:	bf02      	ittt	eq
  403030:	0089      	lsleq	r1, r1, #2
  403032:	b2c9      	uxtbeq	r1, r1
  403034:	9103      	streq	r1, [sp, #12]
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  403036:	9903      	ldr	r1, [sp, #12]
  403038:	f001 030c 	and.w	r3, r1, #12
  40303c:	2b0c      	cmp	r3, #12
  40303e:	d003      	beq.n	403048 <follow_path+0x2d8>
  403040:	f001 0203 	and.w	r2, r1, #3
  403044:	2a03      	cmp	r2, #3
  403046:	d101      	bne.n	40304c <follow_path+0x2dc>
		cf |= NS_LFN;
  403048:	f047 0702 	orr.w	r7, r7, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  40304c:	f007 0202 	and.w	r2, r7, #2
  403050:	b2d2      	uxtb	r2, r2
  403052:	b952      	cbnz	r2, 40306a <follow_path+0x2fa>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  403054:	9903      	ldr	r1, [sp, #12]
  403056:	f001 0203 	and.w	r2, r1, #3
  40305a:	2a01      	cmp	r2, #1
  40305c:	bf08      	it	eq
  40305e:	f047 0710 	orreq.w	r7, r7, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  403062:	2b04      	cmp	r3, #4
  403064:	bf08      	it	eq
  403066:	f047 0708 	orreq.w	r7, r7, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  40306a:	f8db 3018 	ldr.w	r3, [fp, #24]
  40306e:	72df      	strb	r7, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  403070:	4658      	mov	r0, fp
  403072:	f04f 0100 	mov.w	r1, #0
  403076:	f642 23d1 	movw	r3, #10961	; 0x2ad1
  40307a:	f2c0 0340 	movt	r3, #64	; 0x40
  40307e:	4798      	blx	r3
	if (res != FR_OK) return res;
  403080:	4606      	mov	r6, r0
  403082:	2800      	cmp	r0, #0
  403084:	f040 813a 	bne.w	4032fc <follow_path+0x58c>
  403088:	f04f 04ff 	mov.w	r4, #255	; 0xff
  40308c:	4627      	mov	r7, r4

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  40308e:	f642 1381 	movw	r3, #10625	; 0x2981
  403092:	4698      	mov	r8, r3
  403094:	f2c0 0840 	movt	r8, #64	; 0x40
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403098:	f643 03f9 	movw	r3, #14585	; 0x38f9
  40309c:	f2c0 0340 	movt	r3, #64	; 0x40
  4030a0:	9303      	str	r3, [sp, #12]
  4030a2:	f8cd 9004 	str.w	r9, [sp, #4]
  4030a6:	46a1      	mov	r9, r4
  4030a8:	f8cd a008 	str.w	sl, [sp, #8]

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  4030ac:	f8db 0000 	ldr.w	r0, [fp]
  4030b0:	f8db 1010 	ldr.w	r1, [fp, #16]
  4030b4:	47c0      	blx	r8
		if (res != FR_OK) break;
  4030b6:	4606      	mov	r6, r0
  4030b8:	2800      	cmp	r0, #0
  4030ba:	f040 8122 	bne.w	403302 <follow_path+0x592>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  4030be:	f8db 4014 	ldr.w	r4, [fp, #20]
		c = dir[DIR_Name];
  4030c2:	7825      	ldrb	r5, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  4030c4:	2d00      	cmp	r5, #0
  4030c6:	f000 8124 	beq.w	403312 <follow_path+0x5a2>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  4030ca:	7ae3      	ldrb	r3, [r4, #11]
  4030cc:	f003 023f 	and.w	r2, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  4030d0:	2de5      	cmp	r5, #229	; 0xe5
  4030d2:	f000 80a6 	beq.w	403222 <follow_path+0x4b2>
  4030d6:	f003 0308 	and.w	r3, r3, #8
  4030da:	b2db      	uxtb	r3, r3
  4030dc:	b12b      	cbz	r3, 4030ea <follow_path+0x37a>
  4030de:	2a0f      	cmp	r2, #15
			ord = 0xFF;
  4030e0:	bf18      	it	ne
  4030e2:	27ff      	movne	r7, #255	; 0xff
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  4030e4:	f040 80a2 	bne.w	40322c <follow_path+0x4bc>
  4030e8:	e001      	b.n	4030ee <follow_path+0x37e>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  4030ea:	2a0f      	cmp	r2, #15
  4030ec:	d173      	bne.n	4031d6 <follow_path+0x466>
				if (dj->lfn) {
  4030ee:	f8db 601c 	ldr.w	r6, [fp, #28]
  4030f2:	2e00      	cmp	r6, #0
  4030f4:	f000 809a 	beq.w	40322c <follow_path+0x4bc>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  4030f8:	f005 0340 	and.w	r3, r5, #64	; 0x40
  4030fc:	b2db      	uxtb	r3, r3
  4030fe:	b143      	cbz	r3, 403112 <follow_path+0x3a2>
						sum = dir[LDIR_Chksum];
  403100:	f894 900d 	ldrb.w	r9, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
  403104:	f005 05bf 	and.w	r5, r5, #191	; 0xbf
						dj->lfn_idx = dj->index;
  403108:	f8bb 3006 	ldrh.w	r3, [fp, #6]
  40310c:	f8ab 3020 	strh.w	r3, [fp, #32]
  403110:	e004      	b.n	40311c <follow_path+0x3ac>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403112:	42bd      	cmp	r5, r7
  403114:	bf18      	it	ne
  403116:	27ff      	movne	r7, #255	; 0xff
  403118:	f040 8088 	bne.w	40322c <follow_path+0x4bc>
  40311c:	f894 a00d 	ldrb.w	sl, [r4, #13]
  403120:	45ca      	cmp	sl, r9
  403122:	bf18      	it	ne
  403124:	27ff      	movne	r7, #255	; 0xff
  403126:	f040 8081 	bne.w	40322c <follow_path+0x4bc>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  40312a:	7823      	ldrb	r3, [r4, #0]
  40312c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403130:	f103 33ff 	add.w	r3, r3, #4294967295
  403134:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  403138:	eb03 0282 	add.w	r2, r3, r2, lsl #2
  40313c:	9208      	str	r2, [sp, #32]
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  40313e:	9a05      	ldr	r2, [sp, #20]
  403140:	f102 37ff 	add.w	r7, r2, #4294967295
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  403144:	f04f 0901 	mov.w	r9, #1
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  403148:	9509      	str	r5, [sp, #36]	; 0x24
  40314a:	f8cd a010 	str.w	sl, [sp, #16]
  40314e:	464d      	mov	r5, r9
  403150:	f8dd 9020 	ldr.w	r9, [sp, #32]
  403154:	f8cd b018 	str.w	fp, [sp, #24]
  403158:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40315c:	f8dd a01c 	ldr.w	sl, [sp, #28]


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  403160:	f817 3f01 	ldrb.w	r3, [r7, #1]!
  403164:	18e2      	adds	r2, r4, r3
  403166:	7850      	ldrb	r0, [r2, #1]
  403168:	5ce3      	ldrb	r3, [r4, r3]
  40316a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
		if (wc) {	/* Last char has not been processed */
  40316e:	b18d      	cbz	r5, 403194 <follow_path+0x424>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403170:	47d8      	blx	fp
  403172:	4605      	mov	r5, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  403174:	f1b9 0ffe 	cmp.w	r9, #254	; 0xfe
  403178:	f200 80ae 	bhi.w	4032d8 <follow_path+0x568>
  40317c:	f836 0019 	ldrh.w	r0, [r6, r9, lsl #1]
  403180:	f109 0901 	add.w	r9, r9, #1
  403184:	47d8      	blx	fp
  403186:	4285      	cmp	r5, r0
  403188:	d009      	beq.n	40319e <follow_path+0x42e>
  40318a:	f8dd a010 	ldr.w	sl, [sp, #16]
  40318e:	f8dd b018 	ldr.w	fp, [sp, #24]
  403192:	e0aa      	b.n	4032ea <follow_path+0x57a>
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  403194:	f64f 73ff 	movw	r3, #65535	; 0xffff
  403198:	4298      	cmp	r0, r3
  40319a:	f040 80a2 	bne.w	4032e2 <follow_path+0x572>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  40319e:	4557      	cmp	r7, sl
  4031a0:	d1de      	bne.n	403160 <follow_path+0x3f0>
  4031a2:	f8dd a010 	ldr.w	sl, [sp, #16]
  4031a6:	f8cd 9020 	str.w	r9, [sp, #32]
  4031aa:	46a9      	mov	r9, r5
  4031ac:	9d09      	ldr	r5, [sp, #36]	; 0x24
  4031ae:	f8dd b018 	ldr.w	fp, [sp, #24]

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  4031b2:	7823      	ldrb	r3, [r4, #0]
  4031b4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  4031b8:	b2db      	uxtb	r3, r3
  4031ba:	2b00      	cmp	r3, #0
  4031bc:	f000 8099 	beq.w	4032f2 <follow_path+0x582>
  4031c0:	f1b9 0f00 	cmp.w	r9, #0
  4031c4:	f000 8095 	beq.w	4032f2 <follow_path+0x582>
  4031c8:	9908      	ldr	r1, [sp, #32]
  4031ca:	f836 3011 	ldrh.w	r3, [r6, r1, lsl #1]
  4031ce:	2b00      	cmp	r3, #0
  4031d0:	f000 808f 	beq.w	4032f2 <follow_path+0x582>
  4031d4:	e089      	b.n	4032ea <follow_path+0x57a>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  4031d6:	b947      	cbnz	r7, 4031ea <follow_path+0x47a>
  4031d8:	4620      	mov	r0, r4
  4031da:	f242 5399 	movw	r3, #9625	; 0x2599
  4031de:	f2c0 0340 	movt	r3, #64	; 0x40
  4031e2:	4798      	blx	r3
  4031e4:	4548      	cmp	r0, r9
  4031e6:	f000 8099 	beq.w	40331c <follow_path+0x5ac>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  4031ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4031ee:	f8ab 3020 	strh.w	r3, [fp, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  4031f2:	f8db 3018 	ldr.w	r3, [fp, #24]
  4031f6:	7ada      	ldrb	r2, [r3, #11]
  4031f8:	f012 0f01 	tst.w	r2, #1
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  4031fc:	bf04      	itt	eq
  4031fe:	f104 34ff 	addeq.w	r4, r4, #4294967295
  403202:	f103 000b 	addeq.w	r0, r3, #11
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  403206:	d003      	beq.n	403210 <follow_path+0x4a0>
  403208:	e00e      	b.n	403228 <follow_path+0x4b8>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  40320a:	4283      	cmp	r3, r0
  40320c:	f000 808b 	beq.w	403326 <follow_path+0x5b6>
  403210:	f813 2b01 	ldrb.w	r2, [r3], #1
  403214:	f814 1f01 	ldrb.w	r1, [r4, #1]!
  403218:	4291      	cmp	r1, r2
  40321a:	d0f6      	beq.n	40320a <follow_path+0x49a>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40321c:	f04f 07ff 	mov.w	r7, #255	; 0xff
  403220:	e004      	b.n	40322c <follow_path+0x4bc>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  403222:	f04f 07ff 	mov.w	r7, #255	; 0xff
  403226:	e001      	b.n	40322c <follow_path+0x4bc>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  403228:	f04f 07ff 	mov.w	r7, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  40322c:	4658      	mov	r0, fp
  40322e:	f04f 0100 	mov.w	r1, #0
  403232:	f642 3389 	movw	r3, #11145	; 0x2b89
  403236:	f2c0 0340 	movt	r3, #64	; 0x40
  40323a:	4798      	blx	r3
	} while (res == FR_OK);
  40323c:	4606      	mov	r6, r0
  40323e:	2800      	cmp	r0, #0
  403240:	f43f af34 	beq.w	4030ac <follow_path+0x33c>
  403244:	4607      	mov	r7, r0
  403246:	46da      	mov	sl, fp
  403248:	e05d      	b.n	403306 <follow_path+0x596>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  40324a:	f003 0304 	and.w	r3, r3, #4
  40324e:	b2df      	uxtb	r7, r3

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
  403250:	2f00      	cmp	r7, #0
  403252:	bf0c      	ite	eq
  403254:	2705      	moveq	r7, #5
  403256:	2704      	movne	r7, #4
  403258:	e076      	b.n	403348 <follow_path+0x5d8>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  40325a:	f8db 3014 	ldr.w	r3, [fp, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  40325e:	7ada      	ldrb	r2, [r3, #11]
  403260:	f002 0210 	and.w	r2, r2, #16
  403264:	b2d2      	uxtb	r2, r2
  403266:	b162      	cbz	r2, 403282 <follow_path+0x512>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  403268:	7d59      	ldrb	r1, [r3, #21]
  40326a:	7d1a      	ldrb	r2, [r3, #20]
  40326c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  403270:	7ed9      	ldrb	r1, [r3, #27]
  403272:	7e9b      	ldrb	r3, [r3, #26]
  403274:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  403278:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40327c:	f8cb 3008 	str.w	r3, [fp, #8]
		}
  403280:	e5a6      	b.n	402dd0 <follow_path+0x60>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  403282:	f04f 0705 	mov.w	r7, #5
  403286:	e05f      	b.n	403348 <follow_path+0x5d8>
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  403288:	f04f 0400 	mov.w	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  40328c:	f04f 0201 	mov.w	r2, #1
  403290:	e003      	b.n	40329a <follow_path+0x52a>
  403292:	f8dd b00c 	ldr.w	fp, [sp, #12]
  403296:	f8dd 9010 	ldr.w	r9, [sp, #16]
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  40329a:	4491      	add	r9, r2
  40329c:	e5fa      	b.n	402e94 <follow_path+0x124>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  40329e:	9a01      	ldr	r2, [sp, #4]
  4032a0:	eb02 0044 	add.w	r0, r2, r4, lsl #1
  4032a4:	f04f 0300 	mov.w	r3, #0
  4032a8:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  4032ac:	f8db 3018 	ldr.w	r3, [fp, #24]
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
  4032b0:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4032b4:	f04f 0220 	mov.w	r2, #32
  4032b8:	e60b      	b.n	402ed2 <follow_path+0x162>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4032ba:	f04f 0500 	mov.w	r5, #0
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  4032be:	f104 33ff 	add.w	r3, r4, #4294967295
  4032c2:	9901      	ldr	r1, [sp, #4]
  4032c4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
  4032c8:	2b2e      	cmp	r3, #46	; 0x2e
  4032ca:	f43f ae20 	beq.w	402f0e <follow_path+0x19e>
  4032ce:	4603      	mov	r3, r0
  4032d0:	e61b      	b.n	402f0a <follow_path+0x19a>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  4032d2:	f04f 0706 	mov.w	r7, #6
  4032d6:	e037      	b.n	403348 <follow_path+0x5d8>
  4032d8:	f8dd a010 	ldr.w	sl, [sp, #16]
  4032dc:	f8dd b018 	ldr.w	fp, [sp, #24]
  4032e0:	e003      	b.n	4032ea <follow_path+0x57a>
  4032e2:	f8dd a010 	ldr.w	sl, [sp, #16]
  4032e6:	f8dd b018 	ldr.w	fp, [sp, #24]
  4032ea:	46d1      	mov	r9, sl
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  4032ec:	f04f 07ff 	mov.w	r7, #255	; 0xff
  4032f0:	e79c      	b.n	40322c <follow_path+0x4bc>
  4032f2:	f105 35ff 	add.w	r5, r5, #4294967295
  4032f6:	b2ef      	uxtb	r7, r5
  4032f8:	46d1      	mov	r9, sl
  4032fa:	e797      	b.n	40322c <follow_path+0x4bc>
  4032fc:	4607      	mov	r7, r0
  4032fe:	46da      	mov	sl, fp
  403300:	e001      	b.n	403306 <follow_path+0x596>
  403302:	4607      	mov	r7, r0
  403304:	46da      	mov	sl, fp
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  403306:	f8da 3018 	ldr.w	r3, [sl, #24]
  40330a:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  40330c:	2f04      	cmp	r7, #4
  40330e:	d11b      	bne.n	403348 <follow_path+0x5d8>
  403310:	e79b      	b.n	40324a <follow_path+0x4da>
  403312:	46da      	mov	sl, fp
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  403314:	f8db 3018 	ldr.w	r3, [fp, #24]
  403318:	7adb      	ldrb	r3, [r3, #11]
  40331a:	e796      	b.n	40324a <follow_path+0x4da>
  40331c:	f8dd 9004 	ldr.w	r9, [sp, #4]
  403320:	f8dd a008 	ldr.w	sl, [sp, #8]
  403324:	e003      	b.n	40332e <follow_path+0x5be>
  403326:	f8dd 9004 	ldr.w	r9, [sp, #4]
  40332a:	f8dd a008 	ldr.w	sl, [sp, #8]
  40332e:	f8db 3018 	ldr.w	r3, [fp, #24]
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  403332:	7adb      	ldrb	r3, [r3, #11]
  403334:	f003 0304 	and.w	r3, r3, #4
  403338:	b2db      	uxtb	r3, r3
  40333a:	2b00      	cmp	r3, #0
  40333c:	d08d      	beq.n	40325a <follow_path+0x4ea>
  40333e:	4637      	mov	r7, r6
  403340:	e002      	b.n	403348 <follow_path+0x5d8>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  403342:	f047 0702 	orr.w	r7, r7, #2
  403346:	e644      	b.n	402fd2 <follow_path+0x262>
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403348:	4638      	mov	r0, r7
  40334a:	b00b      	add	sp, #44	; 0x2c
  40334c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00403350 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  403350:	b9a0      	cbnz	r0, 40337c <f_mount+0x2c>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  403352:	f240 5300 	movw	r3, #1280	; 0x500
  403356:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40335a:	681b      	ldr	r3, [r3, #0]

	if (rfs) {
  40335c:	b113      	cbz	r3, 403364 <f_mount+0x14>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  40335e:	f04f 0200 	mov.w	r2, #0
  403362:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  403364:	b111      	cbz	r1, 40336c <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
  403366:	f04f 0300 	mov.w	r3, #0
  40336a:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  40336c:	f240 5300 	movw	r3, #1280	; 0x500
  403370:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403374:	6019      	str	r1, [r3, #0]

	return FR_OK;
  403376:	f04f 0000 	mov.w	r0, #0
  40337a:	4770      	bx	lr
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
  40337c:	f04f 000b 	mov.w	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  403380:	4770      	bx	lr
  403382:	bf00      	nop

00403384 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  403384:	b530      	push	{r4, r5, lr}
  403386:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
  40338a:	4604      	mov	r4, r0
  40338c:	9101      	str	r1, [sp, #4]
  40338e:	4615      	mov	r5, r2
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  403390:	f04f 0200 	mov.w	r2, #0
  403394:	6002      	str	r2, [r0, #0]
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
  403396:	a801      	add	r0, sp, #4
  403398:	a985      	add	r1, sp, #532	; 0x214
  40339a:	f242 63a5 	movw	r3, #9893	; 0x26a5
  40339e:	f2c0 0340 	movt	r3, #64	; 0x40
  4033a2:	4798      	blx	r3
#endif
	INIT_BUF(dj);
  4033a4:	ab82      	add	r3, sp, #520	; 0x208
  4033a6:	938b      	str	r3, [sp, #556]	; 0x22c
  4033a8:	ab02      	add	r3, sp, #8
  4033aa:	938c      	str	r3, [sp, #560]	; 0x230
	if (res == FR_OK)
  4033ac:	4603      	mov	r3, r0
  4033ae:	2800      	cmp	r0, #0
  4033b0:	d137      	bne.n	403422 <f_open+0x9e>
		res = follow_path(&dj, path);	/* Follow the file path */
  4033b2:	a885      	add	r0, sp, #532	; 0x214
  4033b4:	9901      	ldr	r1, [sp, #4]
  4033b6:	f642 5371 	movw	r3, #11633	; 0x2d71
  4033ba:	f2c0 0340 	movt	r3, #64	; 0x40
  4033be:	4798      	blx	r3
	dir = dj.dir;
  4033c0:	998a      	ldr	r1, [sp, #552]	; 0x228
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
  4033c2:	4603      	mov	r3, r0
  4033c4:	bb68      	cbnz	r0, 403422 <f_open+0x9e>
		if (!dir) {						/* Current dir itself */
  4033c6:	b339      	cbz	r1, 403418 <f_open+0x94>
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
  4033c8:	7aca      	ldrb	r2, [r1, #11]
  4033ca:	f002 0210 	and.w	r2, r2, #16
  4033ce:	b2d2      	uxtb	r2, r2
  4033d0:	bb2a      	cbnz	r2, 40341e <f_open+0x9a>

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
  4033d2:	f005 0501 	and.w	r5, r5, #1
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  4033d6:	71a5      	strb	r5, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  4033d8:	7d48      	ldrb	r0, [r1, #21]
  4033da:	7d0a      	ldrb	r2, [r1, #20]
  4033dc:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  4033e0:	7ecd      	ldrb	r5, [r1, #27]
  4033e2:	7e8a      	ldrb	r2, [r1, #26]
  4033e4:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  4033e8:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  4033ec:	6122      	str	r2, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4033ee:	7fc8      	ldrb	r0, [r1, #31]
  4033f0:	7f8a      	ldrb	r2, [r1, #30]
  4033f2:	ea4f 4202 	mov.w	r2, r2, lsl #16
  4033f6:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  4033fa:	7f08      	ldrb	r0, [r1, #28]
  4033fc:	4302      	orrs	r2, r0
  4033fe:	7f49      	ldrb	r1, [r1, #29]
  403400:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  403404:	60e2      	str	r2, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  403406:	f04f 0200 	mov.w	r2, #0
  40340a:	60a2      	str	r2, [r4, #8]
		fp->dsect = 0;
  40340c:	61a2      	str	r2, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  40340e:	9a85      	ldr	r2, [sp, #532]	; 0x214
  403410:	6022      	str	r2, [r4, #0]
  403412:	88d2      	ldrh	r2, [r2, #6]
  403414:	80a2      	strh	r2, [r4, #4]
  403416:	e004      	b.n	403422 <f_open+0x9e>
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
			res = FR_INVALID_NAME;
  403418:	f04f 0306 	mov.w	r3, #6
  40341c:	e001      	b.n	403422 <f_open+0x9e>
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
				res = FR_NO_FILE;
  40341e:	f04f 0304 	mov.w	r3, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403422:	4618      	mov	r0, r3
  403424:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403428:	bd30      	pop	{r4, r5, pc}
  40342a:	bf00      	nop

0040342c <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  40342c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403430:	b087      	sub	sp, #28
  403432:	4604      	mov	r4, r0
  403434:	460f      	mov	r7, r1
  403436:	4691      	mov	r9, r2
  403438:	461e      	mov	r6, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  40343a:	f04f 0300 	mov.w	r3, #0
  40343e:	6033      	str	r3, [r6, #0]

	res = validate(fp->fs, fp->id);				/* Check validity */
  403440:	6800      	ldr	r0, [r0, #0]
  403442:	88a1      	ldrh	r1, [r4, #4]
  403444:	f242 53bd 	movw	r3, #9661	; 0x25bd
  403448:	f2c0 0340 	movt	r3, #64	; 0x40
  40344c:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  40344e:	4680      	mov	r8, r0
  403450:	2800      	cmp	r0, #0
  403452:	f040 80c4 	bne.w	4035de <f_read+0x1b2>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403456:	79a3      	ldrb	r3, [r4, #6]
  403458:	f013 0f80 	tst.w	r3, #128	; 0x80
		LEAVE_FF(fp->fs, FR_INT_ERR);
  40345c:	bf18      	it	ne
  40345e:	f04f 0802 	movne.w	r8, #2

	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403462:	f040 80bc 	bne.w	4035de <f_read+0x1b2>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403466:	f013 0f01 	tst.w	r3, #1
		LEAVE_FF(fp->fs, FR_DENIED);
  40346a:	bf08      	it	eq
  40346c:	f04f 0807 	moveq.w	r8, #7

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403470:	f000 80b5 	beq.w	4035de <f_read+0x1b2>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403474:	68e5      	ldr	r5, [r4, #12]
  403476:	68a3      	ldr	r3, [r4, #8]
  403478:	1aed      	subs	r5, r5, r3
  40347a:	45a9      	cmp	r9, r5
  40347c:	bf38      	it	cc
  40347e:	464d      	movcc	r5, r9
  403480:	9501      	str	r5, [sp, #4]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403482:	2d00      	cmp	r5, #0
  403484:	f000 80ab 	beq.w	4035de <f_read+0x1b2>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  403488:	f242 537d 	movw	r3, #9597	; 0x257d
  40348c:	f2c0 0340 	movt	r3, #64	; 0x40
  403490:	9303      	str	r3, [sp, #12]
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403492:	f242 43e1 	movw	r3, #9441	; 0x24e1
  403496:	f2c0 0340 	movt	r3, #64	; 0x40
  40349a:	9304      	str	r3, [sp, #16]
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  40349c:	f642 13bd 	movw	r3, #10685	; 0x29bd
  4034a0:	f2c0 0340 	movt	r3, #64	; 0x40
  4034a4:	9305      	str	r3, [sp, #20]
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  4034a6:	68a2      	ldr	r2, [r4, #8]
  4034a8:	ea4f 53c2 	mov.w	r3, r2, lsl #23
  4034ac:	ea4f 53d3 	mov.w	r3, r3, lsr #23
  4034b0:	2b00      	cmp	r3, #0
  4034b2:	d16a      	bne.n	40358a <f_read+0x15e>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  4034b4:	6820      	ldr	r0, [r4, #0]
  4034b6:	7883      	ldrb	r3, [r0, #2]
  4034b8:	f103 33ff 	add.w	r3, r3, #4294967295
  4034bc:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  4034c0:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
  4034c4:	d119      	bne.n	4034fa <f_read+0xce>
				if (fp->fptr == 0) {			/* On the top of the file? */
  4034c6:	b90a      	cbnz	r2, 4034cc <f_read+0xa0>
					clst = fp->sclust;			/* Follow from the origin */
  4034c8:	6920      	ldr	r0, [r4, #16]
  4034ca:	e002      	b.n	4034d2 <f_read+0xa6>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  4034cc:	6961      	ldr	r1, [r4, #20]
  4034ce:	9d05      	ldr	r5, [sp, #20]
  4034d0:	47a8      	blx	r5
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  4034d2:	2801      	cmp	r0, #1
  4034d4:	d806      	bhi.n	4034e4 <f_read+0xb8>
  4034d6:	79a3      	ldrb	r3, [r4, #6]
  4034d8:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4034dc:	71a3      	strb	r3, [r4, #6]
  4034de:	f04f 0802 	mov.w	r8, #2
  4034e2:	e07c      	b.n	4035de <f_read+0x1b2>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4034e4:	f1b0 3fff 	cmp.w	r0, #4294967295
  4034e8:	d106      	bne.n	4034f8 <f_read+0xcc>
  4034ea:	79a3      	ldrb	r3, [r4, #6]
  4034ec:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4034f0:	71a3      	strb	r3, [r4, #6]
  4034f2:	f04f 0801 	mov.w	r8, #1
  4034f6:	e072      	b.n	4035de <f_read+0x1b2>
				fp->clust = clst;				/* Update current cluster */
  4034f8:	6160      	str	r0, [r4, #20]
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  4034fa:	f8d4 9000 	ldr.w	r9, [r4]
  4034fe:	4648      	mov	r0, r9
  403500:	6961      	ldr	r1, [r4, #20]
  403502:	9d03      	ldr	r5, [sp, #12]
  403504:	47a8      	blx	r5
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403506:	4682      	mov	sl, r0
  403508:	b930      	cbnz	r0, 403518 <f_read+0xec>
  40350a:	79a3      	ldrb	r3, [r4, #6]
  40350c:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403510:	71a3      	strb	r3, [r4, #6]
  403512:	f04f 0802 	mov.w	r8, #2
  403516:	e062      	b.n	4035de <f_read+0x1b2>
			sect += csect;
  403518:	eb00 0a0b 	add.w	sl, r0, fp
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  40351c:	9d01      	ldr	r5, [sp, #4]
  40351e:	0a6d      	lsrs	r5, r5, #9
  403520:	9502      	str	r5, [sp, #8]
  403522:	d01c      	beq.n	40355e <f_read+0x132>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  403524:	f899 3002 	ldrb.w	r3, [r9, #2]
  403528:	eb05 020b 	add.w	r2, r5, fp
  40352c:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
  40352e:	bf84      	itt	hi
  403530:	ebcb 0303 	rsbhi	r3, fp, r3
  403534:	9302      	strhi	r3, [sp, #8]
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403536:	f899 0001 	ldrb.w	r0, [r9, #1]
  40353a:	4639      	mov	r1, r7
  40353c:	4652      	mov	r2, sl
  40353e:	9d02      	ldr	r5, [sp, #8]
  403540:	b2eb      	uxtb	r3, r5
  403542:	9d04      	ldr	r5, [sp, #16]
  403544:	47a8      	blx	r5
  403546:	b130      	cbz	r0, 403556 <f_read+0x12a>
					ABORT(fp->fs, FR_DISK_ERR);
  403548:	79a3      	ldrb	r3, [r4, #6]
  40354a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40354e:	71a3      	strb	r3, [r4, #6]
  403550:	f04f 0801 	mov.w	r8, #1
  403554:	e043      	b.n	4035de <f_read+0x1b2>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403556:	9d02      	ldr	r5, [sp, #8]
  403558:	ea4f 2b45 	mov.w	fp, r5, lsl #9
				continue;
  40355c:	e031      	b.n	4035c2 <f_read+0x196>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  40355e:	69a3      	ldr	r3, [r4, #24]
  403560:	4553      	cmp	r3, sl
  403562:	d010      	beq.n	403586 <f_read+0x15a>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403564:	f899 0001 	ldrb.w	r0, [r9, #1]
  403568:	f104 011c 	add.w	r1, r4, #28
  40356c:	4652      	mov	r2, sl
  40356e:	f04f 0301 	mov.w	r3, #1
  403572:	9d04      	ldr	r5, [sp, #16]
  403574:	47a8      	blx	r5
  403576:	b130      	cbz	r0, 403586 <f_read+0x15a>
					ABORT(fp->fs, FR_DISK_ERR);
  403578:	79a3      	ldrb	r3, [r4, #6]
  40357a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40357e:	71a3      	strb	r3, [r4, #6]
  403580:	f04f 0801 	mov.w	r8, #1
  403584:	e02b      	b.n	4035de <f_read+0x1b2>
			}
#endif
			fp->dsect = sect;
  403586:	f8c4 a018 	str.w	sl, [r4, #24]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  40358a:	68a2      	ldr	r2, [r4, #8]
  40358c:	ea4f 52c2 	mov.w	r2, r2, lsl #23
  403590:	ea4f 52d2 	mov.w	r2, r2, lsr #23
  403594:	f5c2 7b00 	rsb	fp, r2, #512	; 0x200
  403598:	9d01      	ldr	r5, [sp, #4]
  40359a:	455d      	cmp	r5, fp
  40359c:	bf38      	it	cc
  40359e:	46ab      	movcc	fp, r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  4035a0:	18a2      	adds	r2, r4, r2
  4035a2:	f102 021c 	add.w	r2, r2, #28
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4035a6:	f1bb 0f00 	cmp.w	fp, #0
  4035aa:	d00a      	beq.n	4035c2 <f_read+0x196>

/*-----------------------------------------------------------------------*/
/* Read File                                                             */
/*-----------------------------------------------------------------------*/

FRESULT f_read (
  4035ac:	f102 32ff 	add.w	r2, r2, #4294967295
  4035b0:	eb07 000b 	add.w	r0, r7, fp
  4035b4:	463b      	mov	r3, r7
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4035b6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  4035ba:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4035be:	4283      	cmp	r3, r0
  4035c0:	d1f9      	bne.n	4035b6 <f_read+0x18a>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4035c2:	445f      	add	r7, fp
  4035c4:	68a3      	ldr	r3, [r4, #8]
  4035c6:	445b      	add	r3, fp
  4035c8:	60a3      	str	r3, [r4, #8]
  4035ca:	6833      	ldr	r3, [r6, #0]
  4035cc:	445b      	add	r3, fp
  4035ce:	6033      	str	r3, [r6, #0]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4035d0:	9d01      	ldr	r5, [sp, #4]
  4035d2:	ebb5 050b 	subs.w	r5, r5, fp
  4035d6:	9501      	str	r5, [sp, #4]
  4035d8:	f47f af65 	bne.w	4034a6 <f_read+0x7a>
  4035dc:	e7ff      	b.n	4035de <f_read+0x1b2>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  4035de:	4640      	mov	r0, r8
  4035e0:	b007      	add	sp, #28
  4035e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4035e6:	bf00      	nop

004035e8 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  4035e8:	b510      	push	{r4, lr}
  4035ea:	4604      	mov	r4, r0
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
  4035ec:	6800      	ldr	r0, [r0, #0]
  4035ee:	88a1      	ldrh	r1, [r4, #4]
  4035f0:	f242 53bd 	movw	r3, #9661	; 0x25bd
  4035f4:	f2c0 0340 	movt	r3, #64	; 0x40
  4035f8:	4798      	blx	r3
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  4035fa:	4603      	mov	r3, r0
  4035fc:	b910      	cbnz	r0, 403604 <f_close+0x1c>
  4035fe:	f04f 0200 	mov.w	r2, #0
  403602:	6022      	str	r2, [r4, #0]
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
  403604:	4618      	mov	r0, r3
  403606:	bd10      	pop	{r4, pc}

00403608 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
  403608:	b510      	push	{r4, lr}
  40360a:	f5ad 7d06 	sub.w	sp, sp, #536	; 0x218
  40360e:	4604      	mov	r4, r0
  403610:	9101      	str	r1, [sp, #4]
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
  403612:	a801      	add	r0, sp, #4
  403614:	4621      	mov	r1, r4
  403616:	f04f 0200 	mov.w	r2, #0
  40361a:	f242 63a5 	movw	r3, #9893	; 0x26a5
  40361e:	f2c0 0340 	movt	r3, #64	; 0x40
  403622:	4798      	blx	r3
	if (res == FR_OK) {
  403624:	4603      	mov	r3, r0
  403626:	2800      	cmp	r0, #0
  403628:	d133      	bne.n	403692 <f_opendir+0x8a>
		INIT_BUF(*dj);
  40362a:	ab83      	add	r3, sp, #524	; 0x20c
  40362c:	61a3      	str	r3, [r4, #24]
  40362e:	ab03      	add	r3, sp, #12
  403630:	61e3      	str	r3, [r4, #28]
		res = follow_path(dj, path);			/* Follow the path to the directory */
  403632:	4620      	mov	r0, r4
  403634:	9901      	ldr	r1, [sp, #4]
  403636:	f642 5371 	movw	r3, #11633	; 0x2d71
  40363a:	f2c0 0340 	movt	r3, #64	; 0x40
  40363e:	4798      	blx	r3
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
  403640:	4603      	mov	r3, r0
  403642:	b990      	cbnz	r0, 40366a <f_opendir+0x62>
			if (dj->dir) {						/* It is not the root dir */
  403644:	6963      	ldr	r3, [r4, #20]
  403646:	b1bb      	cbz	r3, 403678 <f_opendir+0x70>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
  403648:	7ada      	ldrb	r2, [r3, #11]
  40364a:	f002 0210 	and.w	r2, r2, #16
  40364e:	b2d2      	uxtb	r2, r2
  403650:	b17a      	cbz	r2, 403672 <f_opendir+0x6a>
					dj->sclust = LD_CLUST(dj->dir);
  403652:	7d59      	ldrb	r1, [r3, #21]
  403654:	7d1a      	ldrb	r2, [r3, #20]
  403656:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  40365a:	7ed9      	ldrb	r1, [r3, #27]
  40365c:	7e9b      	ldrb	r3, [r3, #26]
  40365e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  403662:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403666:	60a3      	str	r3, [r4, #8]
  403668:	e006      	b.n	403678 <f_opendir+0x70>
			if (res == FR_OK) {
				dj->id = dj->fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
  40366a:	2b04      	cmp	r3, #4
  40366c:	bf08      	it	eq
  40366e:	2305      	moveq	r3, #5
  403670:	e00f      	b.n	403692 <f_opendir+0x8a>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = LD_CLUST(dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
  403672:	f04f 0305 	mov.w	r3, #5
  403676:	e00c      	b.n	403692 <f_opendir+0x8a>
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
  403678:	6823      	ldr	r3, [r4, #0]
  40367a:	88db      	ldrh	r3, [r3, #6]
  40367c:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
  40367e:	4620      	mov	r0, r4
  403680:	f04f 0100 	mov.w	r1, #0
  403684:	f642 23d1 	movw	r3, #10961	; 0x2ad1
  403688:	f2c0 0340 	movt	r3, #64	; 0x40
  40368c:	4798      	blx	r3
  40368e:	4603      	mov	r3, r0
  403690:	e7eb      	b.n	40366a <f_opendir+0x62>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
  403692:	4618      	mov	r0, r3
  403694:	f50d 7d06 	add.w	sp, sp, #536	; 0x218
  403698:	bd10      	pop	{r4, pc}
  40369a:	bf00      	nop

0040369c <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  40369c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4036a0:	f5ad 7d0b 	sub.w	sp, sp, #556	; 0x22c
  4036a4:	4604      	mov	r4, r0
  4036a6:	468b      	mov	fp, r1
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  4036a8:	6800      	ldr	r0, [r0, #0]
  4036aa:	88a1      	ldrh	r1, [r4, #4]
  4036ac:	f242 53bd 	movw	r3, #9661	; 0x25bd
  4036b0:	f2c0 0340 	movt	r3, #64	; 0x40
  4036b4:	4798      	blx	r3
	if (res == FR_OK) {
  4036b6:	4606      	mov	r6, r0
  4036b8:	2800      	cmp	r0, #0
  4036ba:	f040 80ed 	bne.w	403898 <f_readdir+0x1fc>
		if (!fno) {
  4036be:	f1bb 0f00 	cmp.w	fp, #0
  4036c2:	d109      	bne.n	4036d8 <f_readdir+0x3c>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
  4036c4:	4620      	mov	r0, r4
  4036c6:	f04f 0100 	mov.w	r1, #0
  4036ca:	f642 23d1 	movw	r3, #10961	; 0x2ad1
  4036ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4036d2:	4798      	blx	r3
  4036d4:	4606      	mov	r6, r0
  4036d6:	e0df      	b.n	403898 <f_readdir+0x1fc>
		} else {
			INIT_BUF(*dj);
  4036d8:	ab87      	add	r3, sp, #540	; 0x21c
  4036da:	61a3      	str	r3, [r4, #24]
  4036dc:	ab07      	add	r3, sp, #28
  4036de:	61e3      	str	r3, [r4, #28]
)
{
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
  4036e0:	f04f 0aff 	mov.w	sl, #255	; 0xff
  4036e4:	4657      	mov	r7, sl
#endif

	res = FR_NO_FILE;
  4036e6:	f04f 0504 	mov.w	r5, #4
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  4036ea:	f642 1881 	movw	r8, #10625	; 0x2981
  4036ee:	f2c0 0840 	movt	r8, #64	; 0x40
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  4036f2:	46d1      	mov	r9, sl

/*-----------------------------------------------------------------------*/
/* Read Directory Entry in Sequense                                      */
/*-----------------------------------------------------------------------*/

FRESULT f_readdir (
  4036f4:	f244 53cc 	movw	r3, #17868	; 0x45cc
  4036f8:	f2c0 0340 	movt	r3, #64	; 0x40
  4036fc:	9301      	str	r3, [sp, #4]
  4036fe:	f103 000c 	add.w	r0, r3, #12
  403702:	9002      	str	r0, [sp, #8]
  403704:	46ac      	mov	ip, r5
  403706:	4645      	mov	r5, r8
  403708:	e08a      	b.n	403820 <f_readdir+0x184>
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  40370a:	6820      	ldr	r0, [r4, #0]
  40370c:	47a8      	blx	r5
		if (res != FR_OK) break;
  40370e:	4684      	mov	ip, r0
  403710:	2800      	cmp	r0, #0
  403712:	f040 808c 	bne.w	40382e <f_readdir+0x192>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  403716:	6962      	ldr	r2, [r4, #20]
		c = dir[DIR_Name];
  403718:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  40371a:	2b00      	cmp	r3, #0
  40371c:	f000 80b9 	beq.w	403892 <f_readdir+0x1f6>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  403720:	7ad1      	ldrb	r1, [r2, #11]
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403722:	2be5      	cmp	r3, #229	; 0xe5
  403724:	bf18      	it	ne
  403726:	2b2e      	cmpne	r3, #46	; 0x2e
  403728:	d06e      	beq.n	403808 <f_readdir+0x16c>
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  40372a:	f001 003f 	and.w	r0, r1, #63	; 0x3f
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40372e:	f001 0108 	and.w	r1, r1, #8
  403732:	b2c9      	uxtb	r1, r1
  403734:	b121      	cbz	r1, 403740 <f_readdir+0xa4>
  403736:	280f      	cmp	r0, #15
			ord = 0xFF;
  403738:	bf18      	it	ne
  40373a:	464f      	movne	r7, r9
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40373c:	d166      	bne.n	40380c <f_readdir+0x170>
  40373e:	e001      	b.n	403744 <f_readdir+0xa8>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  403740:	280f      	cmp	r0, #15
  403742:	d153      	bne.n	4037ec <f_readdir+0x150>
				if (c & LLE) {			/* Is it start of LFN sequence? */
  403744:	f003 0140 	and.w	r1, r3, #64	; 0x40
  403748:	b2c9      	uxtb	r1, r1
  40374a:	b131      	cbz	r1, 40375a <f_readdir+0xbe>
					sum = dir[LDIR_Chksum];
  40374c:	f892 a00d 	ldrb.w	sl, [r2, #13]
					c &= ~LLE; ord = c;
  403750:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
					dj->lfn_idx = dj->index;
  403754:	88e1      	ldrh	r1, [r4, #6]
  403756:	8421      	strh	r1, [r4, #32]
  403758:	e003      	b.n	403762 <f_readdir+0xc6>
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40375a:	42bb      	cmp	r3, r7
  40375c:	bf18      	it	ne
  40375e:	464f      	movne	r7, r9
  403760:	d154      	bne.n	40380c <f_readdir+0x170>
  403762:	f892 c00d 	ldrb.w	ip, [r2, #13]
  403766:	45d4      	cmp	ip, sl
  403768:	bf18      	it	ne
  40376a:	464f      	movne	r7, r9
  40376c:	d14e      	bne.n	40380c <f_readdir+0x170>
  40376e:	69e1      	ldr	r1, [r4, #28]
  403770:	9103      	str	r1, [sp, #12]
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  403772:	7811      	ldrb	r1, [r2, #0]
  403774:	f001 013f 	and.w	r1, r1, #63	; 0x3f
  403778:	f101 31ff 	add.w	r1, r1, #4294967295
  40377c:	eb01 0741 	add.w	r7, r1, r1, lsl #1
  403780:	eb01 0787 	add.w	r7, r1, r7, lsl #2

/*-----------------------------------------------------------------------*/
/* Read Directory Entry in Sequense                                      */
/*-----------------------------------------------------------------------*/

FRESULT f_readdir (
  403784:	9801      	ldr	r0, [sp, #4]
  403786:	f100 31ff 	add.w	r1, r0, #4294967295
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
  40378a:	f04f 0801 	mov.w	r8, #1
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  40378e:	f64f 7aff 	movw	sl, #65535	; 0xffff
  403792:	9305      	str	r3, [sp, #20]
  403794:	4623      	mov	r3, r4
  403796:	4644      	mov	r4, r8
  403798:	9504      	str	r5, [sp, #16]
  40379a:	9d03      	ldr	r5, [sp, #12]
  40379c:	f8dd e008 	ldr.w	lr, [sp, #8]
  4037a0:	4698      	mov	r8, r3

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
  4037a2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  4037a6:	18d0      	adds	r0, r2, r3
  4037a8:	7840      	ldrb	r0, [r0, #1]
  4037aa:	5cd3      	ldrb	r3, [r2, r3]
  4037ac:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
		if (wc) {	/* Last char has not been processed */
  4037b0:	b13c      	cbz	r4, 4037c2 <f_readdir+0x126>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
  4037b2:	2ffe      	cmp	r7, #254	; 0xfe
  4037b4:	d860      	bhi.n	403878 <f_readdir+0x1dc>
			lfnbuf[i++] = wc = uc;			/* Store it */
  4037b6:	f825 0017 	strh.w	r0, [r5, r7, lsl #1]
  4037ba:	f107 0701 	add.w	r7, r7, #1
  4037be:	4604      	mov	r4, r0
  4037c0:	e001      	b.n	4037c6 <f_readdir+0x12a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  4037c2:	4550      	cmp	r0, sl
  4037c4:	d15b      	bne.n	40387e <f_readdir+0x1e2>
		}
	} while (++s < 13);						/* Read all character in the entry */
  4037c6:	4571      	cmp	r1, lr
  4037c8:	d1eb      	bne.n	4037a2 <f_readdir+0x106>
  4037ca:	9b05      	ldr	r3, [sp, #20]
  4037cc:	4644      	mov	r4, r8
  4037ce:	9d04      	ldr	r5, [sp, #16]

	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
  4037d0:	7812      	ldrb	r2, [r2, #0]
  4037d2:	f002 0240 	and.w	r2, r2, #64	; 0x40
  4037d6:	b2d2      	uxtb	r2, r2
  4037d8:	2a00      	cmp	r2, #0
  4037da:	d055      	beq.n	403888 <f_readdir+0x1ec>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
  4037dc:	2ffe      	cmp	r7, #254	; 0xfe
  4037de:	d850      	bhi.n	403882 <f_readdir+0x1e6>
		lfnbuf[i] = 0;
  4037e0:	f04f 0200 	mov.w	r2, #0
  4037e4:	9903      	ldr	r1, [sp, #12]
  4037e6:	f821 2017 	strh.w	r2, [r1, r7, lsl #1]
  4037ea:	e04d      	b.n	403888 <f_readdir+0x1ec>
  4037ec:	4610      	mov	r0, r2
  4037ee:	4665      	mov	r5, ip
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
  4037f0:	b937      	cbnz	r7, 403800 <f_readdir+0x164>
  4037f2:	f242 5399 	movw	r3, #9625	; 0x2599
  4037f6:	f2c0 0340 	movt	r3, #64	; 0x40
  4037fa:	4798      	blx	r3
  4037fc:	4550      	cmp	r0, sl
  4037fe:	d021      	beq.n	403844 <f_readdir+0x1a8>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
  403800:	f64f 73ff 	movw	r3, #65535	; 0xffff
  403804:	8423      	strh	r3, [r4, #32]
  403806:	e01d      	b.n	403844 <f_readdir+0x1a8>
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
  403808:	464f      	mov	r7, r9
  40380a:	e7ff      	b.n	40380c <f_readdir+0x170>
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
  40380c:	4620      	mov	r0, r4
  40380e:	f04f 0100 	mov.w	r1, #0
  403812:	f642 3389 	movw	r3, #11145	; 0x2b89
  403816:	f2c0 0340 	movt	r3, #64	; 0x40
  40381a:	4798      	blx	r3
		if (res != FR_OK) break;
  40381c:	4684      	mov	ip, r0
  40381e:	b940      	cbnz	r0, 403832 <f_readdir+0x196>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  403820:	6921      	ldr	r1, [r4, #16]
  403822:	2900      	cmp	r1, #0
  403824:	f47f af71 	bne.w	40370a <f_readdir+0x6e>
  403828:	4665      	mov	r5, ip
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  40382a:	b15d      	cbz	r5, 403844 <f_readdir+0x1a8>
  40382c:	e002      	b.n	403834 <f_readdir+0x198>
  40382e:	4605      	mov	r5, r0
  403830:	e000      	b.n	403834 <f_readdir+0x198>
  403832:	4605      	mov	r5, r0
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
  403834:	2d04      	cmp	r5, #4
				dj->sect = 0;
  403836:	bf04      	itt	eq
  403838:	2300      	moveq	r3, #0
  40383a:	6123      	streq	r3, [r4, #16]
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
  40383c:	d003      	beq.n	403846 <f_readdir+0x1aa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  40383e:	f04f 0300 	mov.w	r3, #0
  403842:	6123      	str	r3, [r4, #16]
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
  403844:	b9a5      	cbnz	r5, 403870 <f_readdir+0x1d4>
				get_fileinfo(dj, fno);		/* Get the object information */
  403846:	4620      	mov	r0, r4
  403848:	4659      	mov	r1, fp
  40384a:	f642 432d 	movw	r3, #11309	; 0x2c2d
  40384e:	f2c0 0340 	movt	r3, #64	; 0x40
  403852:	4798      	blx	r3
				res = dir_next(dj, 0);		/* Increment index for next */
  403854:	4620      	mov	r0, r4
  403856:	f04f 0100 	mov.w	r1, #0
  40385a:	f642 3389 	movw	r3, #11145	; 0x2b89
  40385e:	f2c0 0340 	movt	r3, #64	; 0x40
  403862:	4798      	blx	r3
				if (res == FR_NO_FILE) {
  403864:	2804      	cmp	r0, #4
					dj->sect = 0;
  403866:	bf04      	itt	eq
  403868:	2300      	moveq	r3, #0
  40386a:	6123      	streq	r3, [r4, #16]
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
				if (res == FR_NO_FILE) {
  40386c:	d014      	beq.n	403898 <f_readdir+0x1fc>
  40386e:	e001      	b.n	403874 <f_readdir+0x1d8>
			res = dir_read(dj);				/* Read an directory item */
			if (res == FR_NO_FILE) {		/* Reached end of dir */
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
  403870:	462e      	mov	r6, r5
  403872:	e011      	b.n	403898 <f_readdir+0x1fc>
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
  403874:	4606      	mov	r6, r0
  403876:	e00f      	b.n	403898 <f_readdir+0x1fc>
  403878:	4644      	mov	r4, r8
  40387a:	9d04      	ldr	r5, [sp, #16]
  40387c:	e001      	b.n	403882 <f_readdir+0x1e6>
  40387e:	4644      	mov	r4, r8
  403880:	9d04      	ldr	r5, [sp, #16]
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403882:	46e2      	mov	sl, ip
  403884:	464f      	mov	r7, r9
  403886:	e7c1      	b.n	40380c <f_readdir+0x170>
  403888:	f103 33ff 	add.w	r3, r3, #4294967295
  40388c:	b2df      	uxtb	r7, r3
  40388e:	46e2      	mov	sl, ip
  403890:	e7bc      	b.n	40380c <f_readdir+0x170>
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  403892:	f04f 0504 	mov.w	r5, #4
  403896:	e7cd      	b.n	403834 <f_readdir+0x198>
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
  403898:	4630      	mov	r0, r6
  40389a:	f50d 7d0b 	add.w	sp, sp, #556	; 0x22c
  40389e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4038a2:	bf00      	nop

004038a4 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  4038a4:	287f      	cmp	r0, #127	; 0x7f
  4038a6:	d926      	bls.n	4038f6 <ff_convert+0x52>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  4038a8:	b941      	cbnz	r1, 4038bc <ff_convert+0x18>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
  4038aa:	28c7      	cmp	r0, #199	; 0xc7
  4038ac:	bf1e      	ittt	ne
  4038ae:	f644 023c 	movwne	r2, #18492	; 0x483c
  4038b2:	f2c0 0240 	movtne	r2, #64	; 0x40
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  4038b6:	2301      	movne	r3, #1
				if (src == Tbl[c]) break;
  4038b8:	d10b      	bne.n	4038d2 <ff_convert+0x2e>
  4038ba:	e014      	b.n	4038e6 <ff_convert+0x42>
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4038bc:	28ff      	cmp	r0, #255	; 0xff
  4038be:	d818      	bhi.n	4038f2 <ff_convert+0x4e>
  4038c0:	f644 033c 	movw	r3, #18492	; 0x483c
  4038c4:	f2c0 0340 	movt	r3, #64	; 0x40
  4038c8:	f1a0 0080 	sub.w	r0, r0, #128	; 0x80
  4038cc:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
  4038d0:	4770      	bx	lr

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (src == Tbl[c]) break;
  4038d2:	f832 1f02 	ldrh.w	r1, [r2, #2]!
  4038d6:	4281      	cmp	r1, r0
  4038d8:	d007      	beq.n	4038ea <ff_convert+0x46>
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  4038da:	f103 0301 	add.w	r3, r3, #1
  4038de:	b29b      	uxth	r3, r3
  4038e0:	2b80      	cmp	r3, #128	; 0x80
  4038e2:	d1f6      	bne.n	4038d2 <ff_convert+0x2e>
  4038e4:	e001      	b.n	4038ea <ff_convert+0x46>
				if (src == Tbl[c]) break;
  4038e6:	f04f 0300 	mov.w	r3, #0
			}
			c = (c + 0x80) & 0xFF;
  4038ea:	f103 0080 	add.w	r0, r3, #128	; 0x80
  4038ee:	b2c0      	uxtb	r0, r0
  4038f0:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4038f2:	f04f 0000 	mov.w	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  4038f6:	4770      	bx	lr

004038f8 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  4038f8:	2861      	cmp	r0, #97	; 0x61
  4038fa:	d00e      	beq.n	40391a <ff_wtoupper+0x22>
  4038fc:	f644 113c 	movw	r1, #18748	; 0x493c
  403900:	f2c0 0140 	movt	r1, #64	; 0x40
  403904:	f04f 0200 	mov.w	r2, #0
  403908:	f102 0201 	add.w	r2, r2, #1
  40390c:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403910:	b15b      	cbz	r3, 40392a <ff_wtoupper+0x32>
  403912:	4283      	cmp	r3, r0
  403914:	d1f8      	bne.n	403908 <ff_wtoupper+0x10>

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403916:	b913      	cbnz	r3, 40391e <ff_wtoupper+0x26>
  403918:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  40391a:	f04f 0200 	mov.w	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  40391e:	f244 635c 	movw	r3, #18012	; 0x465c
  403922:	f2c0 0340 	movt	r3, #64	; 0x40
  403926:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  40392a:	4770      	bx	lr

0040392c <readFile>:
	}	
	dac_value=((0x2000|ch0_value)<<16)|(0x1000|ch1_value);
	return 1;
	}
	
int readFile(uint8_t channel){
  40392c:	b510      	push	{r4, lr}
	if (channel==0){
  40392e:	bb60      	cbnz	r0, 40398a <readFile+0x5e>
		r = f_read(&sample0, &buffer, sizeof(buffer), &br0);
  403930:	f640 0030 	movw	r0, #2096	; 0x830
  403934:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403938:	f640 4176 	movw	r1, #3190	; 0xc76
  40393c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403940:	f04f 0202 	mov.w	r2, #2
  403944:	f640 637c 	movw	r3, #3708	; 0xe7c
  403948:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40394c:	f243 442d 	movw	r4, #13357	; 0x342d
  403950:	f2c0 0440 	movt	r4, #64	; 0x40
  403954:	47a0      	blx	r4
  403956:	f640 4374 	movw	r3, #3188	; 0xc74
  40395a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40395e:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK){
  403960:	781b      	ldrb	r3, [r3, #0]
  403962:	2b00      	cmp	r3, #0
  403964:	d141      	bne.n	4039ea <readFile+0xbe>
			return 4;
		}
		if (sample0.fptr>sample0.fsize-2){
  403966:	f640 0330 	movw	r3, #2096	; 0x830
  40396a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40396e:	68da      	ldr	r2, [r3, #12]
  403970:	f1a2 0202 	sub.w	r2, r2, #2
  403974:	689b      	ldr	r3, [r3, #8]
  403976:	4293      	cmp	r3, r2
  403978:	d943      	bls.n	403a02 <readFile+0xd6>
			sample0.fptr=0;
  40397a:	f640 0330 	movw	r3, #2096	; 0x830
  40397e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403982:	f04f 0200 	mov.w	r2, #0
  403986:	609a      	str	r2, [r3, #8]
  403988:	e03b      	b.n	403a02 <readFile+0xd6>
		}
	}
	if (channel==1){
  40398a:	2801      	cmp	r0, #1
  40398c:	d130      	bne.n	4039f0 <readFile+0xc4>
		r = f_read(&sample1, &buffer, sizeof(buffer), &br1);
  40398e:	f640 204c 	movw	r0, #2636	; 0xa4c
  403992:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403996:	f640 4176 	movw	r1, #3190	; 0xc76
  40399a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  40399e:	f04f 0202 	mov.w	r2, #2
  4039a2:	f640 4370 	movw	r3, #3184	; 0xc70
  4039a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039aa:	f243 442d 	movw	r4, #13357	; 0x342d
  4039ae:	f2c0 0440 	movt	r4, #64	; 0x40
  4039b2:	47a0      	blx	r4
  4039b4:	f640 4374 	movw	r3, #3188	; 0xc74
  4039b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039bc:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK){
  4039be:	781b      	ldrb	r3, [r3, #0]
  4039c0:	b9cb      	cbnz	r3, 4039f6 <readFile+0xca>
			return 4;
		}
		if (sample1.fptr>sample1.fsize-2){
  4039c2:	f640 234c 	movw	r3, #2636	; 0xa4c
  4039c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039ca:	68da      	ldr	r2, [r3, #12]
  4039cc:	f1a2 0202 	sub.w	r2, r2, #2
  4039d0:	689b      	ldr	r3, [r3, #8]
  4039d2:	4293      	cmp	r3, r2
  4039d4:	d912      	bls.n	4039fc <readFile+0xd0>
			sample1.fptr=0;
  4039d6:	f640 234c 	movw	r3, #2636	; 0xa4c
  4039da:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4039de:	f04f 0200 	mov.w	r2, #0
  4039e2:	609a      	str	r2, [r3, #8]
		}
	}
	return 1;
  4039e4:	f04f 0001 	mov.w	r0, #1
  4039e8:	bd10      	pop	{r4, pc}
	
int readFile(uint8_t channel){
	if (channel==0){
		r = f_read(&sample0, &buffer, sizeof(buffer), &br0);
		if (r!=FR_OK){
			return 4;
  4039ea:	f04f 0004 	mov.w	r0, #4
  4039ee:	bd10      	pop	{r4, pc}
		}
		if (sample1.fptr>sample1.fsize-2){
			sample1.fptr=0;
		}
	}
	return 1;
  4039f0:	f04f 0001 	mov.w	r0, #1
  4039f4:	bd10      	pop	{r4, pc}
		}
	}
	if (channel==1){
		r = f_read(&sample1, &buffer, sizeof(buffer), &br1);
		if (r!=FR_OK){
			return 4;
  4039f6:	f04f 0004 	mov.w	r0, #4
  4039fa:	bd10      	pop	{r4, pc}
		}
		if (sample1.fptr>sample1.fsize-2){
			sample1.fptr=0;
		}
	}
	return 1;
  4039fc:	f04f 0001 	mov.w	r0, #1
  403a00:	bd10      	pop	{r4, pc}
  403a02:	f04f 0001 	mov.w	r0, #1
}
  403a06:	bd10      	pop	{r4, pc}

00403a08 <validate_file>:
    }
    return res;
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
  403a08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403a0c:	b08b      	sub	sp, #44	; 0x2c
  403a0e:	4606      	mov	r6, r0
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
	char * pch;
	
	if (fn[0]=='s'){
  403a10:	7803      	ldrb	r3, [r0, #0]
  403a12:	2b73      	cmp	r3, #115	; 0x73
			if (i==1) sample_num=(uint8_t)atoi(pch);
			if (i==2) sample_freq=(uint16_t)atoi(pch);
		}
	}
	else {
		return false;
  403a14:	bf18      	it	ne
  403a16:	2000      	movne	r0, #0
{
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
	char * pch;
	
	if (fn[0]=='s'){
  403a18:	d15d      	bne.n	403ad6 <validate_file+0xce>
		char temp[30];
		strcpy(temp,fn);
  403a1a:	a802      	add	r0, sp, #8
  403a1c:	4631      	mov	r1, r6
  403a1e:	f244 2351 	movw	r3, #16977	; 0x4251
  403a22:	f2c0 0340 	movt	r3, #64	; 0x40
  403a26:	4798      	blx	r3
		pch = strtok (temp,"_");
  403a28:	a802      	add	r0, sp, #8
  403a2a:	f644 311c 	movw	r1, #19228	; 0x4b1c
  403a2e:	f2c0 0140 	movt	r1, #64	; 0x40
  403a32:	f244 2361 	movw	r3, #16993	; 0x4261
  403a36:	f2c0 0340 	movt	r3, #64	; 0x40
  403a3a:	4798      	blx	r3
		int i=0;
		while (pch != NULL)
  403a3c:	2800      	cmp	r0, #0
  403a3e:	d048      	beq.n	403ad2 <validate_file+0xca>
	
	if (fn[0]=='s'){
		char temp[30];
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
  403a40:	f04f 0400 	mov.w	r4, #0
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
	uint8_t sample_num=0;
	uint16_t sample_freq=0;
  403a44:	9401      	str	r4, [sp, #4]
    return res;
}
/* Store filename into array if it is valid*/
bool validate_file(char *fn)
{
	uint8_t sample_num=0;
  403a46:	46a2      	mov	sl, r4
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
		{
			i++;
			pch = strtok (NULL, "_");
  403a48:	f644 391c 	movw	r9, #19228	; 0x4b1c
  403a4c:	f2c0 0940 	movt	r9, #64	; 0x40
  403a50:	46a0      	mov	r8, r4
  403a52:	f244 2761 	movw	r7, #16993	; 0x4261
  403a56:	f2c0 0740 	movt	r7, #64	; 0x40
			if (i==1) sample_num=(uint8_t)atoi(pch);
			if (i==2) sample_freq=(uint16_t)atoi(pch);
  403a5a:	f244 1bc5 	movw	fp, #16837	; 0x41c5
  403a5e:	f2c0 0b40 	movt	fp, #64	; 0x40
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
		{
			i++;
  403a62:	f104 0401 	add.w	r4, r4, #1
			pch = strtok (NULL, "_");
  403a66:	4640      	mov	r0, r8
  403a68:	4649      	mov	r1, r9
  403a6a:	47b8      	blx	r7
  403a6c:	4605      	mov	r5, r0
			if (i==1) sample_num=(uint8_t)atoi(pch);
  403a6e:	2c01      	cmp	r4, #1
  403a70:	d103      	bne.n	403a7a <validate_file+0x72>
  403a72:	47d8      	blx	fp
  403a74:	fa5f fa80 	uxtb.w	sl, r0
  403a78:	e004      	b.n	403a84 <validate_file+0x7c>
			if (i==2) sample_freq=(uint16_t)atoi(pch);
  403a7a:	2c02      	cmp	r4, #2
  403a7c:	d102      	bne.n	403a84 <validate_file+0x7c>
  403a7e:	47d8      	blx	fp
  403a80:	b280      	uxth	r0, r0
  403a82:	9001      	str	r0, [sp, #4]
	if (fn[0]=='s'){
		char temp[30];
		strcpy(temp,fn);
		pch = strtok (temp,"_");
		int i=0;
		while (pch != NULL)
  403a84:	2d00      	cmp	r5, #0
  403a86:	d1ec      	bne.n	403a62 <validate_file+0x5a>
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403a88:	9b01      	ldr	r3, [sp, #4]
  403a8a:	2b00      	cmp	r3, #0
  403a8c:	bf18      	it	ne
  403a8e:	f1ba 0f00 	cmpne.w	sl, #0
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403a92:	bf08      	it	eq
  403a94:	2000      	moveq	r0, #0
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403a96:	d01e      	beq.n	403ad6 <validate_file+0xce>
  403a98:	f1ba 0f0f 	cmp.w	sl, #15
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403a9c:	bf88      	it	hi
  403a9e:	2000      	movhi	r0, #0
	}
	else {
		return false;
	}
	
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
  403aa0:	d819      	bhi.n	403ad6 <validate_file+0xce>
		strcpy(samples.filenames[sample_num-1],fn);
  403aa2:	f10a 33ff 	add.w	r3, sl, #4294967295
  403aa6:	ebc3 1003 	rsb	r0, r3, r3, lsl #4
  403aaa:	f640 447c 	movw	r4, #3196	; 0xc7c
  403aae:	f2c2 0400 	movt	r4, #8192	; 0x2000
  403ab2:	eb04 0040 	add.w	r0, r4, r0, lsl #1
  403ab6:	4631      	mov	r1, r6
  403ab8:	f244 2351 	movw	r3, #16977	; 0x4251
  403abc:	f2c0 0340 	movt	r3, #64	; 0x40
  403ac0:	4798      	blx	r3
		samples.file_frequencies[sample_num-1]=sample_freq;
  403ac2:	eb04 048a 	add.w	r4, r4, sl, lsl #2
  403ac6:	9b01      	ldr	r3, [sp, #4]
  403ac8:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
	}
	else {
		return false;
	}

	return true;
  403acc:	f04f 0001 	mov.w	r0, #1
  403ad0:	e001      	b.n	403ad6 <validate_file+0xce>
	if (sample_num > 0 && sample_freq >0 && sample_num<=MAX_SAMPLES){
		strcpy(samples.filenames[sample_num-1],fn);
		samples.file_frequencies[sample_num-1]=sample_freq;
	}
	else {
		return false;
  403ad2:	f04f 0000 	mov.w	r0, #0
	}

	return true;
}
  403ad6:	b00b      	add	sp, #44	; 0x2c
  403ad8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00403adc <scan_files>:
void stopSysTick(){
	SysTick->CTRL  = 0<<SysTick_CTRL_ENABLE_Pos;
}

FRESULT scan_files (char* path)
{
  403adc:	b530      	push	{r4, r5, lr}
  403ade:	b093      	sub	sp, #76	; 0x4c
  403ae0:	4601      	mov	r1, r0
 
    char *fn; 
	
#if _USE_LFN
    static char lfn[_MAX_LFN + 1];
    fno.lfname = lfn;
  403ae2:	f240 732c 	movw	r3, #1836	; 0x72c
  403ae6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403aea:	9310      	str	r3, [sp, #64]	; 0x40
    fno.lfsize = sizeof(lfn);
  403aec:	f44f 7380 	mov.w	r3, #256	; 0x100
  403af0:	9311      	str	r3, [sp, #68]	; 0x44
#endif
    res = f_opendir(&dir, path); //Open dir
  403af2:	a801      	add	r0, sp, #4
  403af4:	f243 6309 	movw	r3, #13833	; 0x3609
  403af8:	f2c0 0340 	movt	r3, #64	; 0x40
  403afc:	4798      	blx	r3
    if (res == FR_OK)
  403afe:	4602      	mov	r2, r0
  403b00:	b9f8      	cbnz	r0, 403b42 <scan_files+0x66>
    {
	
        for (;;)
        {
            res = f_readdir(&dir, &fno);  // Read directory
  403b02:	f243 649d 	movw	r4, #13981	; 0x369d
  403b06:	f2c0 0440 	movt	r4, #64	; 0x40
			
#else
            fn = fno.fname;
#endif
            if (!(fno.fattrib & AM_DIR)){
				validate_file(fn);
  403b0a:	f643 2509 	movw	r5, #14857	; 0x3a09
  403b0e:	f2c0 0540 	movt	r5, #64	; 0x40
    if (res == FR_OK)
    {
	
        for (;;)
        {
            res = f_readdir(&dir, &fno);  // Read directory
  403b12:	a801      	add	r0, sp, #4
  403b14:	a90a      	add	r1, sp, #40	; 0x28
  403b16:	47a0      	blx	r4
            if (res != FR_OK || fno.fname[0] == 0) 
  403b18:	4602      	mov	r2, r0
  403b1a:	b990      	cbnz	r0, 403b42 <scan_files+0x66>
  403b1c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
  403b20:	b17b      	cbz	r3, 403b42 <scan_files+0x66>
               break; // if file end or error
            if (fno.fname[0] == '.')
  403b22:	2b2e      	cmp	r3, #46	; 0x2e
  403b24:	d0f5      	beq.n	403b12 <scan_files+0x36>
               continue; // dot path
#if _USE_LFN
            fn = *fno.lfname ? fno.lfname : fno.fname;
  403b26:	9810      	ldr	r0, [sp, #64]	; 0x40
  403b28:	7803      	ldrb	r3, [r0, #0]
  403b2a:	b90b      	cbnz	r3, 403b30 <scan_files+0x54>
  403b2c:	f10d 0031 	add.w	r0, sp, #49	; 0x31
			
#else
            fn = fno.fname;
#endif
            if (!(fno.fattrib & AM_DIR)){
  403b30:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
  403b34:	f003 0310 	and.w	r3, r3, #16
  403b38:	b2db      	uxtb	r3, r3
  403b3a:	2b00      	cmp	r3, #0
  403b3c:	d1e9      	bne.n	403b12 <scan_files+0x36>
				validate_file(fn);
  403b3e:	47a8      	blx	r5
  403b40:	e7e7      	b.n	403b12 <scan_files+0x36>
            }
        }
    }
    return res;
}
  403b42:	4610      	mov	r0, r2
  403b44:	b013      	add	sp, #76	; 0x4c
  403b46:	bd30      	pop	{r4, r5, pc}

00403b48 <checkSelectedSample>:

	return true;
}

int checkSelectedSample(uint8_t number){
	if (samples.file_frequencies[number]>0 && samples.filenames[number]!=NULL)
  403b48:	f640 437c 	movw	r3, #3196	; 0xc7c
  403b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403b50:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  403b54:	f8d0 01c4 	ldr.w	r0, [r0, #452]	; 0x1c4
		return 1;
	return 0;
}
  403b58:	3000      	adds	r0, #0
  403b5a:	bf18      	it	ne
  403b5c:	2001      	movne	r0, #1
  403b5e:	4770      	bx	lr

00403b60 <configure_dacc>:
	}
	return value;
	
}

void configure_dacc(void){
  403b60:	b538      	push	{r3, r4, r5, lr}
	/* Enable clock for DACC */
	pmc_enable_periph_clk(ID_DACC);
  403b62:	f04f 001e 	mov.w	r0, #30
  403b66:	f242 0391 	movw	r3, #8337	; 0x2091
  403b6a:	f2c0 0340 	movt	r3, #64	; 0x40
  403b6e:	4798      	blx	r3
	
	/* Reset DACC registers */
	dacc_reset(DACC);
  403b70:	f44f 4440 	mov.w	r4, #49152	; 0xc000
  403b74:	f2c4 0403 	movt	r4, #16387	; 0x4003
  403b78:	4620      	mov	r0, r4
  403b7a:	f241 53c1 	movw	r3, #5569	; 0x15c1
  403b7e:	f2c0 0340 	movt	r3, #64	; 0x40
  403b82:	4798      	blx	r3

	/* Half word transfer mode */
	dacc_set_transfer_mode(DACC, 1);
  403b84:	4620      	mov	r0, r4
  403b86:	f04f 0101 	mov.w	r1, #1
  403b8a:	f241 53c9 	movw	r3, #5577	; 0x15c9
  403b8e:	f2c0 0340 	movt	r3, #64	; 0x40
  403b92:	4798      	blx	r3
	dacc_set_power_save(DACC, 0, 0);
  403b94:	4620      	mov	r0, r4
  403b96:	f04f 0100 	mov.w	r1, #0
  403b9a:	460a      	mov	r2, r1
  403b9c:	f241 53f9 	movw	r3, #5625	; 0x15f9
  403ba0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ba4:	4798      	blx	r3
	/* Timing:
	 * refresh        - 0x08 (1024*8 dacc clocks)
	 * max speed mode -    0 (disabled)
	 * startup time   - 0x10 (1024 dacc clocks)
	 */
	dacc_set_timing(DACC, 0x08, 0, 0x10);
  403ba6:	4620      	mov	r0, r4
  403ba8:	f04f 0108 	mov.w	r1, #8
  403bac:	f04f 0200 	mov.w	r2, #0
  403bb0:	f04f 0310 	mov.w	r3, #16
  403bb4:	f241 6529 	movw	r5, #5673	; 0x1629
  403bb8:	f2c0 0540 	movt	r5, #64	; 0x40
  403bbc:	47a8      	blx	r5

	/* Disable TAG and select output channel DACC_CHANNEL */
	//dacc_set_channel_selection(DACC, 0);
	dacc_enable_flexible_selection(DACC);
  403bbe:	4620      	mov	r0, r4
  403bc0:	f241 53ed 	movw	r3, #5613	; 0x15ed
  403bc4:	f2c0 0340 	movt	r3, #64	; 0x40
  403bc8:	4798      	blx	r3
	
	/* Enable output channel DACC_CHANNEL */
	dacc_enable_channel(DACC, 0);
  403bca:	4620      	mov	r0, r4
  403bcc:	f04f 0100 	mov.w	r1, #0
  403bd0:	f241 655d 	movw	r5, #5725	; 0x165d
  403bd4:	f2c0 0540 	movt	r5, #64	; 0x40
  403bd8:	47a8      	blx	r5
	dacc_enable_channel(DACC, 1);
  403bda:	4620      	mov	r0, r4
  403bdc:	f04f 0101 	mov.w	r1, #1
  403be0:	47a8      	blx	r5
	/* Set up analog current */
	dacc_set_analog_control(DACC, DACC_ANALOG_CONTROL);
  403be2:	4620      	mov	r0, r4
  403be4:	f44f 7185 	mov.w	r1, #266	; 0x10a
  403be8:	f241 6371 	movw	r3, #5745	; 0x1671
  403bec:	f2c0 0340 	movt	r3, #64	; 0x40
  403bf0:	4798      	blx	r3
  403bf2:	bd38      	pop	{r3, r4, r5, pc}

00403bf4 <setData>:
	
}
void setData(uint16_t *ch_value, uint8_t *ch_digitals,uint8_t ch){
  403bf4:	b430      	push	{r4, r5}
	*ch_value=(((buffer>>8)|(buffer<<8)));
  403bf6:	f640 4376 	movw	r3, #3190	; 0xc76
  403bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403bfe:	881d      	ldrh	r5, [r3, #0]
  403c00:	881c      	ldrh	r4, [r3, #0]
  403c02:	b2a4      	uxth	r4, r4
  403c04:	f3c5 2307 	ubfx	r3, r5, #8, #8
  403c08:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
  403c0c:	b29b      	uxth	r3, r3
  403c0e:	8003      	strh	r3, [r0, #0]
	*ch_digitals|=(*ch_value & 0xF000)>>12-2*ch;
  403c10:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
  403c14:	f1c2 0206 	rsb	r2, r2, #6
  403c18:	ea4f 0242 	mov.w	r2, r2, lsl #1
  403c1c:	fa43 f302 	asr.w	r3, r3, r2
  403c20:	780a      	ldrb	r2, [r1, #0]
  403c22:	4313      	orrs	r3, r2
  403c24:	700b      	strb	r3, [r1, #0]
	*ch_value=(*ch_value & 0x0FFF);
  403c26:	8803      	ldrh	r3, [r0, #0]
  403c28:	ea4f 5303 	mov.w	r3, r3, lsl #20
  403c2c:	ea4f 5313 	mov.w	r3, r3, lsr #20
  403c30:	8003      	strh	r3, [r0, #0]
}
  403c32:	bc30      	pop	{r4, r5}
  403c34:	4770      	bx	lr
  403c36:	bf00      	nop

00403c38 <updateSamples>:
/*
	stop SysTick timer
*/
void stopSysTick(void);

int updateSamples(){
  403c38:	b538      	push	{r3, r4, r5, lr}
	digitals=0;
  403c3a:	f240 732a 	movw	r3, #1834	; 0x72a
  403c3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c42:	f04f 0200 	mov.w	r2, #0
  403c46:	701a      	strb	r2, [r3, #0]
	if (common_file){
  403c48:	f640 436a 	movw	r3, #3178	; 0xc6a
  403c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c50:	781b      	ldrb	r3, [r3, #0]
  403c52:	b1f3      	cbz	r3, 403c92 <updateSamples+0x5a>
		readFile(0);
  403c54:	4610      	mov	r0, r2
  403c56:	f643 132d 	movw	r3, #14637	; 0x392d
  403c5a:	f2c0 0340 	movt	r3, #64	; 0x40
  403c5e:	4798      	blx	r3
		setData(&ch0_value,&digitals,0);
  403c60:	f240 752a 	movw	r5, #1834	; 0x72a
  403c64:	f2c2 0500 	movt	r5, #8192	; 0x2000
  403c68:	f240 7028 	movw	r0, #1832	; 0x728
  403c6c:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403c70:	4629      	mov	r1, r5
  403c72:	f04f 0200 	mov.w	r2, #0
  403c76:	f643 34f5 	movw	r4, #15349	; 0x3bf5
  403c7a:	f2c0 0440 	movt	r4, #64	; 0x40
  403c7e:	47a0      	blx	r4
		setData(&ch1_value,&digitals,1);
  403c80:	f640 002c 	movw	r0, #2092	; 0x82c
  403c84:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403c88:	4629      	mov	r1, r5
  403c8a:	f04f 0201 	mov.w	r2, #1
  403c8e:	47a0      	blx	r4
  403c90:	e037      	b.n	403d02 <updateSamples+0xca>
	}
	else{
		if(ch0){
  403c92:	f640 4368 	movw	r3, #3176	; 0xc68
  403c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403c9a:	781b      	ldrb	r3, [r3, #0]
  403c9c:	b1ab      	cbz	r3, 403cca <updateSamples+0x92>
			readFile(0);
  403c9e:	f04f 0000 	mov.w	r0, #0
  403ca2:	f643 132d 	movw	r3, #14637	; 0x392d
  403ca6:	f2c0 0340 	movt	r3, #64	; 0x40
  403caa:	4798      	blx	r3
			setData(&ch0_value,&digitals,0);
  403cac:	f240 7028 	movw	r0, #1832	; 0x728
  403cb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403cb4:	f240 712a 	movw	r1, #1834	; 0x72a
  403cb8:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403cbc:	f04f 0200 	mov.w	r2, #0
  403cc0:	f643 33f5 	movw	r3, #15349	; 0x3bf5
  403cc4:	f2c0 0340 	movt	r3, #64	; 0x40
  403cc8:	4798      	blx	r3
		}
		if(ch1){
  403cca:	f640 4369 	movw	r3, #3177	; 0xc69
  403cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403cd2:	781b      	ldrb	r3, [r3, #0]
  403cd4:	b1ab      	cbz	r3, 403d02 <updateSamples+0xca>
			readFile(1);
  403cd6:	f04f 0001 	mov.w	r0, #1
  403cda:	f643 132d 	movw	r3, #14637	; 0x392d
  403cde:	f2c0 0340 	movt	r3, #64	; 0x40
  403ce2:	4798      	blx	r3
			setData(&ch1_value,&digitals,1);
  403ce4:	f640 002c 	movw	r0, #2092	; 0x82c
  403ce8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403cec:	f240 712a 	movw	r1, #1834	; 0x72a
  403cf0:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403cf4:	f04f 0201 	mov.w	r2, #1
  403cf8:	f643 33f5 	movw	r3, #15349	; 0x3bf5
  403cfc:	f2c0 0340 	movt	r3, #64	; 0x40
  403d00:	4798      	blx	r3
		}		
	}	
	dac_value=((0x2000|ch0_value)<<16)|(0x1000|ch1_value);
  403d02:	f640 6380 	movw	r3, #3712	; 0xe80
  403d06:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d0a:	f240 7228 	movw	r2, #1832	; 0x728
  403d0e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d12:	8811      	ldrh	r1, [r2, #0]
  403d14:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  403d18:	f640 022c 	movw	r2, #2092	; 0x82c
  403d1c:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403d20:	8812      	ldrh	r2, [r2, #0]
  403d22:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
  403d26:	b292      	uxth	r2, r2
  403d28:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  403d2c:	601a      	str	r2, [r3, #0]
	return 1;
	}
  403d2e:	f04f 0001 	mov.w	r0, #1
  403d32:	bd38      	pop	{r3, r4, r5, pc}

00403d34 <startGenerating>:
		p_pio->PIO_CODR |= (~(digitals)<<D3_GPIO);
		p_pio->PIO_SODR |= (digitals<<D3_GPIO);
		updateSamples();
	}
}
int startGenerating(){
  403d34:	b538      	push	{r3, r4, r5, lr}
	if (ch0_ss>0 && checkSelectedSample(ch0_ss-1)) ch0=true;
  403d36:	f640 436b 	movw	r3, #3179	; 0xc6b
  403d3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d3e:	781c      	ldrb	r4, [r3, #0]
  403d40:	b17c      	cbz	r4, 403d62 <startGenerating+0x2e>
  403d42:	f104 30ff 	add.w	r0, r4, #4294967295
  403d46:	b2c0      	uxtb	r0, r0
  403d48:	f643 3349 	movw	r3, #15177	; 0x3b49
  403d4c:	f2c0 0340 	movt	r3, #64	; 0x40
  403d50:	4798      	blx	r3
  403d52:	b130      	cbz	r0, 403d62 <startGenerating+0x2e>
  403d54:	f640 4368 	movw	r3, #3176	; 0xc68
  403d58:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d5c:	f04f 0201 	mov.w	r2, #1
  403d60:	701a      	strb	r2, [r3, #0]
	if (ch1_ss>0 && checkSelectedSample(ch1_ss-1)) ch1=true;
  403d62:	f640 436c 	movw	r3, #3180	; 0xc6c
  403d66:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d6a:	781d      	ldrb	r5, [r3, #0]
  403d6c:	b17d      	cbz	r5, 403d8e <startGenerating+0x5a>
  403d6e:	f105 30ff 	add.w	r0, r5, #4294967295
  403d72:	b2c0      	uxtb	r0, r0
  403d74:	f643 3349 	movw	r3, #15177	; 0x3b49
  403d78:	f2c0 0340 	movt	r3, #64	; 0x40
  403d7c:	4798      	blx	r3
  403d7e:	b130      	cbz	r0, 403d8e <startGenerating+0x5a>
  403d80:	f640 4369 	movw	r3, #3177	; 0xc69
  403d84:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d88:	f04f 0201 	mov.w	r2, #1
  403d8c:	701a      	strb	r2, [r3, #0]
	
	if (!(ch0 || ch1)) return 0;
  403d8e:	f640 4368 	movw	r3, #3176	; 0xc68
  403d92:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403d96:	781b      	ldrb	r3, [r3, #0]
  403d98:	b953      	cbnz	r3, 403db0 <startGenerating+0x7c>
  403d9a:	f640 4369 	movw	r3, #3177	; 0xc69
  403d9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403da2:	781b      	ldrb	r3, [r3, #0]
  403da4:	2b00      	cmp	r3, #0
  403da6:	f040 8087 	bne.w	403eb8 <startGenerating+0x184>
  403daa:	f04f 0000 	mov.w	r0, #0
  403dae:	bd38      	pop	{r3, r4, r5, pc}
	if (ch0 && ch1){
  403db0:	f640 4369 	movw	r3, #3177	; 0xc69
  403db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403db8:	781b      	ldrb	r3, [r3, #0]
  403dba:	2b00      	cmp	r3, #0
  403dbc:	d047      	beq.n	403e4e <startGenerating+0x11a>
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
  403dbe:	f640 437c 	movw	r3, #3196	; 0xc7c
  403dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403dc6:	eb03 0284 	add.w	r2, r3, r4, lsl #2
  403dca:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  403dce:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403dd2:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
  403dd6:	429a      	cmp	r2, r3
  403dd8:	f040 80ab 	bne.w	403f32 <startGenerating+0x1fe>
  403ddc:	e0b5      	b.n	403f4a <startGenerating+0x216>
			return 2;
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
		r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
  403dde:	f104 34ff 	add.w	r4, r4, #4294967295
  403de2:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
  403de6:	f640 417c 	movw	r1, #3196	; 0xc7c
  403dea:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403dee:	f640 0030 	movw	r0, #2096	; 0x830
  403df2:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403df6:	eb01 0144 	add.w	r1, r1, r4, lsl #1
  403dfa:	f04f 0201 	mov.w	r2, #1
  403dfe:	f243 3385 	movw	r3, #13189	; 0x3385
  403e02:	f2c0 0340 	movt	r3, #64	; 0x40
  403e06:	4798      	blx	r3
  403e08:	f640 4374 	movw	r3, #3188	; 0xc74
  403e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e10:	7018      	strb	r0, [r3, #0]
		if (r!=FR_OK) return 3;
  403e12:	781b      	ldrb	r3, [r3, #0]
  403e14:	2b00      	cmp	r3, #0
  403e16:	f040 808f 	bne.w	403f38 <startGenerating+0x204>
		current_freq=samples.file_frequencies[ch0_ss-1];
  403e1a:	f640 4378 	movw	r3, #3192	; 0xc78
  403e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e22:	f640 427c 	movw	r2, #3196	; 0xc7c
  403e26:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403e2a:	f640 416b 	movw	r1, #3179	; 0xc6b
  403e2e:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403e32:	7809      	ldrb	r1, [r1, #0]
  403e34:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403e38:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403e3c:	601a      	str	r2, [r3, #0]
		common_file=true;
  403e3e:	f640 436a 	movw	r3, #3178	; 0xc6a
  403e42:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e46:	f04f 0201 	mov.w	r2, #1
  403e4a:	701a      	strb	r2, [r3, #0]
  403e4c:	e067      	b.n	403f1e <startGenerating+0x1ea>
	}
	else{
		if (ch0){
			r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
  403e4e:	f104 34ff 	add.w	r4, r4, #4294967295
  403e52:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
  403e56:	f640 417c 	movw	r1, #3196	; 0xc7c
  403e5a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403e5e:	f640 0030 	movw	r0, #2096	; 0x830
  403e62:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403e66:	eb01 0144 	add.w	r1, r1, r4, lsl #1
  403e6a:	f04f 0201 	mov.w	r2, #1
  403e6e:	f243 3385 	movw	r3, #13189	; 0x3385
  403e72:	f2c0 0340 	movt	r3, #64	; 0x40
  403e76:	4798      	blx	r3
  403e78:	f640 4374 	movw	r3, #3188	; 0xc74
  403e7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e80:	7018      	strb	r0, [r3, #0]
			if (r!=FR_OK) return 3;
  403e82:	781b      	ldrb	r3, [r3, #0]
  403e84:	2b00      	cmp	r3, #0
  403e86:	d15a      	bne.n	403f3e <startGenerating+0x20a>
			current_freq=samples.file_frequencies[ch0_ss-1];
  403e88:	f640 4378 	movw	r3, #3192	; 0xc78
  403e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403e90:	f640 427c 	movw	r2, #3196	; 0xc7c
  403e94:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403e98:	f640 416b 	movw	r1, #3179	; 0xc6b
  403e9c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403ea0:	7809      	ldrb	r1, [r1, #0]
  403ea2:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403ea6:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403eaa:	601a      	str	r2, [r3, #0]
		}
		
		if (ch1){
  403eac:	f640 4369 	movw	r3, #3177	; 0xc69
  403eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403eb4:	781b      	ldrb	r3, [r3, #0]
  403eb6:	b393      	cbz	r3, 403f1e <startGenerating+0x1ea>
			r=f_open(&sample1,samples.filenames[ch1_ss-1],FA_OPEN_EXISTING | FA_READ);
  403eb8:	f640 436c 	movw	r3, #3180	; 0xc6c
  403ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ec0:	7819      	ldrb	r1, [r3, #0]
  403ec2:	f101 31ff 	add.w	r1, r1, #4294967295
  403ec6:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
  403eca:	f640 437c 	movw	r3, #3196	; 0xc7c
  403ece:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ed2:	f640 204c 	movw	r0, #2636	; 0xa4c
  403ed6:	f2c2 0000 	movt	r0, #8192	; 0x2000
  403eda:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  403ede:	f04f 0201 	mov.w	r2, #1
  403ee2:	f243 3385 	movw	r3, #13189	; 0x3385
  403ee6:	f2c0 0340 	movt	r3, #64	; 0x40
  403eea:	4798      	blx	r3
  403eec:	f640 4374 	movw	r3, #3188	; 0xc74
  403ef0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403ef4:	7018      	strb	r0, [r3, #0]
			if (r!=FR_OK) return 3;
  403ef6:	781b      	ldrb	r3, [r3, #0]
  403ef8:	bb23      	cbnz	r3, 403f44 <startGenerating+0x210>
			current_freq=samples.file_frequencies[ch1_ss-1];
  403efa:	f640 4378 	movw	r3, #3192	; 0xc78
  403efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
  403f02:	f640 427c 	movw	r2, #3196	; 0xc7c
  403f06:	f2c2 0200 	movt	r2, #8192	; 0x2000
  403f0a:	f640 416c 	movw	r1, #3180	; 0xc6c
  403f0e:	f2c2 0100 	movt	r1, #8192	; 0x2000
  403f12:	7809      	ldrb	r1, [r1, #0]
  403f14:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  403f18:	f8d2 21c0 	ldr.w	r2, [r2, #448]	; 0x1c0
  403f1c:	601a      	str	r2, [r3, #0]
		}		
	}		
	if (!updateSamples()) return 4;
  403f1e:	f643 4339 	movw	r3, #15417	; 0x3c39
  403f22:	f2c0 0340 	movt	r3, #64	; 0x40
  403f26:	4798      	blx	r3
  403f28:	2800      	cmp	r0, #0
  403f2a:	bf14      	ite	ne
  403f2c:	2001      	movne	r0, #1
  403f2e:	2004      	moveq	r0, #4
  403f30:	bd38      	pop	{r3, r4, r5, pc}
	if (ch1_ss>0 && checkSelectedSample(ch1_ss-1)) ch1=true;
	
	if (!(ch0 || ch1)) return 0;
	if (ch0 && ch1){
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
			return 2;
  403f32:	f04f 0002 	mov.w	r0, #2
  403f36:	bd38      	pop	{r3, r4, r5, pc}
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
		r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
		if (r!=FR_OK) return 3;
  403f38:	f04f 0003 	mov.w	r0, #3
  403f3c:	bd38      	pop	{r3, r4, r5, pc}
		common_file=true;
	}
	else{
		if (ch0){
			r=f_open(&sample0,samples.filenames[ch0_ss-1],FA_OPEN_EXISTING | FA_READ);
			if (r!=FR_OK) return 3;
  403f3e:	f04f 0003 	mov.w	r0, #3
  403f42:	bd38      	pop	{r3, r4, r5, pc}
			current_freq=samples.file_frequencies[ch0_ss-1];
		}
		
		if (ch1){
			r=f_open(&sample1,samples.filenames[ch1_ss-1],FA_OPEN_EXISTING | FA_READ);
			if (r!=FR_OK) return 3;
  403f44:	f04f 0003 	mov.w	r0, #3
  403f48:	bd38      	pop	{r3, r4, r5, pc}
	if (ch0 && ch1){
		if (samples.file_frequencies[ch0_ss-1]!=samples.file_frequencies[ch1_ss-1]){
			return 2;
		}
	}	
	if (ch0 && ch1 && ch0_ss==ch1_ss){
  403f4a:	42ac      	cmp	r4, r5
  403f4c:	f47f af7f 	bne.w	403e4e <startGenerating+0x11a>
  403f50:	e745      	b.n	403dde <startGenerating+0xaa>
  403f52:	bf00      	nop

00403f54 <main>:
	}		
	if (!updateSamples()) return 4;
	return 1;
}

int main(void){
  403f54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	Ctrl_status status;
	board_init();
  403f58:	f240 1381 	movw	r3, #385	; 0x181
  403f5c:	f2c0 0340 	movt	r3, #64	; 0x40
  403f60:	4798      	blx	r3
	
	sysclk_init();
  403f62:	f241 43ad 	movw	r3, #5293	; 0x14ad
  403f66:	f2c0 0340 	movt	r3, #64	; 0x40
  403f6a:	4798      	blx	r3
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  403f6c:	f04f 000b 	mov.w	r0, #11
  403f70:	f242 0391 	movw	r3, #8337	; 0x2091
  403f74:	f2c0 0340 	movt	r3, #64	; 0x40
  403f78:	4798      	blx	r3
	
    sysclk_enable_peripheral_clock(ID_PIOA);
	configure_dacc();
  403f7a:	f643 3361 	movw	r3, #15201	; 0x3b61
  403f7e:	f2c0 0340 	movt	r3, #64	; 0x40
  403f82:	4798      	blx	r3
	sd_mmc_init();
  403f84:	f240 6325 	movw	r3, #1573	; 0x625
  403f88:	f2c0 0340 	movt	r3, #64	; 0x40
  403f8c:	4798      	blx	r3
	card_init:
	gpio_set_pin_low(LED0_GPIO);
  403f8e:	f641 5925 	movw	r9, #7461	; 0x1d25
  403f92:	f2c0 0940 	movt	r9, #64	; 0x40
	while (CTRL_GOOD != sd_mmc_test_unit_ready(0));
  403f96:	f240 256d 	movw	r5, #621	; 0x26d
  403f9a:	f2c0 0540 	movt	r5, #64	; 0x40
	r=sd_mmc_check(0);
  403f9e:	f240 6851 	movw	r8, #1617	; 0x651
  403fa2:	f2c0 0840 	movt	r8, #64	; 0x40
  403fa6:	f640 4674 	movw	r6, #3188	; 0xc74
  403faa:	f2c2 0600 	movt	r6, #8192	; 0x2000
	r = f_mount(0, &fs);
  403fae:	f240 5704 	movw	r7, #1284	; 0x504
  403fb2:	f2c2 0700 	movt	r7, #8192	; 0x2000
	
    sysclk_enable_peripheral_clock(ID_PIOA);
	configure_dacc();
	sd_mmc_init();
	card_init:
	gpio_set_pin_low(LED0_GPIO);
  403fb6:	f04f 0000 	mov.w	r0, #0
  403fba:	47c8      	blx	r9
	while (CTRL_GOOD != sd_mmc_test_unit_ready(0));
  403fbc:	f04f 0400 	mov.w	r4, #0
  403fc0:	4620      	mov	r0, r4
  403fc2:	47a8      	blx	r5
  403fc4:	2800      	cmp	r0, #0
  403fc6:	d1fb      	bne.n	403fc0 <main+0x6c>
	r=sd_mmc_check(0);
  403fc8:	47c0      	blx	r8
  403fca:	7030      	strb	r0, [r6, #0]
	r = f_mount(0, &fs);
  403fcc:	f04f 0000 	mov.w	r0, #0
  403fd0:	4639      	mov	r1, r7
  403fd2:	f243 3351 	movw	r3, #13137	; 0x3351
  403fd6:	f2c0 0340 	movt	r3, #64	; 0x40
  403fda:	4798      	blx	r3
  403fdc:	7030      	strb	r0, [r6, #0]
	if (FR_OK != r) {
  403fde:	7833      	ldrb	r3, [r6, #0]
  403fe0:	2b00      	cmp	r3, #0
  403fe2:	d1e8      	bne.n	403fb6 <main+0x62>
			
			goto card_init;
		}
		
	r=scan_files("/");	
  403fe4:	f644 3020 	movw	r0, #19232	; 0x4b20
  403fe8:	f2c0 0040 	movt	r0, #64	; 0x40
  403fec:	f643 23dd 	movw	r3, #15069	; 0x3add
  403ff0:	f2c0 0340 	movt	r3, #64	; 0x40
  403ff4:	4798      	blx	r3
  403ff6:	7030      	strb	r0, [r6, #0]
	gpio_set_pin_high(LED1_GPIO);
  403ff8:	f04f 0006 	mov.w	r0, #6
  403ffc:	f641 5305 	movw	r3, #7429	; 0x1d05
  404000:	f2c0 0340 	movt	r3, #64	; 0x40
  404004:	4798      	blx	r3
		
	//while (!gpio_pin_is_low(BUT0_GPIO));
	ch0_ss = 2;//getSelectedSample(0);
  404006:	f640 436b 	movw	r3, #3179	; 0xc6b
  40400a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40400e:	f04f 0202 	mov.w	r2, #2
  404012:	701a      	strb	r2, [r3, #0]
	ch1_ss = 3;//getSelectedSample(1);
  404014:	f640 436c 	movw	r3, #3180	; 0xc6c
  404018:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40401c:	f04f 0203 	mov.w	r2, #3
  404020:	701a      	strb	r2, [r3, #0]
	int state;
	
	start:
	state=startGenerating();
  404022:	f643 5335 	movw	r3, #15669	; 0x3d35
  404026:	f2c0 0340 	movt	r3, #64	; 0x40
  40402a:	4798      	blx	r3
	if (state==1){
  40402c:	2801      	cmp	r0, #1
  40402e:	d164      	bne.n	4040fa <main+0x1a6>
		
		gpio_set_pin_high(LED0_GPIO);
  404030:	f04f 0000 	mov.w	r0, #0
  404034:	f641 5305 	movw	r3, #7429	; 0x1d05
  404038:	f2c0 0340 	movt	r3, #64	; 0x40
  40403c:	4798      	blx	r3
	
		if (ch0 && ch1 && !common_file){
  40403e:	f640 4368 	movw	r3, #3176	; 0xc68
  404042:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404046:	781b      	ldrb	r3, [r3, #0]
  404048:	b1e3      	cbz	r3, 404084 <main+0x130>
  40404a:	f640 4369 	movw	r3, #3177	; 0xc69
  40404e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  404052:	781b      	ldrb	r3, [r3, #0]
  404054:	b1b3      	cbz	r3, 404084 <main+0x130>
  404056:	f640 436a 	movw	r3, #3178	; 0xc6a
  40405a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40405e:	781b      	ldrb	r3, [r3, #0]
  404060:	b983      	cbnz	r3, 404084 <main+0x130>
			if (current_freq>MAX_FREQ_2FILES)
  404062:	f640 4378 	movw	r3, #3192	; 0xc78
  404066:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40406a:	681a      	ldr	r2, [r3, #0]
  40406c:	f24c 3350 	movw	r3, #50000	; 0xc350
  404070:	429a      	cmp	r2, r3
  404072:	d91c      	bls.n	4040ae <main+0x15a>
				current_freq=MAX_FREQ_2FILES;
  404074:	f640 4378 	movw	r3, #3192	; 0xc78
  404078:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40407c:	f24c 3250 	movw	r2, #50000	; 0xc350
  404080:	601a      	str	r2, [r3, #0]
  404082:	e056      	b.n	404132 <main+0x1de>
		}
		else{
			if (current_freq>MAX_FREQ_1FILES)
  404084:	f640 4378 	movw	r3, #3192	; 0xc78
  404088:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40408c:	f645 7290 	movw	r2, #24464	; 0x5f90
  404090:	f2c0 0201 	movt	r2, #1
  404094:	681b      	ldr	r3, [r3, #0]
  404096:	4293      	cmp	r3, r2
  404098:	d909      	bls.n	4040ae <main+0x15a>
				current_freq=MAX_FREQ_1FILES;
  40409a:	f640 4378 	movw	r3, #3192	; 0xc78
  40409e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4040a2:	f645 7290 	movw	r2, #24464	; 0x5f90
  4040a6:	f2c0 0201 	movt	r2, #1
  4040aa:	601a      	str	r2, [r3, #0]
  4040ac:	e041      	b.n	404132 <main+0x1de>
		}						
			
		SysTick_Config(sysclk_get_cpu_hz()/current_freq);
  4040ae:	f640 4278 	movw	r2, #3192	; 0xc78
  4040b2:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4040b6:	f44f 6360 	mov.w	r3, #3584	; 0xe00
  4040ba:	f2c0 7327 	movt	r3, #1831	; 0x727
  4040be:	6812      	ldr	r2, [r2, #0]
  4040c0:	fbb3 f3f2 	udiv	r3, r3, r2
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
  4040c4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  4040c8:	d21b      	bcs.n	404102 <main+0x1ae>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  4040ca:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  4040ce:	f103 32ff 	add.w	r2, r3, #4294967295
  4040d2:	f24e 0310 	movw	r3, #57360	; 0xe010
  4040d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
  4040da:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4040dc:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  4040e0:	f2ce 0200 	movt	r2, #57344	; 0xe000
  4040e4:	f04f 01f0 	mov.w	r1, #240	; 0xf0
  4040e8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  4040ec:	f04f 0200 	mov.w	r2, #0
  4040f0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  4040f2:	f04f 0207 	mov.w	r2, #7
  4040f6:	601a      	str	r2, [r3, #0]
  4040f8:	e003      	b.n	404102 <main+0x1ae>
	}		
	else if(state>=3){
  4040fa:	2802      	cmp	r0, #2
  4040fc:	f77f af5b 	ble.w	403fb6 <main+0x62>
  404100:	e000      	b.n	404104 <main+0x1b0>
  404102:	e7fe      	b.n	404102 <main+0x1ae>
	}
	while(1);
	//while (gpio_pin_is_high(BUT0_GPIO));
	
	close_files:
	f_close(&sample0);
  404104:	f640 0030 	movw	r0, #2096	; 0x830
  404108:	f2c2 0000 	movt	r0, #8192	; 0x2000
  40410c:	f243 54e9 	movw	r4, #13801	; 0x35e9
  404110:	f2c0 0440 	movt	r4, #64	; 0x40
  404114:	47a0      	blx	r4
	f_close(&sample1);
  404116:	f640 204c 	movw	r0, #2636	; 0xa4c
  40411a:	f2c2 0000 	movt	r0, #8192	; 0x2000
  40411e:	47a0      	blx	r4
	
	f_mount(0, NULL);
  404120:	f04f 0000 	mov.w	r0, #0
  404124:	4601      	mov	r1, r0
  404126:	f243 3351 	movw	r3, #13137	; 0x3351
  40412a:	f2c0 0340 	movt	r3, #64	; 0x40
  40412e:	4798      	blx	r3
	goto card_init;
  404130:	e741      	b.n	403fb6 <main+0x62>
		else{
			if (current_freq>MAX_FREQ_1FILES)
				current_freq=MAX_FREQ_1FILES;
		}						
			
		SysTick_Config(sysclk_get_cpu_hz()/current_freq);
  404132:	f640 4278 	movw	r2, #3192	; 0xc78
  404136:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40413a:	f44f 6360 	mov.w	r3, #3584	; 0xe00
  40413e:	f2c0 7327 	movt	r3, #1831	; 0x727
  404142:	6812      	ldr	r2, [r2, #0]
  404144:	fbb3 f3f2 	udiv	r3, r3, r2
  404148:	e7bf      	b.n	4040ca <main+0x176>
  40414a:	bf00      	nop

0040414c <SysTick_Handler>:
	}
	return 1;
}

void SysTick_Handler(void)
{
  40414c:	b508      	push	{r3, lr}
	/* If ready for new data */
	if ((dacc_get_interrupt_status(DACC) & DACC_ISR_TXRDY) == DACC_ISR_TXRDY) {
  40414e:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  404152:	f2c4 0003 	movt	r0, #16387	; 0x4003
  404156:	f241 53e5 	movw	r3, #5605	; 0x15e5
  40415a:	f2c0 0340 	movt	r3, #64	; 0x40
  40415e:	4798      	blx	r3
  404160:	f010 0f01 	tst.w	r0, #1
  404164:	d026      	beq.n	4041b4 <SysTick_Handler+0x68>
		dacc_write_conversion_data(DACC, dac_value);
  404166:	f640 6380 	movw	r3, #3712	; 0xe80
  40416a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40416e:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  404172:	f2c4 0003 	movt	r0, #16387	; 0x4003
  404176:	6819      	ldr	r1, [r3, #0]
  404178:	f241 53e9 	movw	r3, #5609	; 0x15e9
  40417c:	f2c0 0340 	movt	r3, #64	; 0x40
  404180:	4798      	blx	r3
		p_pio->PIO_CODR |= (~(digitals)<<D3_GPIO);
  404182:	f240 0304 	movw	r3, #4
  404186:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40418a:	681b      	ldr	r3, [r3, #0]
  40418c:	6b59      	ldr	r1, [r3, #52]	; 0x34
  40418e:	f240 722a 	movw	r2, #1834	; 0x72a
  404192:	f2c2 0200 	movt	r2, #8192	; 0x2000
  404196:	7812      	ldrb	r2, [r2, #0]
  404198:	ea6f 0002 	mvn.w	r0, r2
  40419c:	ea41 2140 	orr.w	r1, r1, r0, lsl #9
  4041a0:	6359      	str	r1, [r3, #52]	; 0x34
		p_pio->PIO_SODR |= (digitals<<D3_GPIO);
  4041a2:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4041a4:	ea41 2242 	orr.w	r2, r1, r2, lsl #9
  4041a8:	631a      	str	r2, [r3, #48]	; 0x30
		updateSamples();
  4041aa:	f643 4339 	movw	r3, #15417	; 0x3c39
  4041ae:	f2c0 0340 	movt	r3, #64	; 0x40
  4041b2:	4798      	blx	r3
  4041b4:	bd08      	pop	{r3, pc}
  4041b6:	bf00      	nop

004041b8 <atexit>:
  4041b8:	4601      	mov	r1, r0
  4041ba:	2000      	movs	r0, #0
  4041bc:	4602      	mov	r2, r0
  4041be:	4603      	mov	r3, r0
  4041c0:	f000 b920 	b.w	404404 <__register_exitproc>

004041c4 <atoi>:
  4041c4:	2100      	movs	r1, #0
  4041c6:	220a      	movs	r2, #10
  4041c8:	f000 b90e 	b.w	4043e8 <strtol>

004041cc <_atoi_r>:
  4041cc:	2200      	movs	r2, #0
  4041ce:	230a      	movs	r3, #10
  4041d0:	f000 b882 	b.w	4042d8 <_strtol_r>

004041d4 <__libc_fini_array>:
  4041d4:	b570      	push	{r4, r5, r6, lr}
  4041d6:	4b09      	ldr	r3, [pc, #36]	; (4041fc <__libc_fini_array+0x28>)
  4041d8:	4c09      	ldr	r4, [pc, #36]	; (404200 <__libc_fini_array+0x2c>)
  4041da:	2500      	movs	r5, #0
  4041dc:	1ae4      	subs	r4, r4, r3
  4041de:	10a4      	asrs	r4, r4, #2
  4041e0:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  4041e4:	e002      	b.n	4041ec <__libc_fini_array+0x18>
  4041e6:	5972      	ldr	r2, [r6, r5]
  4041e8:	4790      	blx	r2
  4041ea:	3c01      	subs	r4, #1
  4041ec:	3d04      	subs	r5, #4
  4041ee:	2c00      	cmp	r4, #0
  4041f0:	d1f9      	bne.n	4041e6 <__libc_fini_array+0x12>
  4041f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  4041f6:	f000 bd23 	b.w	404c40 <_fini>
  4041fa:	bf00      	nop
  4041fc:	00404c4c 	.word	0x00404c4c
  404200:	00404c50 	.word	0x00404c50

00404204 <__libc_init_array>:
  404204:	b570      	push	{r4, r5, r6, lr}
  404206:	4b0e      	ldr	r3, [pc, #56]	; (404240 <__libc_init_array+0x3c>)
  404208:	4d0e      	ldr	r5, [pc, #56]	; (404244 <__libc_init_array+0x40>)
  40420a:	2400      	movs	r4, #0
  40420c:	1aed      	subs	r5, r5, r3
  40420e:	10ad      	asrs	r5, r5, #2
  404210:	461e      	mov	r6, r3
  404212:	e003      	b.n	40421c <__libc_init_array+0x18>
  404214:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  404218:	4790      	blx	r2
  40421a:	3401      	adds	r4, #1
  40421c:	42ac      	cmp	r4, r5
  40421e:	d1f9      	bne.n	404214 <__libc_init_array+0x10>
  404220:	f000 fd04 	bl	404c2c <_init>
  404224:	4d08      	ldr	r5, [pc, #32]	; (404248 <__libc_init_array+0x44>)
  404226:	4b09      	ldr	r3, [pc, #36]	; (40424c <__libc_init_array+0x48>)
  404228:	2400      	movs	r4, #0
  40422a:	1aed      	subs	r5, r5, r3
  40422c:	10ad      	asrs	r5, r5, #2
  40422e:	461e      	mov	r6, r3
  404230:	e003      	b.n	40423a <__libc_init_array+0x36>
  404232:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  404236:	4790      	blx	r2
  404238:	3401      	adds	r4, #1
  40423a:	42ac      	cmp	r4, r5
  40423c:	d1f9      	bne.n	404232 <__libc_init_array+0x2e>
  40423e:	bd70      	pop	{r4, r5, r6, pc}
  404240:	00404c38 	.word	0x00404c38
  404244:	00404c38 	.word	0x00404c38
  404248:	00404c40 	.word	0x00404c40
  40424c:	00404c38 	.word	0x00404c38

00404250 <strcpy>:
  404250:	4603      	mov	r3, r0
  404252:	f811 2b01 	ldrb.w	r2, [r1], #1
  404256:	f803 2b01 	strb.w	r2, [r3], #1
  40425a:	2a00      	cmp	r2, #0
  40425c:	d1f9      	bne.n	404252 <strcpy+0x2>
  40425e:	4770      	bx	lr

00404260 <strtok>:
  404260:	4b02      	ldr	r3, [pc, #8]	; (40426c <strtok+0xc>)
  404262:	681a      	ldr	r2, [r3, #0]
  404264:	2301      	movs	r3, #1
  404266:	325c      	adds	r2, #92	; 0x5c
  404268:	f000 b802 	b.w	404270 <__strtok_r>
  40426c:	20000008 	.word	0x20000008

00404270 <__strtok_r>:
  404270:	b5f0      	push	{r4, r5, r6, r7, lr}
  404272:	b910      	cbnz	r0, 40427a <__strtok_r+0xa>
  404274:	6810      	ldr	r0, [r2, #0]
  404276:	2800      	cmp	r0, #0
  404278:	d02a      	beq.n	4042d0 <__strtok_r+0x60>
  40427a:	4604      	mov	r4, r0
  40427c:	4627      	mov	r7, r4
  40427e:	7838      	ldrb	r0, [r7, #0]
  404280:	3401      	adds	r4, #1
  404282:	460e      	mov	r6, r1
  404284:	e008      	b.n	404298 <__strtok_r+0x28>
  404286:	42a8      	cmp	r0, r5
  404288:	d106      	bne.n	404298 <__strtok_r+0x28>
  40428a:	2b00      	cmp	r3, #0
  40428c:	d1f6      	bne.n	40427c <__strtok_r+0xc>
  40428e:	6014      	str	r4, [r2, #0]
  404290:	4638      	mov	r0, r7
  404292:	f804 3c01 	strb.w	r3, [r4, #-1]
  404296:	bdf0      	pop	{r4, r5, r6, r7, pc}
  404298:	f816 5b01 	ldrb.w	r5, [r6], #1
  40429c:	2d00      	cmp	r5, #0
  40429e:	d1f2      	bne.n	404286 <__strtok_r+0x16>
  4042a0:	4623      	mov	r3, r4
  4042a2:	b908      	cbnz	r0, 4042a8 <__strtok_r+0x38>
  4042a4:	6010      	str	r0, [r2, #0]
  4042a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4042a8:	f813 0b01 	ldrb.w	r0, [r3], #1
  4042ac:	460f      	mov	r7, r1
  4042ae:	461e      	mov	r6, r3
  4042b0:	f817 5b01 	ldrb.w	r5, [r7], #1
  4042b4:	4285      	cmp	r5, r0
  4042b6:	d108      	bne.n	4042ca <__strtok_r+0x5a>
  4042b8:	b118      	cbz	r0, 4042c2 <__strtok_r+0x52>
  4042ba:	2100      	movs	r1, #0
  4042bc:	f803 1c01 	strb.w	r1, [r3, #-1]
  4042c0:	e000      	b.n	4042c4 <__strtok_r+0x54>
  4042c2:	4606      	mov	r6, r0
  4042c4:	6016      	str	r6, [r2, #0]
  4042c6:	1e60      	subs	r0, r4, #1
  4042c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4042ca:	2d00      	cmp	r5, #0
  4042cc:	d1f0      	bne.n	4042b0 <__strtok_r+0x40>
  4042ce:	e7eb      	b.n	4042a8 <__strtok_r+0x38>
  4042d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

004042d2 <strtok_r>:
  4042d2:	2301      	movs	r3, #1
  4042d4:	f7ff bfcc 	b.w	404270 <__strtok_r>

004042d8 <_strtol_r>:
  4042d8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4042dc:	9001      	str	r0, [sp, #4]
  4042de:	4841      	ldr	r0, [pc, #260]	; (4043e4 <_strtol_r+0x10c>)
  4042e0:	f8d0 9000 	ldr.w	r9, [r0]
  4042e4:	4608      	mov	r0, r1
  4042e6:	4604      	mov	r4, r0
  4042e8:	f814 5b01 	ldrb.w	r5, [r4], #1
  4042ec:	eb09 0605 	add.w	r6, r9, r5
  4042f0:	7877      	ldrb	r7, [r6, #1]
  4042f2:	4620      	mov	r0, r4
  4042f4:	f007 0708 	and.w	r7, r7, #8
  4042f8:	b2ff      	uxtb	r7, r7
  4042fa:	2f00      	cmp	r7, #0
  4042fc:	d1f3      	bne.n	4042e6 <_strtol_r+0xe>
  4042fe:	2d2d      	cmp	r5, #45	; 0x2d
  404300:	d103      	bne.n	40430a <_strtol_r+0x32>
  404302:	f814 5b01 	ldrb.w	r5, [r4], #1
  404306:	2701      	movs	r7, #1
  404308:	e004      	b.n	404314 <_strtol_r+0x3c>
  40430a:	2d2b      	cmp	r5, #43	; 0x2b
  40430c:	bf04      	itt	eq
  40430e:	4624      	moveq	r4, r4
  404310:	f814 5b01 	ldrbeq.w	r5, [r4], #1
  404314:	2b00      	cmp	r3, #0
  404316:	d05e      	beq.n	4043d6 <_strtol_r+0xfe>
  404318:	2b10      	cmp	r3, #16
  40431a:	d108      	bne.n	40432e <_strtol_r+0x56>
  40431c:	e058      	b.n	4043d0 <_strtol_r+0xf8>
  40431e:	7820      	ldrb	r0, [r4, #0]
  404320:	2878      	cmp	r0, #120	; 0x78
  404322:	d001      	beq.n	404328 <_strtol_r+0x50>
  404324:	2858      	cmp	r0, #88	; 0x58
  404326:	d14e      	bne.n	4043c6 <_strtol_r+0xee>
  404328:	7865      	ldrb	r5, [r4, #1]
  40432a:	2310      	movs	r3, #16
  40432c:	3402      	adds	r4, #2
  40432e:	2f00      	cmp	r7, #0
  404330:	bf0c      	ite	eq
  404332:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  404336:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  40433a:	fbb0 faf3 	udiv	sl, r0, r3
  40433e:	2600      	movs	r6, #0
  404340:	fb03 081a 	mls	r8, r3, sl, r0
  404344:	4630      	mov	r0, r6
  404346:	eb09 0c05 	add.w	ip, r9, r5
  40434a:	f89c c001 	ldrb.w	ip, [ip, #1]
  40434e:	f00c 0b04 	and.w	fp, ip, #4
  404352:	fa5f fb8b 	uxtb.w	fp, fp
  404356:	f1bb 0f00 	cmp.w	fp, #0
  40435a:	d001      	beq.n	404360 <_strtol_r+0x88>
  40435c:	3d30      	subs	r5, #48	; 0x30
  40435e:	e00b      	b.n	404378 <_strtol_r+0xa0>
  404360:	f01c 0c03 	ands.w	ip, ip, #3
  404364:	d01b      	beq.n	40439e <_strtol_r+0xc6>
  404366:	f1bc 0f01 	cmp.w	ip, #1
  40436a:	bf14      	ite	ne
  40436c:	f04f 0c57 	movne.w	ip, #87	; 0x57
  404370:	f04f 0c37 	moveq.w	ip, #55	; 0x37
  404374:	ebcc 0505 	rsb	r5, ip, r5
  404378:	429d      	cmp	r5, r3
  40437a:	da10      	bge.n	40439e <_strtol_r+0xc6>
  40437c:	f1b6 3fff 	cmp.w	r6, #4294967295
  404380:	d00a      	beq.n	404398 <_strtol_r+0xc0>
  404382:	4550      	cmp	r0, sl
  404384:	d806      	bhi.n	404394 <_strtol_r+0xbc>
  404386:	d101      	bne.n	40438c <_strtol_r+0xb4>
  404388:	4545      	cmp	r5, r8
  40438a:	dc03      	bgt.n	404394 <_strtol_r+0xbc>
  40438c:	fb03 5000 	mla	r0, r3, r0, r5
  404390:	2601      	movs	r6, #1
  404392:	e001      	b.n	404398 <_strtol_r+0xc0>
  404394:	f04f 36ff 	mov.w	r6, #4294967295
  404398:	f814 5b01 	ldrb.w	r5, [r4], #1
  40439c:	e7d3      	b.n	404346 <_strtol_r+0x6e>
  40439e:	1c73      	adds	r3, r6, #1
  4043a0:	d10a      	bne.n	4043b8 <_strtol_r+0xe0>
  4043a2:	2f00      	cmp	r7, #0
  4043a4:	9901      	ldr	r1, [sp, #4]
  4043a6:	bf0c      	ite	eq
  4043a8:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  4043ac:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  4043b0:	2322      	movs	r3, #34	; 0x22
  4043b2:	600b      	str	r3, [r1, #0]
  4043b4:	b922      	cbnz	r2, 4043c0 <_strtol_r+0xe8>
  4043b6:	e012      	b.n	4043de <_strtol_r+0x106>
  4043b8:	b107      	cbz	r7, 4043bc <_strtol_r+0xe4>
  4043ba:	4240      	negs	r0, r0
  4043bc:	b17a      	cbz	r2, 4043de <_strtol_r+0x106>
  4043be:	b106      	cbz	r6, 4043c2 <_strtol_r+0xea>
  4043c0:	1e61      	subs	r1, r4, #1
  4043c2:	6011      	str	r1, [r2, #0]
  4043c4:	e00b      	b.n	4043de <_strtol_r+0x106>
  4043c6:	2530      	movs	r5, #48	; 0x30
  4043c8:	2b00      	cmp	r3, #0
  4043ca:	d1b0      	bne.n	40432e <_strtol_r+0x56>
  4043cc:	2308      	movs	r3, #8
  4043ce:	e7ae      	b.n	40432e <_strtol_r+0x56>
  4043d0:	2d30      	cmp	r5, #48	; 0x30
  4043d2:	d1ac      	bne.n	40432e <_strtol_r+0x56>
  4043d4:	e7a3      	b.n	40431e <_strtol_r+0x46>
  4043d6:	2d30      	cmp	r5, #48	; 0x30
  4043d8:	d0a1      	beq.n	40431e <_strtol_r+0x46>
  4043da:	230a      	movs	r3, #10
  4043dc:	e7a7      	b.n	40432e <_strtol_r+0x56>
  4043de:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4043e2:	bf00      	nop
  4043e4:	20000438 	.word	0x20000438

004043e8 <strtol>:
  4043e8:	b530      	push	{r4, r5, lr}
  4043ea:	4613      	mov	r3, r2
  4043ec:	4a04      	ldr	r2, [pc, #16]	; (404400 <strtol+0x18>)
  4043ee:	4605      	mov	r5, r0
  4043f0:	460c      	mov	r4, r1
  4043f2:	6810      	ldr	r0, [r2, #0]
  4043f4:	4629      	mov	r1, r5
  4043f6:	4622      	mov	r2, r4
  4043f8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  4043fc:	f7ff bf6c 	b.w	4042d8 <_strtol_r>
  404400:	20000008 	.word	0x20000008

00404404 <__register_exitproc>:
  404404:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  404408:	4698      	mov	r8, r3
  40440a:	4b23      	ldr	r3, [pc, #140]	; (404498 <__register_exitproc+0x94>)
  40440c:	4606      	mov	r6, r0
  40440e:	681c      	ldr	r4, [r3, #0]
  404410:	460f      	mov	r7, r1
  404412:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  404416:	4691      	mov	r9, r2
  404418:	b918      	cbnz	r0, 404422 <__register_exitproc+0x1e>
  40441a:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  40441e:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  404422:	6841      	ldr	r1, [r0, #4]
  404424:	291f      	cmp	r1, #31
  404426:	dd16      	ble.n	404456 <__register_exitproc+0x52>
  404428:	4b1c      	ldr	r3, [pc, #112]	; (40449c <__register_exitproc+0x98>)
  40442a:	b91b      	cbnz	r3, 404434 <__register_exitproc+0x30>
  40442c:	f04f 30ff 	mov.w	r0, #4294967295
  404430:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404434:	f44f 70c8 	mov.w	r0, #400	; 0x190
  404438:	f3af 8000 	nop.w
  40443c:	2800      	cmp	r0, #0
  40443e:	d0f5      	beq.n	40442c <__register_exitproc+0x28>
  404440:	f8d4 1148 	ldr.w	r1, [r4, #328]	; 0x148
  404444:	2500      	movs	r5, #0
  404446:	6045      	str	r5, [r0, #4]
  404448:	6001      	str	r1, [r0, #0]
  40444a:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  40444e:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  404452:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  404456:	b1b6      	cbz	r6, 404486 <__register_exitproc+0x82>
  404458:	6844      	ldr	r4, [r0, #4]
  40445a:	2201      	movs	r2, #1
  40445c:	fa02 f204 	lsl.w	r2, r2, r4
  404460:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  404464:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  404468:	4311      	orrs	r1, r2
  40446a:	2e02      	cmp	r6, #2
  40446c:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  404470:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  404474:	461c      	mov	r4, r3
  404476:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  40447a:	d104      	bne.n	404486 <__register_exitproc+0x82>
  40447c:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  404480:	431a      	orrs	r2, r3
  404482:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  404486:	6843      	ldr	r3, [r0, #4]
  404488:	1c9a      	adds	r2, r3, #2
  40448a:	3301      	adds	r3, #1
  40448c:	f840 7022 	str.w	r7, [r0, r2, lsl #2]
  404490:	6043      	str	r3, [r0, #4]
  404492:	2000      	movs	r0, #0
  404494:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404498:	00404b24 	.word	0x00404b24
  40449c:	00000000 	.word	0x00000000

004044a0 <register_fini>:
  4044a0:	4b02      	ldr	r3, [pc, #8]	; (4044ac <register_fini+0xc>)
  4044a2:	b113      	cbz	r3, 4044aa <register_fini+0xa>
  4044a4:	4802      	ldr	r0, [pc, #8]	; (4044b0 <register_fini+0x10>)
  4044a6:	f7ff be87 	b.w	4041b8 <atexit>
  4044aa:	4770      	bx	lr
  4044ac:	00000000 	.word	0x00000000
  4044b0:	004041d5 	.word	0x004041d5

004044b4 <sd_trans_multipliers>:
  4044b4:	00000000 0000000a 0000000c 0000000d     ................
  4044c4:	0000000f 00000014 00000019 0000001e     ................
  4044d4:	00000023 00000028 0000002d 00000032     #...(...-...2...
  4044e4:	00000037 0000003c 00000046 00000050     7...<...F...P...

004044f4 <sd_mmc_trans_units>:
  4044f4:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00404510 <mmc_trans_multipliers>:
  404510:	00000000 0000000a 0000000c 0000000d     ................
  404520:	0000000f 00000014 0000001a 0000001e     ................
  404530:	00000023 00000028 0000002d 00000034     #...(...-...4...
  404540:	00000037 0000003c 00000046 00000050     7...<...F...P...

00404550 <lun_desc>:
  404550:	004002ad 004002fd 00400335 00400365     ..@...@.5.@.e.@.
  404560:	004003d5 0040044d 00404588 004002c1     ..@.M.@..E@...@.
  404570:	00400311 00400349 00400379 004003ed     ..@.I.@.y.@...@.
  404580:	00400465 004045a0 2f445322 20434d4d     e.@..E@."SD/MMC 
  404590:	64726143 6f6c5320 22302074 00000000     Card Slot 0"....
  4045a0:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  4045b0:	22312074 00000000 3c3a2a22 7f7c3f3e     t 1"...."*:<>?|.
  4045c0:	00000000 3d3b2c2b 00005d5b              ....+,;=[]..

004045cc <LfnOfs>:
  4045cc:	07050301 12100e09 1c181614 0000001e     ................

004045dc <excvt.4405>:
  4045dc:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  4045ec:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  4045fc:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  40460c:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  40461c:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  40462c:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  40463c:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  40464c:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................

0040465c <tbl_upper.4241>:
  40465c:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  40466c:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  40467c:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  40468c:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  40469c:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  4046ac:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  4046bc:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  4046cc:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  4046dc:	01040102 01080106 010c010a 0110010e     ................
  4046ec:	01140112 01180116 011c011a 0120011e     .............. .
  4046fc:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  40470c:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  40471c:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  40472c:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  40473c:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  40474c:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  40475c:	03940393 03960395 03980397 039a0399     ................
  40476c:	039c039b 039e039d 03a0039f 03a303a1     ................
  40477c:	03a503a4 03a703a6 03a903a8 041003aa     ................
  40478c:	04120411 04140413 04160415 04180417     ................
  40479c:	041a0419 041c041b 041e041d 0420041f     .............. .
  4047ac:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  4047bc:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  4047cc:	04030402 04050404 04070406 04090408     ................
  4047dc:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  4047ec:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  4047fc:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  40480c:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  40481c:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  40482c:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...

0040483c <Tbl>:
  40483c:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  40484c:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  40485c:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  40486c:	00d600ff 00f800dc 00d800a3 019200d7     ................
  40487c:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  40488c:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  40489c:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  4048ac:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  4048bc:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  4048cc:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  4048dc:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  4048ec:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  4048fc:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  40490c:	00da00de 00d900db 00dd00fd 00b400af     ................
  40491c:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  40492c:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

0040493c <tbl_lower.4240>:
  40493c:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  40494c:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  40495c:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  40496c:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  40497c:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  40498c:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  40499c:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  4049ac:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  4049bc:	01050103 01090107 010d010b 0111010f     ................
  4049cc:	01150113 01190117 011d011b 0121011f     ..............!.
  4049dc:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  4049ec:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  4049fc:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  404a0c:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  404a1c:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  404a2c:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  404a3c:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  404a4c:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  404a5c:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  404a6c:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  404a7c:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  404a8c:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  404a9c:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  404aac:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  404abc:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  404acc:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  404adc:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  404aec:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  404afc:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  404b0c:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...
  404b1c:	0000005f 0000002f                       _.../...

00404b24 <_global_impure_ptr>:
  404b24:	20000010 20000043                                ... C.

00404b2a <_ctype_>:
  404b2a:	20202000 20202020 28282020 20282828     .         ((((( 
  404b3a:	20202020 20202020 20202020 20202020                     
  404b4a:	10108820 10101010 10101010 10101010      ...............
  404b5a:	04040410 04040404 10040404 10101010     ................
  404b6a:	41411010 41414141 01010101 01010101     ..AAAAAA........
  404b7a:	01010101 01010101 01010101 10101010     ................
  404b8a:	42421010 42424242 02020202 02020202     ..BBBBBB........
  404b9a:	02020202 02020202 02020202 10101010     ................
  404baa:	00000020 00000000 00000000 00000000      ...............
	...

00404c2c <_init>:
  404c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404c2e:	bf00      	nop
  404c30:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404c32:	bc08      	pop	{r3}
  404c34:	469e      	mov	lr, r3
  404c36:	4770      	bx	lr

00404c38 <__init_array_start>:
  404c38:	004044a1 	.word	0x004044a1

00404c3c <__frame_dummy_init_array_entry>:
  404c3c:	00400149                                I.@.

00404c40 <_fini>:
  404c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404c42:	bf00      	nop
  404c44:	bcf8      	pop	{r3, r4, r5, r6, r7}
  404c46:	bc08      	pop	{r3}
  404c48:	469e      	mov	lr, r3
  404c4a:	4770      	bx	lr

00404c4c <__fini_array_start>:
  404c4c:	00400121 	.word	0x00400121
